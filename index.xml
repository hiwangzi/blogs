<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>WANG!</title><link>https://hiwangzi.com/</link><description>Recent content on WANG!</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 21 May 2020 12:05:27 +0800</lastBuildDate><atom:link href="https://hiwangzi.com/index.xml" rel="self" type="application/rss+xml"/><item><title>截图 | 识别二维码</title><link>https://hiwangzi.com/posts/2020/05/21/mac-scan-qr-code-from-pasteboard-after-screen-capture/</link><pubDate>Thu, 21 May 2020 12:05:27 +0800</pubDate><guid>https://hiwangzi.com/posts/2020/05/21/mac-scan-qr-code-from-pasteboard-after-screen-capture/</guid><description>macOS中截图后识别二维码</description></item><item><title>Hugo Now</title><link>https://hiwangzi.com/posts/2019/04/17/hugo-now/</link><pubDate>Wed, 17 Apr 2019 18:15:45 +0800</pubDate><guid>https://hiwangzi.com/posts/2019/04/17/hugo-now/</guid><description>从 Hexo 切换到 Hugo！</description></item><item><title>java.util.List 的 remove(int) 与 remove(Object)</title><link>https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/</link><pubDate>Sun, 08 Jul 2018 11:29:16 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/</guid><description>最近看到 V2EX 上一个帖子《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。</description></item><item><title>译｜在 URLs 中使用 JSON</title><link>https://hiwangzi.com/posts/2018/05/14/json-in-urls/</link><pubDate>Mon, 14 May 2018 00:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/05/14/json-in-urls/</guid><description>除了在 URL 中使用路径作为参数或使用查询参数之外，是否还有更好的选择呢？</description></item><item><title>译｜if(a - b &lt; 0) 与 if(a &lt; b) 的区别</title><link>https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/</link><pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/</guid><description>一个针对此问题 Stack Overflow 上的回答。</description></item><item><title>安装 Arch 中遇到的 Broadcom b43(BCM43228) 网卡问题</title><link>https://hiwangzi.com/posts/2018/03/25/arch-install-with-bcm/</link><pubDate>Sun, 25 Mar 2018 00:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/03/25/arch-install-with-bcm/</guid><description>之前按照《以官方 Wiki 的方式安装 ArchLinux》，并结合官方文档，成功的在 VirtualBox 环境下安装好了 Arch。虚拟机限于内存、显卡等因素，体验不够好，因此今天准备在旧笔记本实机安装。在第一步联网过程中，就遇到了阻碍，特此记录。</description></item><item><title>什么是 Unix</title><link>https://hiwangzi.com/posts/2018/02/03/what-is-unix/</link><pubDate>Sat, 03 Feb 2018 00:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/02/03/what-is-unix/</guid><description>关于内核 当计算机启动时，计算机要经历一系列动作，这些动作构成了引导过程。引导过程的最后一个动作是启动一个非常复杂的程序，该程序就被称为内核（Kernel）。 内核的作用是控制计算机，提供基础服务，是操作系统的核心。 内核有许多种类型，但基本可以分为两大类： 单内核：一个庞大的程序自身可以完成所有的事 微内核：一个非常小的程序只执行最基本的任务，其余通过调用其他程序（称为服务器(server)）实现 内核的使用： 大多数 Unix 系统使用的是某种类型的单内核，一些 Unix （例如 OS X，Minix）使用微内核。 Linux 是单内核。 补：Linus 阅读了 Andrew Tanenbaum 的《Operating System: Design and Implementation》，该书解释了 Minix 的设计原则。Linus 选择使用单内核设计 Linux，而 Andrew Tanenbaum 设计的 Minix 使用的是微内核。在 Linux 开始引起注意后不久，Tanenbaum 公开批判这种设计决策。直到今天，Tanenbaum 仍然在批评这种单内核设计。 关于 Unix Unix = Unix 内核 + Unix 实用工具 Unix 过去是属于 AT&amp;amp;T 的商标（必须为大写 UNIX，以下的全大写均指 AT&amp;amp;T 公司的 Unix） 现在可以理解为指代任何 “类Unix” 系统 关于 “类Unix” 的两种理解： 如果操作系统既包含一个 Unix 内核以及一些 Unix 实用工具，又可以运行能够在其他 Unix 操作系统上运行的程序，那么它就是 Unix 系统 如果理解 Unix 的人说这个系统是 Unix，那么它就是 Unix Unix 的历史 20世纪70年代的 Unix：由贝尔实验室转向 Berkeley</description></item><item><title>vim 常用操作笔记</title><link>https://hiwangzi.com/posts/2017/12/07/vim-newbie-note/</link><pubDate>Thu, 07 Dec 2017 21:39:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/12/07/vim-newbie-note/</guid><description> 跳转最后一行 :$ 或 shift+g 跳转第一行 :1 或 gg 设置自动换行 :set wrap 设置不自动换行 :set nowrap</description></item><item><title>《图解HTTP》笔记——Web 基础</title><link>https://hiwangzi.com/posts/2017/12/03/http-note-web/</link><pubDate>Sun, 03 Dec 2017 10:29:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/12/03/http-note-web/</guid><description>Web 基础 三项构建技术：
HTML：页面的文本标记语言 HTTP：文档传输协议 URL：指定文档所在地址 一些概念 HTTP（HyperText Transfer Protocol）：通常被译为“超文本传输协议”，但严谨应译为“超文本转移协议”
传输（transport）：从端到端可靠地搬运比特，属于 TCP/IP 中传输层（transport layer）协议处理的事 转移（transfer）：在客户端-服务器之间转移一些带有操作语义的原语，来执行某些操作，属于TCP/IP中应用层的事务。 HTTP 版本
HTTP/0.9：并没有作为正式标准被建立 HTTP/1.0：公布于 1996 年 5 月，记录于 RFC1945 HTTP/1.1：公布于 1997 年 1 月，最初标准为 RFC 2068，后来发布修订版 RFC2616，目前主流被使用的版本 HTTP/2.0 TCP/IP 协议族
应用层 （FTP、DNS、HTTP&amp;hellip;） 传输层 用于提供处于网络连接中的两台计算机之间的数据传输（TCP、UDP） 网络层 用来处理在网络上流动的数据包（IP） 数据链路层 用来处理连接网络的硬件部分 HTTP over TCP/IP 通信传输图解：</description></item><item><title>PostgreSQL 满足条件时插入数据</title><link>https://hiwangzi.com/posts/2017/11/23/conditional-insert-into-statement-in-postgres/</link><pubDate>Thu, 23 Nov 2017 22:26:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/11/23/conditional-insert-into-statement-in-postgres/</guid><description>例如：当表中不存在某记录时，才插入这条记录。
INSERT INTO 表名(列名1, 列名2) SELECT &amp;#39;值1&amp;#39;, &amp;#39;值2&amp;#39; WHERE NOT EXISTS ( SELECT * FROM 表名 WHERE 列名1 = &amp;#39;值1&amp;#39;, 列名2 = &amp;#39;值2&amp;#39; ); 参考 PostgreSQL: Documentation: 10: INSERT
This example inserts some rows into table films from a table tmp_films with the same column layout as films:
INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &amp;lt; '2004-05-07'; database - Conditional INSERT INTO statement in postgres - Stack Overflow</description></item><item><title>【Redis 笔记】常用命令</title><link>https://hiwangzi.com/posts/2017/11/21/redis-command/</link><pubDate>Tue, 21 Nov 2017 11:20:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/11/21/redis-command/</guid><description> 编号 命令 描述 1 DEL key 此命令删除一个指定键(如果存在)。 2 DUMP key 此命令返回存储在指定键的值的序列化版本。 3 EXISTS key 此命令检查键是否存在。 4 EXPIRE key seconds 设置键在指定时间秒数之后到期/过期。 5 EXPIREAT key timestamp 设置在指定时间戳之后键到期/过期。这里的时间是Unix时间戳格式。 6 PEXPIRE key milliseconds 设置键的到期时间(以毫秒为单位)。 7 PEXPIREAT key milliseconds-timestamp 以Unix时间戳形式来设置键的到期时间(以毫秒为单位)。 8 KEYS pattern 查找与指定模式匹配的所有键。 9 MOVE key db 将键移动到另一个数据库。 10 PERSIST key 删除指定键的过期时间，得永生。 11 PTTL key 获取键的剩余到期时间(以毫秒为单位)。 12 RANDOMKEY 从Redis返回一个随机的键。 13 RENAME key newkey 更改键的名称。 14 RENAMENX key newkey 如果新键不存在，重命名键。 15 TYPE key 返回存储在键中的值的数据类型。</description></item><item><title>【Redis 笔记】数据类型</title><link>https://hiwangzi.com/posts/2017/11/21/redis-data-type/</link><pubDate>Tue, 21 Nov 2017 10:41:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/11/21/redis-data-type/</guid><description>REmote DIctionary Server(Redis)，一个 key-value 存储系统。
数据类型 Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
string
string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，一个键最大能存储 512MB。 相关命令：set, get 127.0.0.1:6379&amp;gt; set str1 hello OK 127.0.0.1:6379&amp;gt; get str1 &amp;#34;hello&amp;#34; hash
hash 是键值对的集合。 每个 hash 可以存储 2^32 - 1 个（超过 40 亿个）键值对。 相关命令：hmset, hmget, hgetall 127.0.0.1:6379&amp;gt; hmset hashmap1 name hiwangzi blog hiwangzi.com OK 127.0.0.1:6379&amp;gt; hmget hashmap1 name 1) &amp;#34;hiwangzi&amp;#34; 127.</description></item><item><title>命令行计算 RSA, Base64, Hash</title><link>https://hiwangzi.com/posts/2017/11/20/calculate-rsa-base64-hash-in-terminal/</link><pubDate>Mon, 20 Nov 2017 15:05:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/11/20/calculate-rsa-base64-hash-in-terminal/</guid><description>OpenSSL 是个好工具 👍</description></item><item><title>如此</title><link>https://hiwangzi.com/posts/2017/10/31/so/</link><pubDate>Tue, 31 Oct 2017 21:55:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/31/so/</guid><description>抑制偏见，拥抱世界。
&amp;mdash; Zi WANG (@zill057) October 29, 2017 有了记录之后，仍然会觉得，时间眨眼飞逝。
去年的今天，写下了 我的十月 这篇博文，再读来，真的觉得当时的自己的生活还算称得上有趣啦。也许就如花花所说，我一直在粉饰自己过去的时光，所以才总是会觉得现在的自己真是大不如从前。
人虽然总是在变化，可变化有时却没那么快。或许未来的自己会觉得今天的我也并非充足的努力，可此刻的我还是愿意鼓励自我的现状。或许没有去年的十月那么多值得记录的事情，但我知道，自己在踏实的前进。
没有什么更多的事说了，如此&amp;hellip;</description></item><item><title>全栈框架——MEAN</title><link>https://hiwangzi.com/posts/2017/10/25/mean/</link><pubDate>Wed, 25 Oct 2017 17:22:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/25/mean/</guid><description>MEAN: MongoDB - Express - AngularJs - Node.js
MongoDB 是一个面向文档的、 NoSQL 类型的数据库。MongoDB 颠覆了传统的基于表的数据存储方式，而采取了类似 JSON 的文档结构来存储数据，因而它在存储数据时可以更加灵活。 Express 是一个 Node.js 框架，可以创建灵活的 Web 服务，比如单页面应用程序、多页面应用程序和混合型 App。 AngularJS 是一个开源的 JavaScript 框架，由 Google 和开源社区共同维护，它用来创建单页面应用程序。它的目标是使用 model-view-controller 模式来规范 Web 应用程序，让开发和测试富交互的单页面应用程序变得更加轻松。 Node.js 是一个运行在服务器端的 JavaScript 运行环境，它的底层是基于 Chrome 的 JavaScript 运行环境——V8 引擎。Node.js 可以作为服务器端语言，用来创建快速、可扩展的应用程序。Node.js 也可以在本机运行，做一些本地操作，比如加速本地开发流程，或者实现一键发布。 MEAN 可以说是传统的 LAMP 方案的有力竞争者。因为从服务器端到页面端都采用同样的语言（JavaScript）和同样的架构模式（MVC），所以一个擅长 JavaScript 的工程师可以兼顾前后端的开发，并且前端代码和后台代码是可以复用的。</description></item><item><title>(转载) IaaS, PaaS, Saas</title><link>https://hiwangzi.com/posts/2017/10/25/iaas-paas-saas/</link><pubDate>Wed, 25 Oct 2017 17:20:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/25/iaas-paas-saas/</guid><description>如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：买服务器，安装服务器软件，编写网站程序。
现在你追随潮流，采用流行的云计算，如果你采用 IaaS 服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件
而如果你采用 PaaS 的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序
如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为 SaaS 。
作者：John Wang 链接：https://www.zhihu.com/question/20387284/answer/28514161 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</description></item><item><title>【Java 核心笔记】04.07. 反射</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-07/</link><pubDate>Sat, 14 Oct 2017 18:27:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-07/</guid><description>能够分析类能力的程序称为反射(reflective)，其可以： 在运行中分析类 在运行中查看对象 编写泛型数组代码 调用任意方法 java.lang.Class 类用于描述 JVM 中使用的类。 在运行中分析类 java.lang.reflect中三个重要的类Field、Method、Constructor分别用于描述类的域、方法、构造器。 Class类对象的 getFields、getMethods、getConstructors方法将分别返回类提供的public 域、方法和构造器数组（包含超类的公有成员） getDeclaredFields、getDeclaredMethods、getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器数组（但不包含超类的成员）。 在运行中分析对象 在获取Field对象后，通过其get方法，可以得到某个对象该字段的值。 直接访问私有域，get方法会抛出IllegalAccessException异常。但如果一个Java程序没有受到安全管理器的控制，就可以通过Field对象的setAccessible方法覆盖访问控制（Method、Constructor同理）。 通过get方法得到的是Object。如果字段为基本类型，会将其打包为包装类型，并以Object形式返回。 通过set方法可以修改字段的值。 编写泛型数组代码 将一个 Employee[] 临时地转换成 Object[] 数组， 然后再把它转换回来是可以的， 但最开始就是 Object[] 的数组却永远不能转换成 Employe[] 数组。（但可以进行单个元素的转换） Employee[] employees = new Employee[10]; Object[] objects = employees; System.out.println((Employee[]) objects); // 可以转换 objects = new Object[10]; System.out.println((Employee[]) objects); // java.lang.ClassCastException 以下是利用反射实现任意类型数组拷贝的例子： private static Object goodCopyOf(Object array, int newLength) { Objects.</description></item><item><title>【Java 核心笔记】04.06. UML、类的一些要点补充</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-06/</link><pubDate>Sat, 14 Oct 2017 18:01:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-06/</guid><description>类间关系 依赖(dependence)（uses-a）：例如Order对象使用Account对象查看账户的信用状态 聚合(aggregation)（has-a）：例如Order对象包含了一些Item对象 继承(inheritance)（is-a） 对应的 UML 符号 有些方法学家不喜欢聚合这个概念，而更加喜欢「关联(association)」这个术语。但「has-a」更加形象，同时「关联」的 UML 符号不易区分。
以下是一个UML类图的示例：
类的一些要点补充 使用类的方法时，会隐式包含一个参数——方法名前的类对象（方法之中使用this调用），这被称为隐式(implicit)参数。其他参数称为显式(explicit)参数。 方法接收参数的形式是按值调用(call by value)。 可以通过「方法的签名(signature)」来完整地描述一个方法（方法名+参数类型，不包含返回类型），例如String类的indexOf方法 indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int) 默认域的初始化 如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。 但局部变量不可，必须明确地初始化方法中的局部变量。 类中代码执行顺序原则： 静态优先（静态域、静态代码块） 对于非静态，顺序为：域(初始化语句)、构造代码块（初始化块）、构造方法 总结：父类静态元素 -&amp;gt; 子类静态元素 -&amp;gt; 父类非静态元素 -&amp;gt; 子类非静态元素 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。 包 从编译器的角度来看，嵌套的包之间没有任何关系。 import java.time.* 对代码的大小无负面影响，但会降低人可读性。 只能使用星号(*)导入 一个 包，而不能使用import java.*或import java.*.*导入以java为前缀的所有包。 在包中定位类是编译器的工作，字节码中使用完整的包名引用其他类。 import static java.</description></item><item><title>【Java 核心笔记】04.05. 内部类</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-05/</link><pubDate>Sat, 14 Oct 2017 16:44:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-05/</guid><description>在类的内部还可以定义另一个类。如果在类 Outter 的内部再定义一个类 Inner ，此时类 Inner 就称为内部类，而类 Outter 则称为外部类。 内部类可声明为 public 或 private。当内部类声明为 public 或 private 时，对其访问的限制与成员变量和成员方法完全相同。
class Outer { // 定义外部类 private String info = &amp;#34;hello world&amp;#34;; // 定义外部类的私有属性 class Inner { // 定义内部类 public void print(){ // 定义内部类的方法 System.out.println(info); // 直接访问外部类的私有属性 } } public void fun() { // 定义外部类的方法 new Inner().print(); // 通过内部类的实例化对象调用方法 } } public class InnerClassDemo01 { public static void main(String args[]){ new Outer().</description></item><item><title>【Java 核心笔记】04.04. 代码块</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-04/</link><pubDate>Sat, 14 Oct 2017 15:52:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-04/</guid><description>代码块就是使用 {} 括起来的一段代码，根据位置不同，可分为四类：
普通代码块 构造代码块 静态代码块 同步代码块 普通代码块 直接定义在方法中的代码块称为普通代码块。
public class Demo { public static void main(String args[]) { { // 普通代码块 int x = 30; // 属于局部变量 System.out.println(&amp;#34;普通代码块 --&amp;gt; x = &amp;#34; + x); } int x = 100; // 与局部变量名称相同 System.out.println(&amp;#34;代码块之外 --&amp;gt; x = &amp;#34; + x); } } // 输出 // 普通代码块 --&amp;gt; x = 30 // 代码块之外 --&amp;gt; x = 100 构造代码块 直接在类中定义的代码块，称为构造块。</description></item><item><title>scp 命令简明介绍</title><link>https://hiwangzi.com/posts/2017/10/11/scp-newbie-note/</link><pubDate>Wed, 11 Oct 2017 10:53:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/11/scp-newbie-note/</guid><description> 安全复制（英语：Secure copy，缩写SCP）是指在本地主机与远程主机或者两台远程主机之间基于Secure Shell（SSH）协议安全地传输电脑文件。“SCP”通常指安全复制协议或者程序本身。安全复制 - 维基百科，自由的百科全书
其使用方法类似于 cp 命令。
复制文件或目录命令：
复制文件：
将本地文件拷贝到远程 scp 文件名 --用户名@计算机IP或者计算机名称:远程路径 从远程将文件拷回本地 scp --用户名@计算机IP或者计算机名称:文件名 本地路径 复制目录：
将本地目录拷贝到远程 scp -r 目录名 用户名@计算机IP或者计算机名称:远程路径 从远程将目录拷回本地 scp -r 用户名@计算机IP或者计算机名称:目录名 本地路径 注意，如果远程主机使用非默认端口22，可以在命令中指定。例如，从远程主机复制一个文件到本地。
scp -P 2222 user@host:directory/SourceFile TargetFile</description></item><item><title>《鸟哥的Linux私房菜》笔记——04. 简单命令行</title><link>https://hiwangzi.com/posts/2017/10/09/vbird-linux-04/</link><pubDate>Mon, 09 Oct 2017 18:25:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/09/vbird-linux-04/</guid><description>键入命令 [zill@hiwangzi.com ~]$ command [-options] parameter1 parameter2 ... 指令 选项 参数(1) 参数(2) 注意：有时也可以使用 + 放置于选项或参数之前
例如：
zill@zill-pc:~$ date +%Y/%m/%d 2017/10/09 zill@zill-pc:~$ date +%H:%M 17:32 几个程序 显示日期与时间的指令： date 显示日历的指令： cal 简单好用的计算器： bc（进入交互界面后 scale=number 设置小数点位数） 几个按键 [Tab]：主要用于自动补全 [Ctrl]-c：中断当前程序 [Ctrl]-d：通常代表「键盘输入结束（End Of File, EOF 或 End Of Input）」的意思（可以代替手动输入 exit） [Shift]+{[PageUP]|[Page Down]}：向前翻页|向后翻页 关于帮助文档 1. man 表格的第一行，可以看到「DATE(1)」，其中(1)代表「一般使用者可以使用的指令」。
常见代号及含义（可以通过 man man 获得更详细的说明）：
代号 代表内容 1 使用者在shell环境中可以操作的指令 2 系统核心可调用的函数与工具等 3 一些常用的函數(function)与函数库(library)，大部分为C的函数库(libc) 4 硬件的说明，通常在/dev下的文件 5 设置文件或者是某些文件的格式 6 游戏(games) 7 惯例与协定，例如Linux文件系统、网络协议、ASCII code等等的说明 8 系统管理员可以使用的管理指令 9 跟kernel有关的文件 可以使用 man -f 指令 查找相关指令（名称完全相同）。 可以使用 man -k 指令 搜索相关指令。</description></item><item><title>《鸟哥的Linux私房菜》笔记——03. 磁盘分区</title><link>https://hiwangzi.com/posts/2017/10/09/vbird-linux-03/</link><pubDate>Mon, 09 Oct 2017 14:37:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/09/vbird-linux-03/</guid><description>Everything is a file.
常见硬件对应于 Linux 下的文件（/dev目录下）
装置 装置在Linux内的档名 SCSI/SATA/U盘硬盘机 /dev/sd[a-p] U盘 /dev/sd[a-p]（与SATA相同） VirtI/O界面 /dev/vd[a-p]（用于虚拟机内） 软盘机 /dev/fd[0-1] 打印机 25针: /dev/lp[0-2]; USB: /dev/usb/lp[0-15] 鼠标 PS2: /dev/psaux; USB: /dev/usb/mouse[0-15] CDROM/DVDROM /dev/scd[0-1]（通用）; /dev/sr[0-1]（通用，CentOS较常见） 当前CDROM/DVDROM /dev/cdrom 当前的鼠标 /dev/mouse 磁带机 IDE: /dev/ht0; SATA/SCSI: /dev/st0 IDE硬盘机 /dev/hd[a-d]（近乎被淘汰） MBR 分区方式 硬盘的第一个扇区主要记录了两个重要的信息，分别是：</description></item><item><title>【Java 核心笔记】04.03. 匿名对象与字符串缓冲池</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-03/</link><pubDate>Sat, 07 Oct 2017 21:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-03/</guid><description>匿名对象 匿名对象：只在堆内存中开辟空间，不存在栈内存的引用。 由于匿名对象没有对应的栈内存引用所指向，所以使用一次之后，就等待被垃圾回收了。 例：一个单独的字符串就是一个 String 的匿名对象。System.out.println(&amp;quot;Hi&amp;quot;); 字符串缓冲池 public class Test { public static void main(String[] args) { String str = &amp;#34;hello&amp;#34; ; System.out.println(&amp;#34;hello&amp;#34;.equals(str)) ; // true System.out.println(&amp;#34;hello&amp;#34; == str); // true // String 池：Java为了优化字符串操作 提供了一个缓冲池； // str 指向字符串 “hello” ,第二句中字符串 “hello” ，因为字符串在常量池中已经存在，第二句中字符串 “hello” 就不再开辟空间。 // 所以不管是 equals 比较内容， == 比较内存地址都为 true // 但请不要使用这种方式比较字符串，不稳键 } } 下面的代码验证了我去「XXXX」面试时真的是乱吹🙈： /* * 当时我以为 JVM 的缓冲池可以实现“变量(a)连接字符串(&amp;#34;b&amp;#34;)可以与&amp;#34;ab&amp;#34;使用同一个堆内存” * 但是事实是并不可行 */ public class StringTest{ public static void main(String [] args){ String ab=&amp;#34;ab&amp;#34;; String a=&amp;#34;a&amp;#34;; // 「变量」与「变量连接字符串（匿名对象）」比较 System.</description></item><item><title>【Java 核心笔记】04.02. Override 的补充</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-02/</link><pubDate>Sat, 07 Oct 2017 17:31:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-02/</guid><description>方法的覆写 当子类定义了与父类方法名称相同、参数的类型及个数、返回值相同的方法时，就被称为方法的覆写。
被覆写的方法不能拥有比父类方法更严格的访问权限。private &amp;lt; default &amp;lt; protected &amp;lt; public
如果父类中的方法使用了 private 声明，而子类中同样的方法使用了 public 声明，这样属于覆写么？不属于。 class A { public void fun() { print(); } /*①*/ void print() { System.out.println(&amp;#34;父类中的 print() 方法&amp;#34;); } } class B extends A { /*②*/ void print() { // 覆写的是 print() 方法 System.out.println(&amp;#34;子类中的 print() 方法&amp;#34;); } } public class OverrideDemo { public static void main(String [] args) { B b = new B(); b.</description></item><item><title>【Java 核心笔记】04.01. 继承与多态、重写Object类方法</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-01/</link><pubDate>Sat, 07 Oct 2017 17:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-01/</guid><description>继承 Java 中只允许单继承。 一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。 子类不能覆盖父类中 final 修饰的方法（final 类中所有方法自动地成为 final 方法，并且 final 类不能被继承）。 在父类转子类的类型转换前，可以先借助 instanceof 操作符，查看是否能够转换成功。 if (staff instanceof Manager) { boss = (Manager) staff; } 在超类（父类）设计合理的情况下，很少会使用到类型转换和 instanceof 运算符。 动态绑定、静态绑定 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。 如果是 private 方法、static 方法、final 方法或者构造器，编译器可以准确知道应该调用哪个方法，此种调用方式称为静态绑定（static binding）。 抽象类 包含一个或多个抽象方法的类本身必须被声明为抽象的。 除了抽象方法，抽象类还可以包含具体数据和具体方法。 扩展抽象类有两种选择： 一是部分实现抽象方法，此时子类仍需标记为抽象类； 二是定义全部抽象方法。 类即使不包含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。 访问控制 仅对本类可见—— private
对本包可见——默认，不需要修饰符（package private）
对本包和所有子类可见—— protected</description></item><item><title>《鸟哥的Linux私房菜》笔记——02. 关于Linux</title><link>https://hiwangzi.com/posts/2017/10/02/vbird-linux-02/</link><pubDate>Mon, 02 Oct 2017 12:28:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/02/vbird-linux-02/</guid><description>Unix 历史 1969年以前：伟大的梦想——Bell, MIT 与 GE 的「Multics」系统 1969年：Ken Thompson 的小型 file server system 1973年：Unix 正式诞生（Ritchie等人以 C 语言写出第一个正式 Unix核心） 1977年：重要的 Unix 分支——BSD 的诞生 1979年：重要的 System V 架构（支持x86）与版权宣告 1984年之一：x86 架构的 Minix 操作系统开始编写并于两年后诞生 1984年之二：GNU 计划与 FSF(Free Software Foundation) 基金会的成立 1988年：图形界面 XFree86(X Window System + Free + x86) 计划 1991年：芬兰大学生 Linux Torvalds 的一则简讯 Linux 的核心版本 2.6.18-92.el5 主版本.次版本.释出版本-修改版本 核心被分为两个分支：
主、次版本为奇数：发展中版本(development) 如2.5.xx，这种核心版本主要用在测试与发展新功能，所以通常这种版本仅有核心开发工程师会使用。 如果有新增的核心程序代码，会加到这种版本当中，等到众多工程师测试没问题后，才加入下一版的稳定核心中； 主、次版本为偶数：稳定版本(stable) 如2.6.xx，等到核心功能发展成熟后会加到这类的版本中，主要用在一般家庭计算机以及企业版本中。 重点在于提供使用者一个相对稳定的Linux作业环境平台。 Linux 是一个操作系统最底层的核心以及其提供的核心工具。他是 GNU GPL 授权模式，所以，任何人均可取得源代码，并且可以修改。</description></item><item><title>《鸟哥的Linux私房菜》笔记——01. 计算机概论</title><link>https://hiwangzi.com/posts/2017/10/02/vbird-linux-01/</link><pubDate>Mon, 02 Oct 2017 11:11:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/02/vbird-linux-01/</guid><description>计算机的五大部分：输入单元、输出单元、CPU（控制单元(Control Unit)、算数逻辑单元(ALU)）、内存。 CPU 的架构
精简指令集（Reduced Instruction Set Computing, RISC），例如：SPARC，ARM 复杂指令集（Complex Instruction Set Computing, RISC），例如：Intel/AMD x86 架构 CPU
外频：CPU 与外部组件进行数据传输时的速度 内频：CPU 内部用来加速工作性能的一个倍数 注：
两者相乘为 CPU 的频率速度 超频：将CPU的倍频或外频更改为更高，但倍频通常被锁定，经常被修改的是外频。 主板芯片组
北桥：系统总线（速度相对较快），内存传输的主要信道 南桥：I/O 总线，连接硬盘、USB、网卡等设备 注：
北桥所支持的频率称为前端总线速度（Front Side Bus, FSB），而每次传送的位数则是总线宽度。 CPU 每次能够处理的数据量称为字组大小（word size）
计算机被称为“32位”或“64位”的主要依据 早期“32位”的CPU中，因为CPU每次能够解析的数据量有限，因此由内存传来的数据量就有所限制，即导致了“32位”CPU最多只能支持到4GB内存 内存主要组件 动态随机访问内存（Dynamic Random Access Memory, DRAM）
CPU 内部第二层缓存（L2 Cache）使用静态随机访问内存（Static Random Access Memory, SRAM） 计算机的分类</description></item><item><title>【Java 核心笔记】04. 面向对象</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-04/</link><pubDate>Wed, 27 Sep 2017 16:11:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-04/</guid><description>面向对象的三大特征 封装（Encapsulation）：对外部不可见 继承（Inheritance）：扩展类的功能 多态（Polymorphism）：一个对象变量可以指示多种实际类型的现象被称为多态 关于重载（Overload）、重写（Override）、多态 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，但是考虑到程序设计的一致性，重载时尽量保证方法的返回值类型相同。
重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。即外壳不变，核心重写。
区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改，但最好相同 可以有可协变的返回类型 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 参考 http://www.runoob.com/java/java-override-overload.html
关于重写（Override）的返回类型：
返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。 例如，假设Employee类有public Employee getBuddy() {}，在子类Manager中，可以按照 public Manager getBuddy() {} 方式覆盖这个方法。这样就可以说，这两个 getBuddy() 方法就有可协变的返回类型。 多态是同一个行为具有多个不同表现形式或形态的能力。
多态的三个必要条件： 继承 重写 父类引用指向子类对象 内存划分：对象创建之初 类属于引用传递类型，同样存在着“栈内存-堆内存”的引用关系</description></item><item><title>【Java 核心笔记】03. 关于数组</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-03/</link><pubDate>Wed, 27 Sep 2017 16:01:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-03/</guid><description>数组的定义及使用 声明及开辟数组空间 声明数组
int score [] = null; // null表示引用数据类型的默认值 int [] score = null; // 与上一句等价 为数组开辟空间
补充：堆栈内存解释 数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是无法使用的，必须有指向的堆内存才可以使用； 要想开辟新的堆内存，则必须使用 new 关键字，之后只是将此内存的使用权交给了对应的栈内存空间，而且一个堆内存可以被多个栈内存空间指向。 数组的静态初始化 一维数组 int score[] = {1,2,3,4,5}; 二维数组 声明之后再赋值
int arr[][] = new int[4][3]; // 声明并实例化二维数组 arr[0][0] = 201604; arr[0][1] = 1; arr[1][1] = 11; arr[2][2] = 22; arr[3][1] = 31; 声明同时赋值
// 每行的数组元素个数不一样，分配空间不同 public class ArrayDemo { public static void main(String args[]){ int score[][] = { {67,61},{78,89,83},{99,100,98,66,95} }; for(int i=0; i&amp;lt;score.</description></item><item><title>【Java 核心笔记】02. 数据类型与运算符</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-02/</link><pubDate>Wed, 27 Sep 2017 10:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-02/</guid><description>数据类型 概述 注意：
在 Java 中，小数默认类型为 double，整数默认类型是 int 基本数据类型的默认值（开发中尽可能为每一个变量赋初值） 类型 默认值 byte (byte) 0 short (short) 0 int 0 long 0L float 0.0f double 0.0d char \u0000 boolean false 基本数据类型 整型 注意：Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。 不同进制的表示形式：
十六进制数值有一个前缀 0x 或 0X（如0xCAFE）。 八进制有一个前缀 0，例如，010 对应十进制中的 8 。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。 从Java 7开始，加上前缀 0b 或 0B 就可以写二进制数。例如， 0b1001 就是 9 。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用（1_000_000 或 0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。 浮点类型 可以使用十六进制表示浮点数值。例如，0.</description></item><item><title>【Java 核心笔记】01. Java介绍</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-01/</link><pubDate>Wed, 27 Sep 2017 10:27:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-01/</guid><description>「白皮书」关键术语 简单性 C++&amp;ndash; 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java 发展历程 SUN公司——Stanford University Network 主设计者：James Gosling 1996年初 - 发布 Java 1.0 Java 2, JDK 1.2 有了很大的改变 - 更加接近“一次编写，随处运行”的承诺 J2SE 5.0 得到了进一步改进 - 泛型、(以下几项受 C# 启发) foreach、自动装箱、注解 2014年 - 发布 Java 8 - 重大改变：提供了一种「函数式」编程方式，可以容易地表述并发执行的计算 Java 主要技术分支 Java SE Java 2 Platform, Standard Edition 前身：J2SE，2005年更名为Java SE Java EE（主要应用） Java 2 Platform, Enterprise Edition 前身：J2EE，2005年更名为Java EE Java ME（嵌入式） Java 2 Platform, Micro Edition 前身：J2ME，2005年更名为Java ME JVM, JRE, JDK JVM(Java Virtual Machine) &amp;lt; JRE(Java Runtime Environment) &amp;lt; JDK(Java Development Kit) “跨平台” 与 “解释执行” 早期的 Java是解释型的。现在 Java 虚拟机使用了即时编译器，因此采用 Java 编写的“热点”代码其运行速度与 C++ 相差无几，有些情况下甚至更快。 Java 开发环境 Path 的主要功能是设置 JDK 的可执行命令 classpath 主要是在执行的时候起作用，告诉JVM类的保存路径，一般（默认）设置为.</description></item><item><title>「cmd」与「网卡」—— netsh 命令</title><link>https://hiwangzi.com/posts/2017/09/04/netsh-newbie-note/</link><pubDate>Mon, 04 Sep 2017 19:13:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/04/netsh-newbie-note/</guid><description>1. 通过命令提示符（cmd）命令连接 Wi-Fi 1.1 连接曾经连接过的 Wi-Fi :: 查看配置的列表（::表示注释） netsh wlan show profile :: 连接 netsh wlan connect ssid=你的SSID名字(简单可以理解为Wi-Fi名) name=你的配置名字 1.2 连接从未连接过的 Wi-Fi :: 先增加一项 Wi-Fi 配置，注意要在配置文件所在目录执行 netsh wlan add profile filename=&amp;#34;你的配置.xml&amp;#34; :: 查看配置的列表，检查是否添加成功 netsh wlan show profile :: 连接 netsh wlan connect ssid=你的SSID名字 name=你的配置名字 示例配置文件 &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;WLANProfile xmlns=&amp;#34;http://www.microsoft.com/networking/WLAN/profile/v1&amp;#34;&amp;gt; &amp;lt;name&amp;gt;你的配置名字（与SSID名字相同即可）&amp;lt;/name&amp;gt; &amp;lt;SSIDConfig&amp;gt; &amp;lt;SSID&amp;gt; &amp;lt;name&amp;gt;你的SSID名字&amp;lt;/name&amp;gt; &amp;lt;/SSID&amp;gt; &amp;lt;/SSIDConfig&amp;gt; &amp;lt;connectionType&amp;gt;ESS&amp;lt;/connectionType&amp;gt; &amp;lt;connectionMode&amp;gt;auto&amp;lt;/connectionMode&amp;gt; &amp;lt;MSM&amp;gt; &amp;lt;security&amp;gt; &amp;lt;authEncryption&amp;gt; &amp;lt;authentication&amp;gt;WPA2PSK&amp;lt;/authentication&amp;gt; &amp;lt;encryption&amp;gt;AES&amp;lt;/encryption&amp;gt; &amp;lt;useOneX&amp;gt;false&amp;lt;/useOneX&amp;gt; &amp;lt;/authEncryption&amp;gt; &amp;lt;sharedKey&amp;gt; &amp;lt;keyType&amp;gt;passPhrase&amp;lt;/keyType&amp;gt; &amp;lt;protected&amp;gt;false&amp;lt;/protected&amp;gt; &amp;lt;keyMaterial&amp;gt;你的WiFi密码&amp;lt;/keyMaterial&amp;gt; &amp;lt;/sharedKey&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/MSM&amp;gt; &amp;lt;MacRandomization xmlns=&amp;#34;http://www.</description></item><item><title>代码与数据</title><link>https://hiwangzi.com/posts/2017/09/03/code-and-data/</link><pubDate>Sun, 03 Sep 2017 13:20:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/03/code-and-data/</guid><description>半年之前，第一次接触到这种将函数作为参数传递的做法，当时实在觉得难以理解。
PHP 的变量真的是啥都能装，不管函数还是类，这个真的是灵活到飘逸🙈。另外，“魔术方法”哈哈哈哈哈哈哈🌞好酷哦... pic.twitter.com/nxGwbBKAEl
&amp;mdash; Zi WANG (@zill057) March 28, 2017 直到最近再次接触到 Python，查询了一些资料，才开始对其有了一些初步的认识。
我们暂停一下，看看计算机中比较诡异的地方，也就是代码(code)和数据(data)的统一。这是一个槛，如果不跨过这槛，很多概念就不清楚。我们常常说计算机程序分成 code 和 data 两部分。很多人会理解成，code 是会运行的，是动态的，data 是给 code 使用，是静态的，这是两种完全不同的东西。
回调函数（callback）是什么？ - 回答作者: 黄兢成 https://zhihu.com/question/19801131/answer/17156023
最开始我的认知也就如上面这个问题的答主描述的一般，但如果转变一下思维，将 code 与 data 统一视为视为信息，对于 PHP 中可以将函数作为参数传递的做法，也就可以理解了。
其实 code 只是对行为的一种描述，比如有个机器人可以开灯，关灯，扫地。如果跟机器人约定好，0 表示开灯，1 表示关灯，2 表示扫地。
我发出指令串，0 1 2，就可以控制机器人开灯，关灯，扫地。再约定用二进制表示，两位一个指令，就有一个数字串，000111，这个时候 000111 这串数字就描述了机器人的一系列动作，这个就是从一方面理解是 code，它可以控制机器人的行为。
但另一方面，它可以传递，可以记录，可以修改，也就是数据。只要大家都协商好，code 就可以编码成 data, 将 data 解释运行的时候，也变成了 code。
关于 code 与 data，上面的答主如是说：
有些语言不区分，它的 function(表示code)跟 int, double 的地位是一样的。这种语言称函数是第一类值。 有些语言是不能存储函数，不能动态创建函数，不能动态销毁函数。只能存储一个指向函数的指针，这种语言称函数是第二类值。 在 Python 中，将一切都视为对象，传递的即是函数的指针。这种做法即属于上述描述中的第二类。</description></item><item><title>Python 3 基础总结</title><link>https://hiwangzi.com/posts/2017/08/31/python3-newbie-note/</link><pubDate>Thu, 31 Aug 2017 18:20:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/08/31/python3-newbie-note/</guid><description>基础 Python 的语法比较简单，采用缩进方式 以 # 开头的语句是注释 当语句以冒号 : 结尾时，缩进的语句视为代码块 没有规定缩进是几个空格还是 Tab，但按照约定俗成的惯例，应该始终坚持使用4个空格的缩进 确保不混用 Tab 和空格 Python 程序是大小写敏感的 输入输出 print() input() 数据类型 整数 浮点数 对于很大或很小的浮点数，用科学计数法表示，把10用e替代，例: 1.23x10⁹就是1.23e9, 0.000012可以写成1.2e-5 字符串 可以用r''表示''内部的字符串默认不转义 布尔值 空值 一个特殊的值，用 None 表示。 常量 变量名全大写表示常量, 事实上仍然是变量 字符串与编码 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
#!/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉 Linux/OS X系统，这是一个 Python 可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 格式化 &amp;gt;&amp;gt;&amp;gt; 'Hello, %s' % 'world' 'Hello, world' &amp;gt;&amp;gt;&amp;gt; 'Hi, %s, you have $%d.</description></item><item><title>Debian/Linux 下无线网卡驱动的安装</title><link>https://hiwangzi.com/posts/2017/08/29/install-wifi-driver-for-bcm43228-in-linux/</link><pubDate>Tue, 29 Aug 2017 16:43:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/08/29/install-wifi-driver-for-bcm43228-in-linux/</guid><description>在 Debian 下为 BCM43228 无线网卡安装驱动</description></item><item><title>Linux 安装软件的几种方式</title><link>https://hiwangzi.com/posts/2017/08/22/how-to-install-software-for-linux/</link><pubDate>Tue, 22 Aug 2017 16:38:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/08/22/how-to-install-software-for-linux/</guid><description>源代码编译安装 源代码包的安装一般为下载软件源代码，然后编译安装。常见的 C 程序软件的安装步骤是 configure, make, make install 三部曲（./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install）。
一句话来解释整个过程：
根据源码包中 Makefile.in 文件的指示，configure 脚本检查当前的系统环境和配置选项，在当前目录中生成 Makefile 文件(还有其它本文无需关心的文件)，然后 make 程序就按照当前目录中的 Makefile 文件的指示将源代码编译为二进制文件，最后将这些二进制文件移动(即安装)到指定的地方(仍然按照 Makefile 文件的指示)。
借助软件包管理器安装 例如借助 yum、apt-get 等管理软件进行安装。
在 Ubuntu 系统上，软件包的格式是 deb，相比于「源代码编译安装」，deb 包这类的二进制包是依赖硬件和软件平台的。
顺便提一点，apt-get只是dpkg的一个前端而已，dpkg 是Debian软件包管理器的基础。而上层的工具，像是 APT，用于从远程获取软件包以及处理复杂的软件包关系。
二进制格式安装 编译好的文件，类似于 Windows 下的 exe，后缀一般为 bin，如 jdk 就有 bin 后缀（虽然 Linux 下没有后缀的概念，但为了好区分，一般文件名都加后缀）。安装就是先给它可执行权限，然后执行，例如：
chmod 777 xxx.bin ./xxx.bin 总结 源代码编译安装最为灵活自由 借助包管理器最为方便 二进制格式安装方式一般被一些闭源的驱动和预编译的安装包所采用 参考 源代码包 - deepin Wiki 深入理解软件包的配置、编译与安装 在 Linux 下安装软件的方法有哪些？各有什么优劣？</description></item><item><title>数据库表间多对多关系（附带额外字段）的实体类（POJO 或 POCO）表示</title><link>https://hiwangzi.com/posts/2017/05/26/po-in-many-to-many-relationship/</link><pubDate>Fri, 26 May 2017 22:25:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/05/26/po-in-many-to-many-relationship/</guid><description>介绍 在之前的 Entity Framework 快速上手介绍 之中，两个实体之间只是简单的一对一关系，而在实际的应用场景中，还会出现多对多关系，同时还有可能会出现多对多关系还附带有其他字段的情况。
下面以几个例子，对表间多对多关系的类表示加以更加详细地描述。虽然两个场景举例是使用的 C# 及 Entity Framework(Model First) 框架自动生成数据库、实体类。但这种设计方法，并不只是在使用 ORM 框架时需要，事实上，它是 POCO 及简单 Java 类（POJO）的设计原则之一。
场景实例 场景一 在考虑多对多关系还附带有字段的情况之前，让我们先看一下，多对多关系但不附带额外字段的情况下，实体类代码的表示。
此处使用 Entity Framework(Model First)，快速将 model diagram 转为数据库中的表及实体类。
假设的场景是学生选课，一名学生可以选多门课，一门课也可以被多个学生选择。E-R 图如下所示： 对应自动生成的数据库如下：
StudentSet CourseSet CourseRegistrationSet 其中 Course_Id 与 Students_Id（注：此处词尾(s)负数的原因参见上面 E-R 图中右边的 Properties 中 End1 Navigation Property 的设置）分别以另外两张数据表的 Id 主键作为外键。 同时 Course_Id 与 Students_Id 两者联合做 CourseRegistrationSet 表的主键。 对应自动生成实体类的代码如下：
Student.cs namespace Model { using System; using System.</description></item><item><title>《面向对象软件开发实践》笔记一</title><link>https://hiwangzi.com/posts/2017/03/25/oop-practice-csharp-note-1/</link><pubDate>Sat, 25 Mar 2017 13:53:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/03/25/oop-practice-csharp-note-1/</guid><description>开始学习这门课程，是源自一次无意间的发现。上一周时看到金老师的博客，觉得内容非常不错，这才开始了这门课程的学习。
面向对象软件开发实践之基本技能训练 - 网易云课堂
这门课能告诉他们：一个有用的软件到底是如何诞生的，我们在学校里学的操作系统、数据结构等专业课程到底在开发中是怎样应用的……
以下是本课程第一单元的笔记：
工具 .NET Reference Source 在此之前，有一次也想查看微软类库的源代码，可在 Visual Studio 中使用 F12 可以查看到的，仅仅只是定义，并没有对应的实现。那时还在想，难道是微软仅仅只是开放定义给开发人员。后来在网络上也没有搜索到相关内容（那时不知道如何描述，也没有找到合适的人请教），直到在这门课程中看到金老师的演示，才了解到微软的 .NET Framework 框架源码是完全开放的。
查看方式有两种：
直接在 .NET Reference Source 网站中在线浏览。
通过配置，在 Visual Studio 中调试 .NET Framework 源码。 具体配置方法参考：
微软开放了.NET 4.5.1的源代码 .NET Framework 4.5.1 已正式开源 配置Visual Studio 以调试.net framework的源代码 ildasm IL 反汇编程序是 IL 汇编程序 (Ilasm.exe) 的配套工具。Ildasm.exe 可利用包含中间语言 (IL) 代码的可移植可执行 (PE) 文件，并创建适合输入到 Ilasm.exe 的文本文件。此工具自动随 Visual Studio 一起安装。</description></item><item><title>Entity Framework 新手入门友好实例</title><link>https://hiwangzi.com/posts/2017/03/24/entity-framework-newbie-sample/</link><pubDate>Fri, 24 Mar 2017 22:35:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/03/24/entity-framework-newbie-sample/</guid><description>起因 因为实习的原因，程序之中用到了较多的数据库操作逻辑。如果每一处数据库操作都手写的话，工作量较大且后期不易于维护，所以希望能通过 ORM 框架来解决这两个问题。
在昨天之前，对于 ORM 这个词汇，我也仅仅只是在上个学期的 Java EE 课上看企业老师“神速”地使用 Hibernate 做了建立数据库、插入数据的演示。
这两天花了很多时间了解 Entity Framework，终于在今晚成功地实现了“查插删改”，中间经过了很多的波折。例如：查找的很多资料提供的代码都是不完整的，同时他们的讲解也不够“新人（菜鸟）友好型”。所以我决定把一个简单的实例的具体步骤写出来，帮助像我这样的菜鸟快速将 EF(Entity Framework) 应用起来。
如果博文有不当之处，欢迎指出，谢谢~
简介 首先是两个概念
对象关系映射（英语：Object Relational Mapping，简称 ORM，或 O/RM，或 O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。简单来说，就是可以把一条数据库记录转换为程序中的一个对象，或者反向转换，当然实际上 ORM 可以做更多的事情。）
Entity Framework (又称ADO.NET Entity Framework) 是微软以 ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。
使用 Entity Framework 在实际数据库相关代码开发中可以采取三种方式：
DB First：先开发数据库，然后借助 Visual Studio 将数据库中的表结构（或视图）转换为程序中实体模型类。 Code First：直接在程序中定义实体模型类，然后借助 Visual Studio 将其转换为数据库中的表。 Model First：借助 Visual Studio 中的可视化设计工具，设计好数据模型（可以理解为E-R图），然后转换为数据库中的表。 本实例采用第三种方式，即 Model First。</description></item><item><title>MIT 计算机科学及编程导论Python 笔记 1</title><link>https://hiwangzi.com/posts/2017/02/10/mit-introduction-to-computer-science-and-programming-in-python-note-1/</link><pubDate>Fri, 10 Feb 2017 21:05:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/02/10/mit-introduction-to-computer-science-and-programming-in-python-note-1/</guid><description>计算机科学及编程导论在 MIT 的课程编号是 6.00.1，是计算机科学及工程学院的经典课程。之前，课程一直使用 Scheme 作为教学语言，不过由于 Python 简单、易学等原因，近年来已经改用 Python 作为教学语言了。（更多介绍）
最初知道这个课程的时候大概是在 2014 年，对于做事拖沓的我，这门课程已经从低清随堂录制变成了 edX 平台的一门 高清的 MOOC，转眼间已经大三，希望自己能够完成自己曾经定下的计划。以下是在我在学习本课程时的一些笔记，在此与大家共享、共勉。
What does a computer do? Fundamentally a computer:
Performs some calculations Remembers results What calculations?
Built in primitives Creating our own methods of calculating Simple calculations are not enough, so good algorithm design also needed to accomplish a task.
Despite its speed and storage, a computer does have limitations</description></item><item><title>JetBrains 套装免费学生授权申请（IntelliJ, WebStorm...）</title><link>https://hiwangzi.com/posts/2017/02/10/how-to-apply-jetbrains-education-license/</link><pubDate>Fri, 10 Feb 2017 18:20:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/02/10/how-to-apply-jetbrains-education-license/</guid><description>希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠资格，不要作践自己作为学生的价值</description></item><item><title>我的十月</title><link>https://hiwangzi.com/posts/2016/10/31/october-2016/</link><pubDate>Mon, 31 Oct 2016 21:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2016/10/31/october-2016/</guid><description>10月是个忙碌的月份，总感觉每天都是匆匆忙忙，人生何其短……</description></item><item><title>关于《未成年人网络保护条例（草案征求意见稿）》的意见</title><link>https://hiwangzi.com/posts/2016/10/04/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%88%90%E5%B9%B4%E4%BA%BA%E7%BD%91%E7%BB%9C%E4%BF%9D%E6%8A%A4%E6%9D%A1%E4%BE%8B%E8%8D%89%E6%A1%88%E5%BE%81%E6%B1%82%E6%84%8F%E8%A7%81%E7%A8%BF%E7%9A%84%E6%84%8F%E8%A7%81/</link><pubDate>Tue, 04 Oct 2016 09:34:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2016/10/04/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%88%90%E5%B9%B4%E4%BA%BA%E7%BD%91%E7%BB%9C%E4%BF%9D%E6%8A%A4%E6%9D%A1%E4%BE%8B%E8%8D%89%E6%A1%88%E5%BE%81%E6%B1%82%E6%84%8F%E8%A7%81%E7%A8%BF%E7%9A%84%E6%84%8F%E8%A7%81/</guid><description>2016年9月30日，网信办正式发布《未成年人网络保护条例（草案征求意见稿）》。最早看到这条信息是在知乎（ 网瘾即将合法化，绿坝将强奸全部智能设备 ）。因为对其中的某些条例存在意见，故写了电邮反馈。
同时希望大家也可以将自己的意见通过电邮的形式表达，条例内容及反馈方式在此：
国家互联网信息办公室关于《未成年人网络保护条例（草案征求意见稿）》公开征求意见的通知-中共中央网络安全和信息化领导小组办公室
截止日期是2016年10月31日。
我的邮件内容如下：
您好，
关于这份草案，作为一名已经上网近10年的网民，我有如下意见：
网瘾并不是疾病，不需要治疗。草案中第二十条如此表述：
第二十条 教育、卫生计生等部门依据各自职责，组织开展预防未成年人沉迷网络的教育，对未成年人网络成瘾实施干预和矫治。
县级以上人民政府及其教育行政部门应当为中小学校配备专门教师或提高教师专业水平，增强对未成年人沉迷网络的早期识别和干预能力，并可以通过购买服务等方式提供预防和干预未成年人沉迷网络的教育或服务。
国务院卫生计生部门会同有关部门推动出台网络成瘾的本土化预测和诊断测评系统，制定诊断、治疗规范。
可是截至目前为止，国际社会上并无任何临床标准证明网瘾属于疾病。难道只有我国的青少年独有此病？所以治疗矫正，自然无稽之谈。此种举动，将会使社会上出现越来越多的杨永信之流，带给青少年的反而是更多的伤害。
我认为对于智能终端设备，不应当强制要求出厂时、销售前安装未成年人上网保护软件。草案中第十二条表述如下：
第十二条 智能终端产品制造商在产品出厂时、智能终端产品进口商在产品销售前应当在产品上安装未成年人上网保护软件，或者为安装未成年人上网保护软件提供便利并采用显著方式告知用户安装渠道和方法。
我认为仅保留最后一句表述即可，即
智能终端产品制造商应当为安装未成年人上网保护软件提供便利并采用显著方式告知用户安装渠道和方法。
因为使用智能终端的用户群体中，不止未成年人，还有成年人。对于成年人而言，是拥有能力辨别有害信息的，不需要国家统一划定范围。
我认为保护青少年不受到网络伤害、不沉迷网络的最重要解决途径应当是为青少年增加更多的公益场所、公益娱乐项目。
现在青少年更多地喜欢上网的原因一方面是因为网络世界很精彩，可很重要的另一方面也是他们闲暇时要么无处可去，要么就要花费大量金钱才可以参加绘画、音乐等娱乐活动。
相较于发达国家，我们国家城市中公益性质的活动场所太少。例如，国外的青少年暑假可以在公共游泳馆愉快玩耍，而我们的青少年却要花费百元乃至千元才可以得到同样的娱乐机会。
自然，免费或说低成本的互联网更吸引青少年的注意力。同时，这也是寒门子弟得到知识、提升综合素质成本最低的方式。如果政府再进一步限制青少年上网，那么我国的阶层固化将进一步严重。
以上是我的一点看法，感谢您的阅读，同时希望您能认真考虑一下以上三点意见。
谢谢！
2016年10月4日</description></item><item><title>C#指定并保留分隔符，字符串转数组</title><link>https://hiwangzi.com/posts/2016/09/04/split-string-into-array-by-specific-separator-in-csharp/</link><pubDate>Sun, 04 Sep 2016 14:41:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2016/09/04/split-string-into-array-by-specific-separator-in-csharp/</guid><description>mmmmmmynameismickeym -&amp;gt; [&amp;ldquo;m&amp;rdquo;, &amp;ldquo;m&amp;rdquo;, &amp;ldquo;m&amp;rdquo;, &amp;ldquo;m&amp;rdquo;, &amp;ldquo;m&amp;rdquo;, &amp;ldquo;m&amp;rdquo;, &amp;ldquo;yna&amp;rdquo;, &amp;ldquo;m&amp;rdquo;, &amp;ldquo;eis&amp;rdquo;, &amp;ldquo;m&amp;rdquo;, &amp;ldquo;ickey&amp;rdquo;, &amp;ldquo;m&amp;rdquo;]</description></item><item><title>值得探访的星球</title><link>https://hiwangzi.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hiwangzi.com/about/</guid><description>about</description></item></channel></rss>