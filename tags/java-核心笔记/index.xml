<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Java 核心笔记 on WANG!</title><link>https://hiwangzi.com/tags/java-%E6%A0%B8%E5%BF%83%E7%AC%94%E8%AE%B0/</link><description>Recent content in Java 核心笔记 on WANG!</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 07 Oct 2017 21:00:00 +0800</lastBuildDate><atom:link href="https://hiwangzi.com/tags/java-%E6%A0%B8%E5%BF%83%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>【Java 核心笔记】04. equals、hashcode、toString方法</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04/</link><pubDate>Sat, 07 Oct 2017 21:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04/</guid><description>equals equals 方法示例 // 代码来自《Java核心技术 卷I》P167 // 父类 public class Employee{ ... public boolean equals(Object otherObject){ // a quick test to see if the objects are identical if(this == otherObject) return true; // must return false if the explicit parameter is null if(otherObject == null) return false; // if the classes don&amp;#39;t match, they can&amp;#39;t be equal // 笔者注：子类通过super.equals方法调用到此处时，getClass()的结果是子类 if(getClass() != otherObject.getClass()) return false; // now we know otherObject is a non-null Employee Employee other = (Employee) otherObject; // test whether the fields hava identicial values // 笔者注：此处使用Objects.</description></item><item><title>【Java 核心笔记】03. 继承</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-03/</link><pubDate>Sat, 07 Oct 2017 17:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-03/</guid><description>继承 一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用哪个方法，此种调用方式称为静态绑定（static binding）。 子类不能覆盖父类中final修饰的方法（final类中所有方法自动地成为final方法，并且final类不能被继承）。 在父类转子类的类型转换前，可以先借助 instanceof 操作符，查看是否能够转换成功。 if(staff instanceof Manager){ boss=(Manager) staff; } 在超类（父类）设计合理的情况下，很少会使用到类型转换和instanceof运算符。 包含一个或多个抽象方法的类本身必须被声明为抽象的。 除了抽象方法，抽象类还可以包含具体数据和具体方法。 扩展抽象类有两种选择：一是部分实现抽象方法，此时子类仍需标记为抽象类;二是定义全部抽象方法。 类即使不包含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。 访问控制： 仅对本类可见——private 对本包可见——默认，不需要修饰符 对本包和所有子类可见——protected 对所有类可见——public 如果没有明确地指出父类，则Object就被认为是这个类的超类，其常见几个方法： equals 方法 hashcode 方法 toString 方法</description></item><item><title>【Java 核心笔记】02. 数据类型与运算符</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-02/</link><pubDate>Wed, 27 Sep 2017 10:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-02/</guid><description>数据类型 概述 注意：
在 Java 中，小数默认类型为 double，整数默认类型是 int 基本数据类型的默认值（开发中尽可能为每一个变量赋初值） 类型 默认值 byte (byte) 0 short (short) 0 int 0 long 0L float 0.0f double 0.0d char \u0000 boolean false 基本数据类型 整型 注意：Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。 不同进制的表示形式：
十六进制数值有一个前缀 0x 或 0X（如0xCAFE）。 八进制有一个前缀 0，例如，010 对应十进制中的 8 。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。 从Java 7开始，加上前缀 0b 或 0B 就可以写二进制数。例如， 0b1001 就是 9 。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用（1_000_000 或 0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。 浮点类型 可以使用十六进制表示浮点数值。例如，0.</description></item><item><title>【Java 核心笔记】01. Java介绍</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-01/</link><pubDate>Wed, 27 Sep 2017 10:27:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-01/</guid><description>「白皮书」关键术语 简单性 C++&amp;ndash; 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java 发展历程 SUN公司——Stanford University Network 主设计者：James Gosling 1996年初 - 发布 Java 1.0 Java 2, JDK 1.2 有了很大的改变 - 更加接近“一次编写，随处运行”的承诺 J2SE 5.0 得到了进一步改进 - 泛型、(以下几项受 C# 启发) foreach、自动装箱、注解 2014年 - 发布 Java 8 - 重大改变：提供了一种「函数式」编程方式，可以容易地表述并发执行的计算 Java 主要技术分支 Java SE Java 2 Platform, Standard Edition 前身：J2SE，2005年更名为Java SE Java EE（主要应用） Java 2 Platform, Enterprise Edition 前身：J2EE，2005年更名为Java EE Java ME（嵌入式） Java 2 Platform, Micro Edition 前身：J2ME，2005年更名为Java ME JVM, JRE, JDK JVM(Java Virtual Machine) &amp;lt; JRE(Java Runtime Environment) &amp;lt; JDK(Java Development Kit) “跨平台” 与 “解释执行” 早期的 Java是解释型的。现在 Java 虚拟机使用了即时编译器，因此采用 Java 编写的“热点”代码其运行速度与 C++ 相差无几，有些情况下甚至更快。 Java 开发环境 Path 的主要功能是设置 JDK 的可执行命令 classpath 主要是在执行的时候起作用，告诉JVM类的保存路径，一般（默认）设置为.</description></item></channel></rss>