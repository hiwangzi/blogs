<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Java on WANG!</title><link>https://hiwangzi.com/tags/java/</link><description>Recent content in Java on WANG!</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 08 Jul 2018 11:29:16 +0800</lastBuildDate><atom:link href="https://hiwangzi.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>java.util.List 的 remove(int) 与 remove(Object)</title><link>https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/</link><pubDate>Sun, 08 Jul 2018 11:29:16 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/</guid><description>最近看到 V2EX 上一个帖子《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。</description></item><item><title>译｜if(a - b &lt; 0) 与 if(a &lt; b) 的区别</title><link>https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/</link><pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/</guid><description>一个针对此问题 Stack Overflow 上的回答。</description></item><item><title>【Java 核心笔记】04.07. 反射</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-07/</link><pubDate>Sat, 14 Oct 2017 18:27:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-07/</guid><description>反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。 能够分析类能力的程序称为反射(reflective)，其可以： 在运行中分析类 在运行中查看对象 编写泛型数组代码 调用任意方法 java.lang.Class 类用于描述 JVM 中使用的类。 不要过多地使用反射，其不适合编写应用程序。反射是很脆弱的，编译器很难帮助人们发现程序中的错误，因此很有可能会导致运行时出现异常。 在运行中分析类 获取Class对象的三种方式（JVM为每个类型管理一个 Class 对象）： // 1. 通过实例对象获取 Random random = new Random(); Class cl = random.getClass(); System.out.println(cl.getName()); // 输出为 java.util.Random // 2. 通过静态方法 forName 获得类名对应的 Class 对象 Class cl = Class.forName(&amp;#34;java.util.Random&amp;#34;); // 3. 通过`类.class`获取（例如cl2，基本类型也可以） Class cl1 = Random.class; Class cl2 = int.class; Class cl3 = Double[].class; // 历史原因，getName 方法有时会返回一个奇怪的名字 Double[].</description></item><item><title>【Java 核心笔记】04.06. UML、类的一些要点补充</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-06/</link><pubDate>Sat, 14 Oct 2017 18:01:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-06/</guid><description>类间关系 依赖(dependence)（uses-a）：例如Order对象使用Account对象查看账户的信用状态 聚合(aggregation)（has-a）：例如Order对象包含了一些Item对象 继承(inheritance)（is-a） 对应的 UML 符号 有些方法学家不喜欢聚合这个概念，而更加喜欢「关联(association)」这个术语。但「has-a」更加形象，同时「关联」的 UML 符号不易区分。
以下是一个UML类图的示例：
类的一些要点补充 使用类的方法时，会隐式包含一个参数——方法名前的类对象（方法之中使用this调用），这被称为隐式(implicit)参数。其他参数称为显式(explicit)参数。 方法接收参数的形式是按值调用(call by value)。 可以通过「方法的签名(signature)」来完整地描述一个方法（方法名+参数类型，不包含返回类型），例如String类的indexOf方法 indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int) 默认域的初始化 如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。 但局部变量不可，必须明确地初始化方法中的局部变量。 类中代码执行顺序原则： 静态优先（静态域、静态代码块） 对于非静态，顺序为：域(初始化语句)、构造代码块（初始化块）、构造方法 总结：父类静态元素 -&amp;gt; 子类静态元素 -&amp;gt; 父类非静态元素 -&amp;gt; 子类非静态元素 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。 包 从编译器的角度来看，嵌套的包之间没有任何关系。 import java.time.* 对代码的大小无负面影响，但会降低人可读性。 只能使用星号(*)导入 一个 包，而不能使用import java.*或import java.*.*导入以java为前缀的所有包。 在包中定位类是编译器的工作，字节码中使用完整的包名引用其他类。 import static java.</description></item><item><title>【Java 核心笔记】04.05. 内部类</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-05/</link><pubDate>Sat, 14 Oct 2017 16:44:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-05/</guid><description>在类的内部还可以定义另一个类。如果在类 Outter 的内部再定义一个类 Inner ，此时类 Inner 就称为内部类，而类 Outter 则称为外部类。 内部类可声明为 public 或 private。当内部类声明为 public 或 private 时，对其访问的限制与成员变量和成员方法完全相同。
class Outer { // 定义外部类 private String info = &amp;#34;hello world&amp;#34;; // 定义外部类的私有属性 class Inner { // 定义内部类 public void print(){ // 定义内部类的方法 System.out.println(info); // 直接访问外部类的私有属性 } } public void fun() { // 定义外部类的方法 new Inner().print(); // 通过内部类的实例化对象调用方法 } } public class InnerClassDemo01 { public static void main(String args[]){ new Outer().</description></item><item><title>【Java 核心笔记】04.04. 代码块</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-04/</link><pubDate>Sat, 14 Oct 2017 15:52:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-04/</guid><description>代码块就是使用 {} 括起来的一段代码，根据位置不同，可分为四类：
普通代码块 构造代码块 静态代码块 同步代码块 普通代码块 直接定义在方法中的代码块称为普通代码块。
public class Demo { public static void main(String args[]) { { // 普通代码块 int x = 30; // 属于局部变量 System.out.println(&amp;#34;普通代码块 --&amp;gt; x = &amp;#34; + x); } int x = 100; // 与局部变量名称相同 System.out.println(&amp;#34;代码块之外 --&amp;gt; x = &amp;#34; + x); } } // 输出 // 普通代码块 --&amp;gt; x = 30 // 代码块之外 --&amp;gt; x = 100 构造代码块 直接在类中定义的代码块，称为构造块。</description></item><item><title>【Java 核心笔记】04.03. 匿名对象与字符串缓冲池</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-03/</link><pubDate>Sat, 07 Oct 2017 21:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-03/</guid><description>匿名对象 匿名对象：只在堆内存中开辟空间，不存在栈内存的引用。 由于匿名对象没有对应的栈内存引用所指向，所以使用一次之后，就等待被垃圾回收了。 例：一个单独的字符串就是一个 String 的匿名对象。System.out.println(&amp;quot;Hi&amp;quot;); 字符串缓冲池 public class Test { public static void main(String[] args) { String str = &amp;#34;hello&amp;#34; ; System.out.println(&amp;#34;hello&amp;#34;.equals(str)) ; // true System.out.println(&amp;#34;hello&amp;#34; == str); // true // String 池：Java为了优化字符串操作 提供了一个缓冲池； // str 指向字符串 “hello” ,第二句中字符串 “hello” ，因为字符串在常量池中已经存在，第二句中字符串 “hello” 就不再开辟空间。 // 所以不管是 equals 比较内容， == 比较内存地址都为 true // 但请不要使用这种方式比较字符串，不稳键 } } 下面的代码验证了我去「XXXX」面试时真的是乱吹🙈： /* * 当时我以为 JVM 的缓冲池可以实现“变量(a)连接字符串(&amp;#34;b&amp;#34;)可以与&amp;#34;ab&amp;#34;使用同一个堆内存” * 但是事实是并不可行 */ public class StringTest{ public static void main(String [] args){ String ab=&amp;#34;ab&amp;#34;; String a=&amp;#34;a&amp;#34;; // 「变量」与「变量连接字符串（匿名对象）」比较 System.</description></item><item><title>【Java 核心笔记】04.02. Override 的补充</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-02/</link><pubDate>Sat, 07 Oct 2017 17:31:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-02/</guid><description>方法的覆写 当子类定义了与父类方法名称相同、参数的类型及个数、返回值相同的方法时，就被称为方法的覆写。
被覆写的方法不能拥有比父类方法更严格的访问权限。private &amp;lt; default &amp;lt; protected &amp;lt; public
如果父类中的方法使用了 private 声明，而子类中同样的方法使用了 public 声明，这样属于覆写么？不属于。 class A { public void fun() { print(); } /*①*/ void print() { System.out.println(&amp;#34;父类中的 print() 方法&amp;#34;); } } class B extends A { /*②*/ void print() { // 覆写的是 print() 方法 System.out.println(&amp;#34;子类中的 print() 方法&amp;#34;); } } public class OverrideDemo { public static void main(String [] args) { B b = new B(); b.</description></item><item><title>【Java 核心笔记】04.01. 继承与多态、重写Object类方法</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-01/</link><pubDate>Sat, 07 Oct 2017 17:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-01/</guid><description>继承 Java 中只允许单继承。 继承的UML类图表示，关于UML 在使用继承的时候应该注意的是：子类不能直接访问父类中的私有成员，但是子类可以调用父类中的非私有方法。（详见下文访问控制） 使用super()方法调用父类构造函数 class A { A(String str) { System.out.println(str); } } class B extends A { B() { // 1. 因为A类缺少默认构造方法，所以必须显示调用父类A的构造函数， // 否则无法编译通过。 // 2. 另外，使用super，显示调用父类构造函数时，必须在方法体首行。 super(&amp;#34;default&amp;#34;); System.out.println(&amp;#34;Hello&amp;#34;); System.out.println(&amp;#34;World&amp;#34;); } B(String str) { // 此处调用本类的无参构造函数，已经传递调用了父类A的构造函数。 this(); } } public class SuperTest { public static void main(String [] args) { B b = new B(&amp;#34;Hi&amp;#34;); } // 输出结果如下： // default // Hello // World } 一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。 子类不能覆盖父类中 final 修饰的方法（final 类中所有方法自动地成为 final 方法，并且 final 类不能被继承）。 在父类转子类的类型转换前，可以先借助 instanceof 操作符，查看是否能够转换成功。 if (staff instanceof Manager) { boss = (Manager) staff; } 在超类（父类）设计合理的情况下，很少会使用到类型转换和 instanceof 运算符。 动态绑定、静态绑定 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。 如果是 private 方法、static 方法、final 方法或者构造器，编译器可以准确知道应该调用哪个方法，此种调用方式称为静态绑定（static binding）。 抽象类 包含一个或多个抽象方法的类本身必须被声明为抽象的（abstract）。 除了抽象方法，抽象类还可以包含具体数据和具体方法。 扩展抽象类有两种选择： 一是部分实现抽象方法，此时子类仍需标记为抽象类； 二是定义全部抽象方法。 类即使不包含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。 访问控制 仅对本类可见—— private</description></item><item><title>【Java 核心笔记】04. 面向对象</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-04/</link><pubDate>Wed, 27 Sep 2017 16:11:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-04/</guid><description>面向对象的三大特征 封装（Encapsulation）：对外部不可见 继承（Inheritance）：扩展类的功能 多态（Polymorphism）：一个对象变量可以指示多种实际类型的现象被称为多态 关于重载（Overload）、重写（Override）、多态 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，但是考虑到程序设计的一致性，重载时尽量保证方法的返回值类型相同。
重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。即外壳不变，核心重写。
区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改，但最好相同 可以有可协变的返回类型 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 参考 http://www.runoob.com/java/java-override-overload.html
关于重写（Override）的返回类型：
返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。 例如，假设Employee类有public Employee getBuddy() {}，在子类Manager中，可以按照 public Manager getBuddy() {} 方式覆盖这个方法。这样就可以说，这两个 getBuddy() 方法就有可协变的返回类型。 多态是同一个行为具有多个不同表现形式或形态的能力。
多态的三个必要条件： 继承 重写 父类引用指向子类对象 内存划分：对象创建之初 类属于引用传递类型，同样存在着“栈内存-堆内存”的引用关系</description></item><item><title>【Java 核心笔记】03.01 泛型数组、包装类</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-03-01/</link><pubDate>Wed, 27 Sep 2017 16:10:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-03-01/</guid><description>泛型数组列表 ArrayList 是一个采用类型参数（type parameter）的泛型类（generic class）。
ArrayList&amp;lt;Employee&amp;gt; staff = new ArrayList&amp;lt;Employee&amp;gt;(); ArrayList&amp;lt;Employee&amp;gt; staff = new ArrayList&amp;lt;&amp;gt;(); // JavaSE 7 之后可以简写 JavaSE 5.0 以前的版本没有提供泛型类，而是有一个 ArrayList 类，其中保存类型为 Object 的元素。
如果已经清楚或者能够估计数组可能的存储元素数量，就可以在填充数组之前调用 ensureCapacity 方法
staff.ensureCapacity(100); ArrayList&amp;lt;Employee&amp;gt; staff = new ArrayList&amp;lt;&amp;gt;(100); // 或者在构造时就传入初始容量（超过100个之后自动扩展） 这样做可以预先分配100个内存空间，而不用在每次 add 的时候再去分配。
一旦可以确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法，其可以将存储区域的大小调整为当前元素数量所需要的存储空间数目，垃圾回收器将回收多余的存储空间。但要注意，在整理了存储空间大小之后，添加新元素就需要再次花费时间移动存储块。
常用方法
boolean add(E obj) // 在数组列表尾端添加一个元素，永远返回 true void add(int index, E obj) void set(int index, E obj) // 替换已经存在的元素内容 E get(int index) E remove(int index) // 删除一个元素，并返回这个被删除的元素 int size() // 返回数组列表中当前元素数量 对象包装器与自动装箱 所有的基本类型都有一个与之对应的类。这些类称为包装器（wrapper）。 Integer, Long, Float, Double, Short, Byte, Character, Void, Boolean（前6个类派生于公共的超类Number） 对象包装器类是不可变的（一旦构造了包装器，就不允许更改包装在其中的值）（个人认为类似 String） 对象包装器类是 final。 自动装箱 // 下面这个调用 list.</description></item><item><title>【Java 核心笔记】03. 关于数组</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-03/</link><pubDate>Wed, 27 Sep 2017 16:01:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-03/</guid><description>数组的定义及使用 声明及开辟数组空间 声明数组
int score [] = null; // null表示引用数据类型的默认值 int [] score = null; // 与上一句等价 为数组开辟空间
补充：堆栈内存解释 数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是无法使用的，必须有指向的堆内存才可以使用； 要想开辟新的堆内存，则必须使用 new 关键字，之后只是将此内存的使用权交给了对应的栈内存空间，而且一个堆内存可以被多个栈内存空间指向。 数组的静态初始化 一维数组 int score[] = {1,2,3,4,5}; 二维数组 声明之后再赋值
int arr[][] = new int[4][3]; // 声明并实例化二维数组 arr[0][0] = 201604; arr[0][1] = 1; arr[1][1] = 11; arr[2][2] = 22; arr[3][1] = 31; 声明同时赋值
// 每行的数组元素个数不一样，分配空间不同 public class ArrayDemo { public static void main(String args[]){ int score[][] = { {67,61},{78,89,83},{99,100,98,66,95} }; for(int i=0; i&amp;lt;score.</description></item><item><title>【Java 核心笔记】02. 数据类型与运算符</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-02/</link><pubDate>Wed, 27 Sep 2017 10:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-02/</guid><description>数据类型 概述 注意：
在 Java 中，小数默认类型为 double，整数默认类型是 int 基本数据类型的默认值（开发中尽可能为每一个变量赋初值） 类型 默认值 byte (byte) 0 short (short) 0 int 0 long 0L float 0.0f double 0.0d char \u0000 boolean false 基本数据类型 整型 注意：Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。 不同进制的表示形式：
十六进制数值有一个前缀 0x 或 0X（如0xCAFE）。 八进制有一个前缀 0，例如，010 对应十进制中的 8 。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。 从Java 7开始，加上前缀 0b 或 0B 就可以写二进制数。例如， 0b1001 就是 9 。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用（1_000_000 或 0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。 浮点类型 可以使用十六进制表示浮点数值。例如，0.</description></item><item><title>【Java 核心笔记】01. Java介绍</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-01/</link><pubDate>Wed, 27 Sep 2017 10:27:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-01/</guid><description>「白皮书」关键术语 简单性 C++&amp;ndash; 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java 发展历程 SUN公司——Stanford University Network 主设计者：James Gosling 1996年初 - 发布 Java 1.0 Java 2, JDK 1.2 有了很大的改变 - 更加接近“一次编写，随处运行”的承诺 J2SE 5.0 得到了进一步改进 - 泛型、(以下几项受 C# 启发) foreach、自动装箱、注解 2014年 - 发布 Java 8 - 重大改变：提供了一种「函数式」编程方式，可以容易地表述并发执行的计算 Java 主要技术分支 Java SE Java 2 Platform, Standard Edition 前身：J2SE，2005年更名为Java SE Java EE（主要应用） Java 2 Platform, Enterprise Edition 前身：J2EE，2005年更名为Java EE Java ME（嵌入式） Java 2 Platform, Micro Edition 前身：J2ME，2005年更名为Java ME JVM, JRE, JDK JVM(Java Virtual Machine) &amp;lt; JRE(Java Runtime Environment) &amp;lt; JDK(Java Development Kit) “跨平台” 与 “解释执行” 早期的 Java是解释型的。现在 Java 虚拟机使用了即时编译器，因此采用 Java 编写的“热点”代码其运行速度与 C++ 相差无几，有些情况下甚至更快。 Java 开发环境 Path 的主要功能是设置 JDK 的可执行命令 classpath 主要是在执行的时候起作用，告诉JVM类的保存路径，一般（默认）设置为.</description></item></channel></rss>