<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Java on WANG!</title><link>https://hiwangzi.com/tags/java/</link><description>Recent content in Java on WANG!</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 08 Jul 2018 11:29:16 +0800</lastBuildDate><atom:link href="https://hiwangzi.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>java.util.List 的 remove(int) 与 remove(Object)</title><link>https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/</link><pubDate>Sun, 08 Jul 2018 11:29:16 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/</guid><description>最近看到 V2EX 上一个帖子《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。</description><content:encoded><![CDATA[<p>最近看到 V2EX 上一个帖子<a href="https://www.v2ex.com/t/465153">《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》</a>，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。</p>
<p>帖子正文中贴出的代码为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.ArrayList<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> java.util.List<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForeachTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> test <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            test<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>test<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 50<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> t <span style="color:#f92672">:</span> test<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>t<span style="color:#f92672">);</span>
                test<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>t<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>test<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>我预测的执行结果：</p>
<pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
0
1
2
3
……此处省略
47
48
49
[50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre><p>实际执行结果：</p>
<pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
0
1
1
1
……此处省略
1
1
1
[1, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre><p>我预测的理由是，每次最内层的循环只执行一次，并且移除第一个元素。但我忽略了一点，楼主贴出的代码之中，实际调用的是 <code>remove(int)</code> 方法，而不是 <code>remove(Object)</code> 方法。前者是根据下标移除对应元素，后者是移除对应的元素。第一次循环之中，移除了第0个元素（<code>test.get(0)</code>值为<code>0</code>），随后的循环，均移除第1个元素（<code>test.get(0)</code>值为<code>1</code>）。</p>
<p>因此，将 <code>for (int t : test)</code> 更改为 <code>for (Integer t : test)</code>，即可实现预测中的输出。</p>
]]></content:encoded></item><item><title>译｜if(a - b &lt; 0) 与 if(a &lt; b) 的区别</title><link>https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/</link><pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/</guid><description>一个针对此问题 Stack Overflow 上的回答。</description><content:encoded><![CDATA[<h2 id="目录">目录</h2>
<ul>
<li><a href="#%E9%97%AE%E9%A2%98">问题</a></li>
<li><a href="#%E8%B5%9E%E5%90%8C%E6%9C%80%E5%A4%9A%E7%9A%84%E5%9B%9E%E7%AD%94">赞同最多的回答</a></li>
</ul>
<blockquote>
<p>原文地址：<a href="https://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b">java - Difference between if (a - b &lt; 0) and if (a &lt; b) - Stack Overflow</a></p>
</blockquote>
<h2 id="问题">问题</h2>
<p>在阅读 Java 的 <code>ArrayList</code> 源代码时，我注意到在 <code>if</code> 语句中的一些比较语句。</p>
<p>在 Java 7 之中，<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/ArrayList.java#ArrayList.grow%28int%29"><code>grow(int)</code></a> 方法使用了如下代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> minCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
    newCapacity <span style="color:#f92672">=</span> minCapacity<span style="color:#f92672">;</span>
</code></pre></div><p>在 Java 6 中，没有 <code>grow</code> 方法。但方法 <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/util/ArrayList.java#ArrayList.ensureCapacity%28int%29"><code>ensureCapacity(int)</code></a> 却使用如下方式比较数值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">&lt;</span> minCapacity<span style="color:#f92672">)</span>
    newCapacity <span style="color:#f92672">=</span> minCapacity<span style="color:#f92672">;</span>
</code></pre></div><p>变更比较语句写法的原因是什么呢？为了性能还是说只是代码风格的变化？</p>
<p>我可以理解，与 0 作比较速度更快，但同时却需多执行一个减法，这不是额外的开销吗？同时对于编译后的字节码来说，做差比较需要涉及两个指令（<code>ISUB</code> 和 <code>IF_ICMPGE</code>），而直接比较只需要涉及 <code>IFGE</code> 一条指令。</p>
<h2 id="赞同最多的回答">赞同最多的回答</h2>
<p><code>a &lt; b</code> 与 <code>a - b &lt; 0</code> 可以表示不同的含义。</p>
<p>考虑如下场景：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>a <span style="color:#f92672">&lt;</span> b<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a &lt; b&#34;</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>a <span style="color:#f92672">-</span> b <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a - b &lt; 0&#34;</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>执行结果是：只会打印 <code>a - b &lt; 0</code>。因为 <code>a &lt; b</code> 显然是 false，但 <code>a - b</code> 产生了溢出，结果是 <code>-1</code>，因此结果为 true。</p>
<ul>
<li>译者注：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span> <span style="color:#75715e">//  2147483647
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span><span style="color:#f92672">;</span> <span style="color:#75715e">// -2147483648
</span></code></pre></div></li>
</ul>
<p>说回问题本身，我们假设数组长度本身已经非常接近于 <code>Integer.MAX_VALUE</code> 来看一看。<code>ArrayList</code> 之中的代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 译者注：可以查看问题中的第一个链接 grow(int) 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> oldCapacity <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>oldCapacity <span style="color:#f92672">&gt;&gt;</span> 1<span style="color:#f92672">);</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> minCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
    newCapacity <span style="color:#f92672">=</span> minCapacity<span style="color:#f92672">;</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> MAX_ARRAY_SIZE <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
    newCapacity <span style="color:#f92672">=</span> hugeCapacity<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
</code></pre></div><p><code>oldCapacity</code> 非常接近 <code>Integer.MAX_VALUE</code>，因此 <code>newCapacity</code>（即<code>oldCapacity + 0.5 * oldCapacity</code>）有可能产生溢出，假设溢出后值为 <code>Integer.MIN_VALUE</code> (负值)。然后，减去 <code>minCapacity</code> 又<strong>下溢</strong>变为正值（译者注：假设参数<code>minCapacity</code>为正值）。</p>
<p>因此第一个 <code>if</code> 块中的代码将不会被执行。但假设代码条件写作 <code>if (newCapacity &lt; minCapacity)</code>，结果将会是 <code>true</code>（因为 <code>newCapacity</code> 是负值），这将导致 <code>newCapacity</code> 被强行指定为 <code>minCapacity</code> 而没有考虑 <code>minCapacity</code>。</p>
<p>这个溢出问题将会被下一个 <code>if</code> 语句所处理。当 <code>newCapacity</code> 溢出后，此 <code>if</code> 的结果为 <code>true</code>：<code>MAX_ARRAY_SIZE</code> 为 <code>Integer.MAX_VALUE - 8</code>，所以 <code>Integer.MIN_VALUE - (Integer.MAX_VALUE - 8) &gt; 0</code> 为 <code>true</code>。因此 <code>newCapacity</code> 可以被正确的处理：<code>hugeCapacity</code> 方法将返回 <code>MAX_ARRAY_SIZE</code> 或 <code>Integer.MAX_VALUE</code>。</p>
<p>注意：这就是对应 Java 代码中注释 <code>// overflow-conscious</code> 的含义。</p>
]]></content:encoded></item><item><title>【Java 核心笔记】04.07. 反射</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-07/</link><pubDate>Sat, 14 Oct 2017 18:27:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-07/</guid><description>反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。 能够分析类能力的程序称为反射(reflective)，其可以： 在运行中分析类 在运行中查看对象 编写泛型数组代码 调用任意方法 java.lang.Class 类用于描述 JVM 中使用的类。 不要过多地使用反射，其不适合编写应用程序。反射是很脆弱的，编译器很难帮助人们发现程序中的错误，因此很有可能会导致运行时出现异常。 在运行中分析类 获取Class对象的三种方式（JVM为每个类型管理一个 Class 对象）： // 1. 通过实例对象获取 Random random = new Random(); Class cl = random.getClass(); System.out.println(cl.getName()); // 输出为 java.util.Random // 2. 通过静态方法 forName 获得类名对应的 Class 对象 Class cl = Class.forName(&amp;#34;java.util.Random&amp;#34;); // 3. 通过`类.class`获取（例如cl2，基本类型也可以） Class cl1 = Random.class; Class cl2 = int.class; Class cl3 = Double[].class; // 历史原因，getName 方法有时会返回一个奇怪的名字 Double[].</description><content:encoded><![CDATA[<ul>
<li>反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。</li>
<li>能够分析类能力的程序称为反射(reflective)，其可以：
<ul>
<li>在运行中分析类</li>
<li>在运行中查看对象</li>
<li>编写泛型数组代码</li>
<li>调用任意方法</li>
</ul>
</li>
<li><code>java.lang.Class</code> 类用于描述 JVM 中使用的类。</li>
<li>不要过多地使用反射，其不适合编写应用程序。反射是很脆弱的，编译器很难帮助人们发现程序中的错误，因此很有可能会导致运行时出现异常。</li>
</ul>
<h2 id="在运行中分析类">在运行中分析类</h2>
<ul>
<li>获取<code>Class</code>对象的三种方式（JVM为每个类型管理一个 Class 对象）：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 1. 通过实例对象获取
</span><span style="color:#75715e"></span>Random random <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Random<span style="color:#f92672">();</span>
Class cl <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">();</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>cl<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span> <span style="color:#75715e">// 输出为 java.util.Random
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 2. 通过静态方法 forName 获得类名对应的 Class 对象
</span><span style="color:#75715e"></span>Class cl <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;java.util.Random&#34;</span><span style="color:#f92672">);</span>

<span style="color:#75715e">// 3. 通过`类.class`获取（例如cl2，基本类型也可以）
</span><span style="color:#75715e"></span>Class cl1 <span style="color:#f92672">=</span> Random<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">;</span>
Class cl2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">;</span>
Class cl3 <span style="color:#f92672">=</span> Double<span style="color:#f92672">[].</span><span style="color:#a6e22e">class</span><span style="color:#f92672">;</span>
<span style="color:#75715e">// 历史原因，getName 方法有时会返回一个奇怪的名字
</span><span style="color:#75715e"></span>Double<span style="color:#f92672">[].</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 返回结果为 &#34;[Ljava.lang.Double;&#34;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">[].</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 返回结果为 &#34;[I&#34;
</span></code></pre></div></li>
<li><code>java.lang.reflect</code>中三个重要的类<code>Field</code>、<code>Method</code>、<code>Constructor</code>分别用于描述类的域、方法、构造器。</li>
<li><code>Class</code>类对象的
<ul>
<li><code>getFields</code>、<code>getMethods</code>、<code>getConstructors</code>方法将分别返回类提供的<code>public</code> 域、方法和构造器数组（包含超类的公有成员）</li>
<li><code>getDeclaredFields</code>、<code>getDeclaredMethods</code>、<code>getDeclaredConstructors</code>方法将分别返回类中声明的全部域、方法和构造器数组（但不包含超类的成员）。</li>
</ul>
</li>
<li>可以通过 newInstance 方法动态地创建一个类的实例
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">e<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">().</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 调用默认的无参构造器
</span></code></pre></div><ul>
<li>如果没有无参构造，则会抛出异常; 而对于基本类型来说，例如：<code>int.class.newInstance()</code> 会抛出 <code>InstantiationException</code> 异常</li>
<li>如果希望提供参数，则应使用 Constructor 类中的 newInstance 方法。</li>
</ul>
</li>
</ul>
<h2 id="在运行中分析对象">在运行中分析对象</h2>
<ul>
<li>在获取<code>Field</code>对象后，通过其<code>get</code>方法，可以得到某个对象该字段的值。</li>
<li>直接访问私有域，<code>get</code>方法会抛出<code>IllegalAccessException</code>异常。但如果一个Java程序没有受到安全管理器的控制，就可以通过<code>Field</code>对象的<code>setAccessible</code>方法覆盖访问控制（<code>Method</code>、<code>Constructor</code>同理）。</li>
<li>通过<code>get</code>方法得到的是<code>Object</code>。如果字段为基本类型，会将其打包为包装类型，并以<code>Object</code>形式返回。</li>
<li>通过<code>set</code>方法可以修改字段的值。</li>
<li>在编写程序时，如果知道想要查看的对象的域名称，查看指定的域是一个很容易的事，而利用反射机制可以查看在编译时还不清楚的对象域。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Employee tank <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Employee<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;man&#34;</span><span style="color:#f92672">,</span> 35000<span style="color:#f92672">,</span> 6<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 1989<span style="color:#f92672">);</span>
Class cl <span style="color:#f92672">=</span> tank<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">();</span>
Field f <span style="color:#f92672">=</span> cl<span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredField</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">);</span>
f<span style="color:#f92672">.</span><span style="color:#a6e22e">setAccessible</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>      <span style="color:#75715e">// 使得可以访问私有域
</span><span style="color:#75715e"></span>Object obj <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>tank<span style="color:#f92672">);</span>   <span style="color:#75715e">// 结果为&#34;man&#34;
</span><span style="color:#75715e"></span>f<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>tank<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;hero&#34;</span><span style="color:#f92672">);</span>        <span style="color:#75715e">// 修改域
</span><span style="color:#75715e"></span>Object obj <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>tank<span style="color:#f92672">);</span>   <span style="color:#75715e">// 结果为&#34;hero&#34;
</span></code></pre></div></li>
</ul>
<h2 id="编写泛型数组代码">编写泛型数组代码</h2>
<h3 id="例子目标实现一个通用的数组拷贝方法">例子目标：实现一个通用的数组拷贝方法</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">};</span>
    a <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[])</span> goodCopyOf<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 10<span style="color:#f92672">);</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>a<span style="color:#f92672">));</span>
    
    String<span style="color:#f92672">[]</span> b <span style="color:#f92672">=</span> <span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Andy&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Haley&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Tom&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Jerry&#34;</span><span style="color:#f92672">};</span>
    b <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>String<span style="color:#f92672">[])</span> goodCopyOf<span style="color:#f92672">(</span>b<span style="color:#f92672">,</span> 10<span style="color:#f92672">);</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>b<span style="color:#f92672">));</span>
    
    b <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>String<span style="color:#f92672">[])</span> badCopyOf<span style="color:#f92672">(</span>b<span style="color:#f92672">,</span> 10<span style="color:#f92672">);</span> <span style="color:#75715e">// 将抛出异常，原因如下
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><h3 id="限制下的-badcopyof">限制下的 <code>badCopyOf</code></h3>
<ul>
<li>将一个对象数组（<code>String[]</code>）临时地转换成 <code>Object[]</code> 数组， 然后再把它转换回来是可以的。</li>
<li>但<em><strong>最开始</strong></em>就是 <code>Object[]</code> 的数组却永远不能转换成对象数组。</li>
<li>不过可以通过进行单个元素的转换，循环处理得到目标类型数组。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.Arrays<span style="color:#f92672">;</span>

String<span style="color:#f92672">[]</span> strArray <span style="color:#f92672">=</span> <span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Tom&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Jerry&#34;</span><span style="color:#f92672">};</span>
Object<span style="color:#f92672">[]</span> objArray <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Object<span style="color:#f92672">[])</span> strArray<span style="color:#f92672">;</span>
Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>objArray<span style="color:#f92672">);</span>                  <span style="color:#75715e">// ✅ &#34;[Tom, Jerry]&#34;
</span><span style="color:#75715e"></span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">((</span>String<span style="color:#f92672">[])</span> objArray<span style="color:#f92672">);</span>       <span style="color:#75715e">// ✅ &#34;[Tom, Jerry]&#34;
</span><span style="color:#75715e"></span>
Object<span style="color:#f92672">[]</span> objArrayCopy <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">[</span>2<span style="color:#f92672">];</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>strArray<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> objArrayCopy<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> strArray<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>objArrayCopy<span style="color:#f92672">);</span>              <span style="color:#75715e">// ✅ &#34;[Tom, Jerry]&#34;
</span><span style="color:#75715e"></span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">((</span>String<span style="color:#f92672">[])</span> objArrayCopy<span style="color:#f92672">);</span>   <span style="color:#75715e">// ❌ java.lang.ClassCastException: class [Ljava.lang.Object; cannot be cast to class [Ljava.lang.String; ([Ljava.lang.Object; and [Ljava.lang.String; are in module java.base of loader &#39;bootstrap&#39;)
</span><span style="color:#75715e"></span>
String<span style="color:#f92672">[]</span> strArrayCopy <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>2<span style="color:#f92672">];</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> objArrayCopy<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    strArrayCopy<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>String<span style="color:#f92672">)</span> objArrayCopy<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>
Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>strArrayCopy<span style="color:#f92672">);</span>              <span style="color:#75715e">// ✅ &#34;[Tom, Jerry]&#34;
</span></code></pre></div></li>
<li>因此，下面方法的返回值的数组类型 <code>Object []</code> 不能直接被转换为目标类型数组：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Object<span style="color:#f92672">[]</span> <span style="color:#a6e22e">badCopyOf</span><span style="color:#f92672">(</span>Object<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> newLength<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Object<span style="color:#f92672">[]</span> newArray <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">[</span>newLength<span style="color:#f92672">];</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> newArray<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">,</span> newLength<span style="color:#f92672">));</span>
    <span style="color:#66d9ef">return</span> newArray<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h3 id="利用反射实现-goodcopyof">利用反射实现 <code>goodCopyOf</code></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 1. 参数 array 的类型为 Object，而不是 Object[] 的原因：整型数组类型int[]可以被转换成Object，但不能转换成对象数组。
</span><span style="color:#75715e">// 2. 返回值的类型为 Object，而不是 Object[] 的原因：最开始就定义为 `Object []` 的数组不能直接被转换为目标类型数组。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Object <span style="color:#a6e22e">goodCopyOf</span><span style="color:#f92672">(</span>Object array<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> newLength<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">requireNonNull</span><span style="color:#f92672">(</span>array<span style="color:#f92672">);</span>
    Class clazz <span style="color:#f92672">=</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">isArray</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        Class componentTypeClazz <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getComponentType</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> Array<span style="color:#f92672">.</span><span style="color:#a6e22e">getLength</span><span style="color:#f92672">(</span>array<span style="color:#f92672">);</span>
        Object newArray <span style="color:#f92672">=</span> Array<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span>componentTypeClazz<span style="color:#f92672">,</span> newLength<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> newArray<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>length<span style="color:#f92672">,</span> newLength<span style="color:#f92672">));</span>
        <span style="color:#66d9ef">return</span> newArray<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;First parameter should be an array.&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="调用任意方法">调用任意方法</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// `name` 为方法名，`parameterTypes`为该方法的参数类型（因为可能存在重载）
</span><span style="color:#75715e"></span>
Method <span style="color:#a6e22e">getMethod</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> Class<span style="color:#f92672">...</span> parameterTypes<span style="color:#f92672">)</span> <span style="color:#75715e">// 该方法属于`Class`类的实例对象
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// `obj` 为该方法所属的对象，如果为静态方法，传入`null`即可，后面的`args`为该方法所需的参数
</span><span style="color:#75715e">// 返回值如果为基本类型，会自动包装后返回
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">invoke</span><span style="color:#f92672">(</span>Object obj<span style="color:#f92672">,</span> Object<span style="color:#f92672">...</span> args<span style="color:#f92672">)</span> <span style="color:#75715e">// 该方法属于 `Method` 类的实例对象
</span></code></pre></div>]]></content:encoded></item><item><title>【Java 核心笔记】04.06. UML</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-06/</link><pubDate>Sat, 14 Oct 2017 18:01:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-06/</guid><description>类间关系 依赖(dependence)（uses-a）：例如Order对象使用Account对象查看账户的信用状态 聚合(aggregation)（has-a）：例如Order对象包含了一些Item对象 继承(inheritance)（is-a） 对应的 UML 符号 有些方法学家不喜欢聚合这个概念，而更加喜欢「关联(association)」这个术语。但「has-a」更加形象，同时「关联」的 UML 符号不易区分。
以下是一个UML类图的示例：</description><content:encoded><![CDATA[<h2 id="类间关系">类间关系</h2>
<ul>
<li>依赖(dependence)（uses-a）：例如Order对象使用Account对象查看账户的信用状态</li>
<li>聚合(aggregation)（has-a）：例如Order对象包含了一些Item对象</li>
<li>继承(inheritance)（is-a）</li>
</ul>
<h2 id="对应的-uml-符号">对应的 UML 符号</h2>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/10/14/core-java-04-06/resources/uml-notation-for-class-relationships.png" alt="UML符号"  />
</p>
<ul>
<li>
<p>有些方法学家不喜欢聚合这个概念，而更加喜欢「关联(association)」这个术语。但「has-a」更加形象，同时「关联」的 UML 符号不易区分。</p>
</li>
<li>
<p>以下是一个UML类图的示例：</p>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/10/14/core-java-04-06/resources/class-diagram-example.png" alt="UML类图示例"  />
</p>
</li>
</ul>
]]></content:encoded></item><item><title>【Java 核心笔记】04.05. 内部类、lambda</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-05/</link><pubDate>Sat, 14 Oct 2017 16:44:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-05/</guid><description>在类的内部还可以定义另一个类。如果在类 Outter 的内部再定义一个类 Inner ，此时类 Inner 就称为内部类，而类 Outter 则称为外部类。 内部类可声明为 public 或 private。当内部类声明为 public 或 private 时，对其访问的限制与成员变量和成员方法完全相同。
class Outer { // 定义外部类 private String info = &amp;#34;hello world&amp;#34;; // 定义外部类的私有属性 class Inner { // 定义内部类 public void print(){ // 定义内部类的方法 System.out.println(info); // 直接访问外部类的私有属性 } } public void fun() { // 定义外部类的方法 new Inner().print(); // 通过内部类的实例化对象调用方法 } } public class InnerClassDemo01 { public static void main(String args[]){ new Outer().</description><content:encoded><![CDATA[<p>在类的内部还可以定义另一个类。如果在类 <code>Outter</code> 的内部再定义一个类 <code>Inner</code> ，此时类 <code>Inner</code> 就称为内部类，而类 <code>Outter</code> 则称为外部类。
内部类可声明为 <code>public</code> 或 <code>private</code>。当内部类声明为 <code>public</code> 或 <code>private</code> 时，对其访问的限制与成员变量和成员方法完全相同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Outer</span> <span style="color:#f92672">{</span>                               <span style="color:#75715e">// 定义外部类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> String info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span><span style="color:#f92672">;</span>    <span style="color:#75715e">// 定义外部类的私有属性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Inner</span> <span style="color:#f92672">{</span>                           <span style="color:#75715e">// 定义内部类
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(){</span>                <span style="color:#75715e">// 定义内部类的方法
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>info<span style="color:#f92672">);</span>       <span style="color:#75715e">// 直接访问外部类的私有属性
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>                     <span style="color:#75715e">// 定义外部类的方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Inner<span style="color:#f92672">().</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>                <span style="color:#75715e">// 通过内部类的实例化对象调用方法
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClassDemo01</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[]){</span>
        <span style="color:#66d9ef">new</span> Outer<span style="color:#f92672">().</span><span style="color:#a6e22e">fun</span><span style="color:#f92672">();</span>                  <span style="color:#75715e">// 调用外部类的fun()方法
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// 以上程序中，Inner 类作为 Outter 的内部类存在，
</span><span style="color:#75715e">// 并且在外部类的 fun() 方法之中直接实例化内部类的对象并调用 print() 方法。
</span></code></pre></div><p>内部类存在的特点：</p>
<ul>
<li>缺点：破坏了程序的结构</li>
<li>优点：可以方便的访问外部类中的私有属性</li>
</ul>
<p>四类内部类：</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
<h2 id="在其他类中调用内部类成员内部类">在其他类中调用内部类（成员内部类）</h2>
<p>一个内部类除了可以通过外部类访问，也可以直接在其他类中调用（这里指的是在声明了外部类对象后，通过外部类对象调用内部类构造方法来实例化一个内部类对象），调用的格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">外部类<span style="color:#f92672">.</span><span style="color:#a6e22e">内部类</span> 内部类对象 <span style="color:#f92672">=</span> 外部类实例<span style="color:#f92672">.</span><span style="color:#a6e22e">new</span> <span style="color:#a6e22e">内部类</span><span style="color:#f92672">();</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Outer</span> <span style="color:#f92672">{</span>                               <span style="color:#75715e">// 定义外部类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> String info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span><span style="color:#f92672">;</span>    <span style="color:#75715e">// 定义外部类的私有属性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Inner</span><span style="color:#f92672">{</span>                            <span style="color:#75715e">// 定义内部类
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>               <span style="color:#75715e">// 定义内部类的方法
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>info<span style="color:#f92672">);</span>       <span style="color:#75715e">// 直接访问外部类的私有属性
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>                     <span style="color:#75715e">// 定义外部类的方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Inner<span style="color:#f92672">().</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>                <span style="color:#75715e">// 通过内部类的实例化对象调用方法
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClassDemo04</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        Outer out <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Outer<span style="color:#f92672">();</span>            <span style="color:#75715e">// 外部类实例化对象
</span><span style="color:#75715e"></span>        Outer<span style="color:#f92672">.</span><span style="color:#a6e22e">Inner</span> in <span style="color:#f92672">=</span> out<span style="color:#f92672">.</span><span style="color:#a6e22e">new</span> <span style="color:#a6e22e">Inner</span><span style="color:#f92672">();</span>   <span style="color:#75715e">// 实例化内部类对象
</span><span style="color:#75715e"></span>        in<span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>                         <span style="color:#75715e">// 调用内部类的方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Outer<span style="color:#f92672">().</span><span style="color:#a6e22e">new</span> Inner<span style="color:#f92672">().</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// 与上面的代码等效
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="使用-static-声明内部类静态内部类">使用 static 声明内部类（静态内部类）</h2>
<ul>
<li>如果一个内部类使用 <code>static</code> 关键字声明，则此内部类称为静态内部类（内部类访问控制是 public 的情况下相当于一个外部类，可以直接通过外部类.内部类进行访问）</li>
<li>静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类不持有指向外部类对象的引用（可以反编译代码查看）。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Outer</span><span style="color:#f92672">{</span>                                    <span style="color:#75715e">// 定义外部类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> String info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 定义外部类的私有属性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Inner</span> <span style="color:#f92672">{</span>                        <span style="color:#75715e">// 使用static定义内部类为外部类
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>                   <span style="color:#75715e">// 定义内部类的方法
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>info<span style="color:#f92672">);</span>           <span style="color:#75715e">// 直接访问外部类的私有属性
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClassDemo03</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">new</span> Outer<span style="color:#f92672">.</span><span style="color:#a6e22e">Inner</span><span style="color:#f92672">().</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="在方法中定义内部类局部内部类匿名内部类">在方法中定义内部类（局部内部类、匿名内部类）</h2>
<p>一个内部类可以在任意的位置定义，下面在方法中定义内部类。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Outer</span> <span style="color:#f92672">{</span>                                           <span style="color:#75715e">// 定义外部类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> String info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span><span style="color:#f92672">;</span>                <span style="color:#75715e">// 定义外部类的私有属性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> temp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                   <span style="color:#75715e">// 定义外部类的方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Inner</span> <span style="color:#f92672">{</span>                                   <span style="color:#75715e">// 在方法中定义的内部类
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>                       <span style="color:#75715e">// 定义内部类的方法
</span><span style="color:#75715e"></span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;类中属性：&#34;</span> <span style="color:#f92672">+</span> info<span style="color:#f92672">);</span>  <span style="color:#75715e">// 直接访问外部类的私有属性
</span><span style="color:#75715e"></span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;方法中参数：&#34;</span> <span style="color:#f92672">+</span> temp<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">new</span> Inner<span style="color:#f92672">().</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>                           <span style="color:#75715e">// 通过内部类的实例化对象调用方法
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClassDemo05</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[]){</span>
        <span style="color:#66d9ef">new</span> Outer<span style="color:#f92672">().</span><span style="color:#a6e22e">fun</span><span style="color:#f92672">(</span>30<span style="color:#f92672">)</span> <span style="color:#f92672">;</span>                           <span style="color:#75715e">// 调用外部类的方法
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>以上代码还可以写作「匿名内部类」的形式（Java 1.8 后还可以写作 lambda 表达式形式）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Outer</span> <span style="color:#f92672">{</span>                                                <span style="color:#75715e">// 定义外部类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> String info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span> <span style="color:#f92672">;</span>                   <span style="color:#75715e">// 定义外部类的私有属性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> temp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                        <span style="color:#75715e">// 定义外部类的方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>                            <span style="color:#75715e">// 定义内部类的方法
</span><span style="color:#75715e"></span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;类中的属性：&#34;</span> <span style="color:#f92672">+</span> info<span style="color:#f92672">);</span>    <span style="color:#75715e">// 直接访问外部类的私有属性
</span><span style="color:#75715e"></span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;方法中的参数：&#34;</span> <span style="color:#f92672">+</span> temp<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="lambda-表达式">lambda 表达式</h2>
<ul>
<li>lambada 表达式是一个可传递的代码块，重点是延迟执行（deferred execution）。</li>
<li>对于<em><strong>只有一个抽象方法</strong></em>的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。这种接口称为函数式接口(functional interface)。</li>
<li>java.util.function 包中定义了很多非常通用的函数式接口，可以用来保存 lambda 表达式。</li>
</ul>
<h3 id="方法引用">方法引用</h3>
<ul>
<li>使用 <code>::</code> 操作符分隔对象(或类)名与方法名，主要有以下3种情况：
<ul>
<li><code>object::instanceMethod</code>，例如：<code>System.out::println</code>等价于<code>x -&gt; System.out.println(x)</code></li>
<li><code>Class::staticMethod</code>，例如：<code>Math::pow</code>等价于<code>(x,y) -&gt; Math.pow(x, y)</code></li>
<li><code>CLass::instanceMethod</code>，例如：<code>String::compareToIgnoreCase</code>等价于<code>(x, y) -&gt; x.compareToIgnoreCase(y)</code></li>
</ul>
</li>
</ul>
<h3 id="构造器引用">构造器引用</h3>
<ul>
<li><code>Person::new</code> 指的是 <code>Person</code> 的哪一个构造器呢? 这取决于上下文。</li>
<li>可以用数组类型建立构造器引用。例如，<code>int[]::new</code> 是一个构造器引用，它有一个参数表示数组的长度。这等价于 lambda 表达式 <code>x -&gt; new int[x]</code>。
<ul>
<li>实例：Stream 接口有一个 <code>toArray</code> 方法可以返回 Object 数组: <code>Object[] people = stream.toArray()</code>，但将 <code>Person[]::new</code> 传入 <code>toArray</code> 方法，即使用 <code>Perso[] people = stream.toArray(Person[]::new)</code> 更佳，可以得到一个正确类型的数组。</li>
</ul>
</li>
</ul>
<h3 id="变量作用域">变量作用域</h3>
<ul>
<li>lambda 表达式中的3个部分：一个代码块、参数、自由变量的值（非参数且不在代码中定义的变量）</li>
<li>因为并发执行多个动作时的安全性，所以在lambda中自由变量的值不允许被改变。在外部可能发生改变同样不合法。</li>
<li>在lambda表达式中<code>this</code>表示的是创建这个lambda表达式方法的<code>this</code>参数。</li>
</ul>
<h3 id="处理-lambda-表达式">处理 lambda 表达式</h3>
<h4 id="常用函数式接口">常用函数式接口</h4>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
<th>描述</th>
<th>其他方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Runnable</code></td>
<td>无</td>
<td><code>void</code></td>
<td><code>run</code></td>
<td>作为无参数或无返回值的动作运行</td>
<td></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td>无</td>
<td><code>T</code></td>
<td><code>get</code></td>
<td>提供一个<code>T</code>类型的值</td>
<td></td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>void</code></td>
<td><code>accept</code></td>
<td>处理一个<code>T</code>类型的值</td>
<td><code>andThen</code></td>
</tr>
<tr>
<td><code>BiConsumer&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>void</code></td>
<td><code>accept</code></td>
<td>处理<code>T</code>和<code>U</code>类型的值</td>
<td><code>andThen</code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code></td>
<td><code>T</code></td>
<td><code>R</code></td>
<td><code>apply</code></td>
<td>有一个<code>T</code>类型参数的函数，返回<code>R</code>类型值</td>
<td><code>compose</code>, <code>andThen</code>, <code>identity</code></td>
</tr>
<tr>
<td><code>BiFunction&lt;T, U, R&gt;</code></td>
<td><code>T, U</code></td>
<td><code>R</code></td>
<td><code>apply</code></td>
<td>有<code>T</code>和<code>U</code>类型参数的函数，返回<code>R</code>类型值</td>
<td><code>andThen</code></td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>T</code></td>
<td><code>apply</code></td>
<td>类型<code>T</code>上的一元操作符</td>
<td><code>compose</code>, <code>andThen</code>, <code>identity</code></td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>T</code></td>
<td><code>apply</code></td>
<td>类型<code>T</code>上的二元操作符</td>
<td><code>andThen</code>, <code>maxBy</code>, <code>minBy</code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>boolean</code></td>
<td><code>test</code></td>
<td>判断是否为真</td>
<td><code>and</code>, <code>or</code>, <code>negate</code>, <code>isEqual</code></td>
</tr>
<tr>
<td><code>BiPredicate&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>boolean</code></td>
<td><code>test</code></td>
<td>判断是否为真</td>
<td><code>and</code>, <code>or</code>, <code>negate</code></td>
</tr>
</tbody>
</table>
<h4 id="基本类型的函数式接口">基本类型的函数式接口</h4>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IntSupplier</code></td>
<td>无</td>
<td><code>int</code></td>
<td><code>getAsInt</code></td>
</tr>
<tr>
<td><code>IntConsumer</code></td>
<td><code>int</code></td>
<td><code>void</code></td>
<td><code>accept</code></td>
</tr>
<tr>
<td><code>ObjIntConsumer&lt;T&gt;</code></td>
<td><code>T, int</code></td>
<td><code>void</code></td>
<td><code>accept</code></td>
</tr>
<tr>
<td><code>IntFunction&lt;T&gt;</code></td>
<td><code>int</code></td>
<td><code>T</code></td>
<td><code>apply</code></td>
</tr>
<tr>
<td><code>IntToDoubleFunction&lt;T&gt;</code></td>
<td><code>int</code></td>
<td><code>double</code></td>
<td><code>applyAsDouble</code></td>
</tr>
<tr>
<td><code>ToIntFunction&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>int</code></td>
<td><code>applyAsInt</code></td>
</tr>
<tr>
<td><code>ToIntBiFunction&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>int</code></td>
<td><code>applyAsInt</code></td>
</tr>
<tr>
<td><code>IntUnaryOperator</code></td>
<td><code>int</code></td>
<td><code>int</code></td>
<td><code>applyAsInt</code></td>
</tr>
<tr>
<td><code>IntBinaryOperator</code></td>
<td><code>int, int</code></td>
<td><code>int</code></td>
<td><code>applyAsInt</code></td>
</tr>
<tr>
<td><code>IntPredicate</code></td>
<td><code>int</code></td>
<td><code>boolean</code></td>
<td><code>test</code></td>
</tr>
</tbody>
</table>
<ul>
<li>以<code>int</code>为例，其他基本类型同理</li>
</ul>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html">Java内部类详解 - Matrix海子 - 博客园</a></li>
</ul>
]]></content:encoded></item><item><title>【Java 核心笔记】04.04. 代码块</title><link>https://hiwangzi.com/posts/2017/10/14/core-java-04-04/</link><pubDate>Sat, 14 Oct 2017 15:52:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/14/core-java-04-04/</guid><description>代码块就是使用 {} 括起来的一段代码，根据位置不同，可分为四类：
普通代码块 构造代码块 静态代码块 同步代码块 普通代码块 直接定义在方法中的代码块称为普通代码块。
public class Demo { public static void main(String args[]) { { // 普通代码块 int x = 30; // 属于局部变量 System.out.println(&amp;#34;普通代码块 --&amp;gt; x = &amp;#34; + x); } int x = 100; // 与局部变量名称相同 System.out.println(&amp;#34;代码块之外 --&amp;gt; x = &amp;#34; + x); } } // 输出 // 普通代码块 --&amp;gt; x = 30 // 代码块之外 --&amp;gt; x = 100 构造代码块 直接在类中定义的代码块，称为构造块。</description><content:encoded><![CDATA[<p>代码块就是使用 <code>{}</code> 括起来的一段代码，根据位置不同，可分为四类：</p>
<ul>
<li>普通代码块</li>
<li>构造代码块</li>
<li>静态代码块</li>
<li>同步代码块</li>
</ul>
<h2 id="普通代码块">普通代码块</h2>
<p>直接定义在方法中的代码块称为普通代码块。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        <span style="color:#f92672">{</span> <span style="color:#75715e">// 普通代码块
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 30<span style="color:#f92672">;</span> <span style="color:#75715e">// 属于局部变量
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;普通代码块 --&gt; x = &#34;</span> <span style="color:#f92672">+</span> x<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 100<span style="color:#f92672">;</span> <span style="color:#75715e">// 与局部变量名称相同
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;代码块之外 --&gt; x = &#34;</span> <span style="color:#f92672">+</span> x<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 输出
</span><span style="color:#75715e">// 普通代码块 --&gt; x = 30
</span><span style="color:#75715e">// 代码块之外 --&gt; x = 100
</span></code></pre></div><h2 id="构造代码块">构造代码块</h2>
<p>直接在类中定义的代码块，称为构造块。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">new</span> JustClass<span style="color:#f92672">();</span> <span style="color:#75715e">// 实例化对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> JustClass<span style="color:#f92672">();</span> <span style="color:#75715e">// 实例化对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> JustClass<span style="color:#f92672">();</span> <span style="color:#75715e">// 实例化对象
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JustClass</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">{</span> <span style="color:#75715e">// 直接在类中编写代码块，称为构造块
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1. 构造块。&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">JustClass</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 定义构造方法
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;2. 构造方法。&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 输出
</span><span style="color:#75715e">// 1. 构造块。
</span><span style="color:#75715e">// 2. 构造方法。
</span><span style="color:#75715e">// 1. 构造块。
</span><span style="color:#75715e">// 2. 构造方法。
</span><span style="color:#75715e">// 1. 构造块。
</span><span style="color:#75715e">// 2. 构造方法。
</span></code></pre></div><p>可以发现，</p>
<ol>
<li><strong>构造块优先于构造方法执行</strong>（<em>代码先后顺序无影响</em>），且每次实例化都执行。</li>
<li><strong>只要有</strong>实例化对象产生，<strong>就执行</strong>构造块中的语句。</li>
</ol>
<h2 id="静态代码块">静态代码块</h2>
<p>使用 <code>static</code> 关键字声明的代码块就称为静态代码块。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 在主方法所在的类中定义静态块
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;在主方法所在类中定义的代码块&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">new</span> JustClass<span style="color:#f92672">();</span> <span style="color:#75715e">// 实例化对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> JustClass<span style="color:#f92672">();</span> <span style="color:#75715e">// 实例化对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> JustClass<span style="color:#f92672">();</span> <span style="color:#75715e">// 实例化对象
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JustClass</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">{</span> <span style="color:#75715e">// 直接在类中编写代码块，称为构造块
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1. 构造块。&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 使用static，称为静态代码块
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;0. 静态代码块&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">JustClass</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 定义构造方法
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;2. 构造方法。&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 输出
</span><span style="color:#75715e">// 在主方法所在类中定义的代码块
</span><span style="color:#75715e">// 0. 静态代码块
</span><span style="color:#75715e">// 1. 构造块。
</span><span style="color:#75715e">// 2. 构造方法。
</span><span style="color:#75715e">// 1. 构造块。
</span><span style="color:#75715e">// 2. 构造方法。
</span><span style="color:#75715e">// 1. 构造块。
</span><span style="color:#75715e">// 2. 构造方法。
</span></code></pre></div><p>注意：</p>
<ul>
<li>静态块优先于主方法执行。</li>
<li>不管有多少个实例化对象产生，静态代码块<strong>只执行一次</strong>。</li>
<li>静态代码块的主要功能是为静态属性初始化。</li>
</ul>
<h2 id="同步代码块">同步代码块</h2>
<p><a href="https://segmentfault.com/a/1190000015979202">线程间的同步与通信(1)——同步代码块Synchronized - SegmentFault 思否</a></p>
]]></content:encoded></item><item><title>【Java 核心笔记】04.03. 匿名对象与字符串缓冲池</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-03/</link><pubDate>Sat, 07 Oct 2017 21:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-03/</guid><description>匿名对象 匿名对象：只在堆内存中开辟空间，不存在栈内存的引用。 由于匿名对象没有对应的栈内存引用所指向，所以使用一次之后，就等待被垃圾回收了。 例：一个单独的字符串就是一个 String 的匿名对象。System.out.println(&amp;quot;Hi&amp;quot;); 字符串缓冲池 public class Test { public static void main(String[] args) { String str = &amp;#34;hello&amp;#34; ; System.out.println(&amp;#34;hello&amp;#34;.equals(str)) ; // true System.out.println(&amp;#34;hello&amp;#34; == str); // true // String 池：Java为了优化字符串操作 提供了一个缓冲池； // str 指向字符串 &amp;#34;hello&amp;#34;, 第二句中字符串 &amp;#34;hello&amp;#34; ，为同一指向。 // 这是因为字符串在常量池中已经存在，第二句中字符串 &amp;#34;hello&amp;#34; 就不再开辟新空间。 // 所以不管是 equals 比较内容， == 比较内存地址都为 true。 // 但请不要使用这种方式比较字符串，不稳键。 } } 下面的代码验证了我去「XXXX」面试时真的是乱吹🙈： /* * 当时我以为 JVM 的缓冲池可以实现“变量(a)连接字符串(&amp;#34;b&amp;#34;)可以与&amp;#34;ab&amp;#34;使用同一个堆内存” * 但是事实是并不可行 */ public class StringTest{ public static void main(String [] args){ String ab=&amp;#34;ab&amp;#34;; String a=&amp;#34;a&amp;#34;; // 「变量」与「变量连接字符串（匿名对象）」比较 System.</description><content:encoded><![CDATA[<h2 id="匿名对象">匿名对象</h2>
<ul>
<li>匿名对象：只在堆内存中开辟空间，不存在栈内存的引用。</li>
<li>由于匿名对象没有对应的栈内存引用所指向，所以使用一次之后，就等待被垃圾回收了。</li>
<li>例：一个单独的字符串就是一个 String 的匿名对象。<code>System.out.println(&quot;Hi&quot;);</code></li>
</ul>
<h2 id="字符串缓冲池">字符串缓冲池</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">;</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>str<span style="color:#f92672">))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">==</span> str<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// String 池：Java为了优化字符串操作 提供了一个缓冲池；
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// str 指向字符串 &#34;hello&#34;, 第二句中字符串 &#34;hello&#34; ，为同一指向。
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这是因为字符串在常量池中已经存在，第二句中字符串 &#34;hello&#34; 就不再开辟新空间。
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 所以不管是 equals 比较内容， == 比较内存地址都为 true。
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 但请不要使用这种方式比较字符串，不稳键。
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>下面的代码验证了我去「XXXX」面试时真的是乱吹🙈：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/*
</span><span style="color:#75715e">* 当时我以为 JVM 的缓冲池可以实现“变量(a)连接字符串(&#34;b&#34;)可以与&#34;ab&#34;使用同一个堆内存”
</span><span style="color:#75715e">* 但是事实是并不可行
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringTest</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String <span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
        String ab<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ab&#34;</span><span style="color:#f92672">;</span>
        String a<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 「变量」与「变量连接字符串（匿名对象）」比较
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ab<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">((</span>a<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">)));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ab<span style="color:#f92672">==(</span>a<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">));</span> <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 「字符串（匿名对象）」与「字符串（匿名对象）连接字符串（匿名对象）」比较
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ab&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">((</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">)));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ab&#34;</span><span style="color:#f92672">==(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 「变量」与「字符串（匿名对象）连接字符串（匿名对象）」比较
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ab<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">((</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">)));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ab<span style="color:#f92672">==(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 「字符串（匿名对象）」与「变量」比较
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ab&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ab<span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ab&#34;</span><span style="color:#f92672">==</span>ab<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 「变量」与「字符串（匿名对象）」比较
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ab<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ab&#34;</span><span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ab<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ab&#34;</span><span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img loading="lazy" src="https://hiwangzi.com/posts/2017/10/07/core-java-04-03/resources/string-pool-test.png" alt="字符串池测试结果"  />
</p>
<ul>
<li>时光恍惚，当时还在用着 Deepin（上图）</li>
<li>现在看来（2018年4月13日），道理也并不复杂
<ul>
<li>像 <code>&quot;a&quot;+&quot;b&quot;</code> 这种代码，在编译的时候必然可以优化为 <code>&quot;ab&quot;</code></li>
<li>但 <code>a+&quot;b&quot;</code> 显式的开辟了两个堆内存空间（分别存储<code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>），并且还需要再次开辟堆空间存储连接后的值</li>
</ul>
</li>
<li>
<blockquote>
<p>What is String pool in Java</p>
<p>This prints true (even though we don&rsquo;t use equals method: correct way to compare strings)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;a&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;bc&#34;</span><span style="color:#f92672">;</span>
String t <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ab&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s <span style="color:#f92672">==</span> t<span style="color:#f92672">);</span>
</code></pre></div><p>When compiler optimizes your string literals, it sees that both <code>s</code> and <code>t</code> have same value and thus you need only one string object. It&rsquo;s safe because <code>String</code> is <strong>immutable</strong> in Java.</p>
<p>As result, both <code>s</code> and <code>t</code> point to the same object and some little memory saved.</p>
<p>Name &lsquo;string pool&rsquo; comes from the idea that all already defined string are stored in some &lsquo;pool&rsquo; and before creating new String object compiler checks if such string is already defined.</p>
<p>参考：https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java#3801355</p>
</blockquote>
</li>
</ul>
]]></content:encoded></item><item><title>【Java 核心笔记】04.02. Override 的补充</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-02/</link><pubDate>Sat, 07 Oct 2017 17:31:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-02/</guid><description>方法的覆写 当子类定义了与父类方法名称相同、参数的类型及个数、返回值相同的方法时，就被称为方法的覆写。
被覆写的方法不能拥有比父类方法更严格的访问权限。private &amp;lt; default &amp;lt; protected &amp;lt; public
如果父类中的方法使用了 private 声明，而子类中同样的方法使用了 public 声明，这样属于覆写么？不属于。 class A { public void fun() { print(); } /*①*/ void print() { System.out.println(&amp;#34;父类中的 print() 方法&amp;#34;); } } class B extends A { /*②*/ void print() { // 覆写的是 print() 方法 System.out.println(&amp;#34;子类中的 print() 方法&amp;#34;); } } public class OverrideDemo { public static void main(String [] args) { B b = new B(); b.</description><content:encoded><![CDATA[<h2 id="方法的覆写">方法的覆写</h2>
<ul>
<li>
<p>当子类定义了与父类方法名称相同、参数的类型及个数、<strong>返回值相同</strong>的方法时，就被称为方法的覆写。</p>
</li>
<li>
<p>被覆写的方法不能拥有比父类方法更严格的访问权限。<code>private &lt; default &lt; protected &lt; public</code></p>
<ul>
<li>如果父类中的方法使用了 <code>private</code> 声明，而子类中同样的方法使用了 <code>public</code> 声明，这样属于覆写么？不属于。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        print<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">/*①*/</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;父类中的 print() 方法&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">extends</span> A <span style="color:#f92672">{</span>
    <span style="color:#75715e">/*②*/</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 覆写的是 print() 方法
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;子类中的 print() 方法&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OverrideDemo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String <span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        B b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B<span style="color:#f92672">();</span>
        b<span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>
        b<span style="color:#f92672">.</span><span style="color:#a6e22e">fun</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// ① public;  ② public  属于重写，输出结果为“子类；子类”
</span><span style="color:#75715e">// ① public;  ② private 不属于重写，因为不符合重写原则，无法编译通过
</span><span style="color:#75715e">// ① private; ② public  不属于重写，因为如果父类中方法使用了 private 声明，
</span><span style="color:#75715e">//                        那这个方法对于子类而言是不可见的，即使它符合了覆写的访问限制要求，
</span><span style="color:#75715e">//                        但仍然不能够动态的实现重写的效果，输出结果为“子类；父类”。
</span><span style="color:#75715e">//                        此时子类中的方法相当于子类新定义了一个方法，与父类中的同名方法无关
</span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="关于-this方法-与-super方法">关于 <code>this.方法()</code> 与 <code>super.方法()</code></h4>
<ul>
<li>使用 <code>this.方法()</code> 会首先查找本类中是否存在有要调用的方法名称，如果存在则直接调用，如果不存在则查找父类中是否具有此方法，如果有就调用，如果没有，则会出现编译时错误。</li>
<li>使用 <code>super.方法()</code> 明确的表示调用的方法不是子类中的方法（不查找子类），而直接调用父类中的指定方法。</li>
</ul>
<h3 id="属性的覆盖了解">属性的覆盖（了解）</h3>
<ul>
<li>子类定义了和父类完全相同的属性名称时，就称为属性的覆盖。</li>
<li>与方法的覆盖表现不同，实际上不能实现「动态多态」</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VarOverrideDemo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String <span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        B b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B<span style="color:#f92672">();</span>
        b<span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>  <span style="color:#75715e">// Hello
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 100
</span><span style="color:#75715e"></span>        
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>c<span style="color:#f92672">.</span><span style="color:#a6e22e">str</span><span style="color:#f92672">);</span>      <span style="color:#75715e">// C
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>d<span style="color:#f92672">.</span><span style="color:#a6e22e">str</span><span style="color:#f92672">);</span>      <span style="color:#75715e">// D
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>c<span style="color:#f92672">.</span><span style="color:#a6e22e">getStr</span><span style="color:#f92672">());</span> <span style="color:#75715e">// D
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>d<span style="color:#f92672">.</span><span style="color:#a6e22e">getStr</span><span style="color:#f92672">());</span> <span style="color:#75715e">// D
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>
    String info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">extends</span> A <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> info <span style="color:#f92672">=</span> 100<span style="color:#f92672">;</span> <span style="color:#75715e">// 名称与父类中变量相同
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">{</span>
    String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;C&#34;</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getStr</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> str<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">extends</span> C <span style="color:#f92672">{</span>
    String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;D&#34;</span><span style="color:#f92672">;</span>

    <span style="color:#75715e">// 即使不加Override注解，也能实现动态绑定
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// @Override
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getStr</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> str<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>但其实在实际开发中，这种特性意义不是很大，因为绝大多数情况，属性都是被封装的，而被限制为 <code>private</code> 后，对于子类而言不可见，因此不会相互影响。</p>
<h2 id="关于-this-与-super-的小总结">关于 <code>this</code> 与 <code>super</code> 的小总结</h2>
<table>
<thead>
<tr>
<th>区别</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>调用本类构造、本类方法、本类属性</td>
<td>子类调用父类构造、父类方法、父类属性</td>
</tr>
<tr>
<td>形式</td>
<td>先查找本类中时候存在指定的调用结构，有则调用，无则调用父类定义</td>
<td>不查找子类，直接调用父类调用结构</td>
</tr>
<tr>
<td>特殊</td>
<td>表示本类的当前对象</td>
<td></td>
</tr>
</tbody>
</table>
<p>建议在开发中，加上 <code>this.</code> 或者 <code>super.</code>，这样便于区分。</p>
]]></content:encoded></item><item><title>【Java 核心笔记】04.01. 继承与多态、重写Object类方法</title><link>https://hiwangzi.com/posts/2017/10/07/core-java-04-01/</link><pubDate>Sat, 07 Oct 2017 17:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/10/07/core-java-04-01/</guid><description>继承 Java 中只允许单继承。 继承的UML类图表示，关于UML 在使用继承的时候应该注意的是：子类不能直接访问父类中的私有成员，但是子类可以调用父类中的非私有方法。（详见下文访问控制） 使用super()方法调用父类构造函数 class A { A(String str) { System.out.println(str); } } class B extends A { B() { // 1. 因为A类缺少默认构造方法，所以必须显示调用父类A的构造函数， // 否则无法编译通过。 // 2. 另外，使用super，显示调用父类构造函数时，必须在方法体首行。 super(&amp;#34;default&amp;#34;); System.out.println(&amp;#34;Hello&amp;#34;); System.out.println(&amp;#34;World&amp;#34;); } B(String str) { // 此处调用本类的无参构造函数，已经传递调用了父类A的构造函数。 this(); } } public class SuperTest { public static void main(String [] args) { B b = new B(&amp;#34;Hi&amp;#34;); } // 输出结果如下： // default // Hello // World } 一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。 子类不能覆盖父类中 final 修饰的方法（final 类中所有方法自动地成为 final 方法，并且 final 类不能被继承）。 在父类转子类的类型转换前，可以先借助 instanceof 操作符，查看是否能够转换成功。 if (staff instanceof Manager) { boss = (Manager) staff; } 在超类（父类）设计合理的情况下，很少会使用到类型转换和 instanceof 运算符。 动态绑定、静态绑定 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。 如果是 private 方法、static 方法、final 方法或者构造器，编译器可以准确知道应该调用哪个方法，此种调用方式称为静态绑定（static binding）。 抽象类 包含一个或多个抽象方法的类本身必须被声明为抽象的（abstract）。 除了抽象方法，抽象类还可以包含具体数据和具体方法。 扩展抽象类有两种选择： 一是部分实现抽象方法，此时子类仍需标记为抽象类； 二是定义全部抽象方法。 类即使不包含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。 访问控制 仅对本类可见—— private</description><content:encoded><![CDATA[<h2 id="继承">继承</h2>
<ul>
<li>Java 中只允许单继承。
<img loading="lazy" src="https://hiwangzi.com/posts/2017/10/07/core-java-04-01/resources/1.png" alt="多重继承 vs 多层继承"  />
</li>
<li>继承的UML类图表示，<a href="/posts/2017/10/14/core-java-04-06/">关于UML</a>
<img loading="lazy" src="https://hiwangzi.com/posts/2017/10/07/core-java-04-01/resources/2.png" alt="继承的UML类图表示"  />
</li>
<li>在使用继承的时候应该注意的是：子类不能直接访问父类中的私有成员，但是子类可以调用父类中的非私有方法。（详见下文<a href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">访问控制</a>）</li>
<li>使用<code>super()</code>方法调用父类构造函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>
    A<span style="color:#f92672">(</span>String str<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>str<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">extends</span> A <span style="color:#f92672">{</span>
    B<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 1. 因为A类缺少默认构造方法，所以必须显示调用父类A的构造函数，
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//    否则无法编译通过。
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 2. 另外，使用super，显示调用父类构造函数时，必须在方法体首行。
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;default&#34;</span><span style="color:#f92672">);</span> 

        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;World&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    B<span style="color:#f92672">(</span>String str<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 此处调用本类的无参构造函数，已经传递调用了父类A的构造函数。
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SuperTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String <span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        B b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hi&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 输出结果如下：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// default
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Hello
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// World
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div></li>
<li>一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。</li>
<li>子类不能覆盖父类中 <code>final</code> 修饰的方法（<code>final</code> 类中所有方法自动地成为 <code>final</code> 方法，并且 <code>final</code> 类不能被继承）。</li>
<li>在父类转子类的类型转换前，可以先借助 <code>instanceof</code> 操作符，查看是否能够转换成功。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>staff <span style="color:#66d9ef">instanceof</span> Manager<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    boss <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Manager<span style="color:#f92672">)</span> staff<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>在超类（父类）设计合理的情况下，很少会使用到类型转换和 <code>instanceof</code> 运算符。</li>
</ul>
<h2 id="动态绑定静态绑定">动态绑定、静态绑定</h2>
<ul>
<li>在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>（dynamic binding）。</li>
<li>如果是 <code>private</code> 方法、<code>static</code> 方法、<code>final</code> 方法或者构造器，编译器可以准确知道应该调用哪个方法，此种调用方式称为<strong>静态绑定</strong>（static binding）。</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<ul>
<li>包含一个或多个抽象方法的类本身必须被声明为抽象的（abstract）。
<ul>
<li>除了抽象方法，抽象类还可以包含具体数据和具体方法。</li>
<li>扩展抽象类有两种选择：
<ul>
<li>一是部分实现抽象方法，此时子类仍需标记为抽象类；</li>
<li>二是定义全部抽象方法。</li>
</ul>
</li>
<li>类即使不包含抽象方法，也可以将类声明为抽象类。</li>
<li>抽象类不能被实例化。</li>
</ul>
</li>
</ul>
<h2 id="访问控制">访问控制</h2>
<ul>
<li>
<p>仅对本类可见—— <code>private</code></p>
</li>
<li>
<p>对本包可见——默认，不需要修饰符（package private）</p>
</li>
<li>
<p>对本包和所有子类可见—— <code>protected</code></p>
</li>
<li>
<p>对所有类可见—— <code>public</code></p>
</li>
<li>
<p>如果没有明确地指出父类，则Object就被认为是这个类的超类，其常见几个方法：</p>
<ul>
<li><a href="#equals-%E6%96%B9%E6%B3%95">equals 方法</a></li>
<li><a href="#hashcode-%E6%96%B9%E6%B3%95">hashcode 方法</a></li>
<li><a href="#tostring-%E6%96%B9%E6%B3%95">toString 方法</a></li>
</ul>
</li>
<li>
<p>关于 <code>protected</code> 的补充：</p>
<ul>
<li>即使两个子类继承自同一个父类，也不能在一个子类中访问另一个子类的<code>protected</code>方法</li>
<li>
<blockquote>
<p>Protected access requires a little more elaboration. Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important). Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to. This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them.</p>
<p>——《Java in a Nutshell》</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="equals-方法"><code>equals</code> 方法</h3>
<ul>
<li>equals 方法示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 代码来自《Java核心技术 卷I 第十版》P167
</span><span style="color:#75715e">// 父类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span><span style="color:#f92672">{</span>
    <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object otherObject<span style="color:#f92672">){</span>
        <span style="color:#75715e">// a quick test to see if the objects are identical
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> otherObject<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// must return false if the explicit parameter is null
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>otherObject <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// if the classes don&#39;t match, they can&#39;t be equal
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 笔者注：子类Manager通过super.equals方法调用到此处时，
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//        getClass()的结果是子类，这是动态绑定的体现
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>getClass<span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> otherObject<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">())</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// now we know otherObject is a non-null Employee
</span><span style="color:#75715e"></span>        Employee other <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Employee<span style="color:#f92672">)</span> otherObject<span style="color:#f92672">;</span>

        <span style="color:#75715e">// test whether the fields hava identicial values
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 笔者注：此处使用Objects.equals方法是为了防备name或hireDay可能为null的情况
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">)</span>
            <span style="color:#f92672">&amp;&amp;</span> salary <span style="color:#f92672">==</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">salary</span>
            <span style="color:#f92672">&amp;&amp;</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>hireDate<span style="color:#f92672">,</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">hireDate</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 子类
</span><span style="color:#75715e">// 1. 先调用父类的equals，如果返回false，对象则不可能相等
</span><span style="color:#75715e">// 2. 如果父类中的域都相等，再比较子类中新增的实例域
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manager</span> <span style="color:#66d9ef">extends</span> Employee<span style="color:#f92672">{</span>
    <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object otherObject<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(!</span><span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>otherObject<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// super.equals checked that this and otherObject belong to the same class
</span><span style="color:#75715e"></span>        Manager other <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Manager<span style="color:#f92672">)</span> otherObject<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> bonus <span style="color:#f92672">==</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">bonus</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p>Java 语言规范要求 equals 方法具有以下特性：</p>
<ul>
<li>自反性：x.equals(x) 应当返回 true</li>
<li>对称性：x.equals(y) 与 y.equals(x) 返回应当相同</li>
<li>传递性：如果 x.equals(y) 返回 true，且 y.equals(z) 也返回 true，则 x.equals(z) 也应返回 true</li>
<li>一致性：如果 x 与 y 引用的对象没有发生变化，则 x.eqauls(y) 也不应变化</li>
<li>对于任意的非空引用 x，x.equals(null) 应当返回 false</li>
</ul>
</li>
<li>
<p>在上面的例子中，<code>if(getClass() != otherObject.getClass()) return false;</code> 如果发现类型不一致，就返回 false。</p>
<ul>
<li>但有一些程序员喜欢采用以下代码进行检测 <code>if(!(otherObject instanceof Employee)) return false;</code> 但这样存在问题，父类对象与子类对象比较时，不满足对称性，如下示例代码：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.Objects<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SuperTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Parent parent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Parent<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hi&#34;</span><span style="color:#f92672">);</span>
        Child child <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Child<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hi&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>parent<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>child<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>child<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>parent<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parent</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> String strParent<span style="color:#f92672">;</span>

    Parent<span style="color:#f92672">(</span>String str<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">strParent</span> <span style="color:#f92672">=</span> str<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object otherObject<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> otherObject<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>otherObject <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// ⬇️ 最终输出会得到 true、java.lang.ClassCastException，不满足对称性
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>otherObject <span style="color:#66d9ef">instanceof</span> Parent<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

        <span style="color:#75715e">// ⬇️ 使用该种判断，最终输出会得到 false、false
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// if (getClass() != otherObject.getClass()) return false;
</span><span style="color:#75715e"></span>        Parent other <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Parent<span style="color:#f92672">)</span> otherObject<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>strParent<span style="color:#f92672">,</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">strParent</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Child</span> <span style="color:#66d9ef">extends</span> Parent <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> String strChild<span style="color:#f92672">;</span>

    Child<span style="color:#f92672">(</span>String str<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>str<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">strChild</span> <span style="color:#f92672">=</span> str<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object otherObject<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span><span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>otherObject<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        Child other <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Child<span style="color:#f92672">)</span> otherObject<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>strChild<span style="color:#f92672">,</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">strChild</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>关于 <code>getClass</code> 与 <code>instanceof</code> 两种检测方法：</p>
<ul>
<li>如果子类能够拥有自己的相等概念，则对称性需求将强制采用 <code>getClass</code> 进行检测。</li>
<li>如果由超类决定相等的概念，那么就可以使用 <code>instanceof</code> 进行检测，这样可以在不同子类的对象之间进行相等的比较。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object otherObject<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span><span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>otherObject<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 为了实现「由超类决定相等的概念」，可以通过以下两种方式：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1. 直接移除子类的equals重载，因为既然都是父类决定，子类没有必要进行重载操作，比较推荐这种方式 👍
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2. 基于上面的例子，通过在子类equals中增加instance判断（下面这行代码）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>otherObject <span style="color:#66d9ef">instanceof</span> Child<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    Child other <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Child<span style="color:#f92672">)</span> otherObject<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>strChild<span style="color:#f92672">,</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">strChild</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>造成二者之间差异的根本原因：
<ul>
<li><code>子对象 instanceof 父类</code>结果为true，<code>父对象 instanceof 子类</code>结果为false</li>
<li><code>getClass</code>得到的结果是动态绑定后的子类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编写完美的 equals 方法的建议：</p>
<ol>
<li>显式参数命名为 otherObject，稍后需要将它转换为另一个叫做 other 的变量。</li>
<li>检测 this 与 otherObject 是否引用同一个对象：<code>return this == otherObject;</code></li>
<li>检测 otherObject 是否为 null，是则返回 false。</li>
<li>比较 this 与 otherObject 是否属于同一个类：
<ul>
<li>如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：<code>return getClass() != otherObject.getClass();</code></li>
<li>如果所有的子类都拥有统一的语义，就使用 instanceof 检测：<code>return (!(otherObject instanceof ClassName));</code></li>
</ul>
</li>
<li>将 otherObject 转换为相应的类类型变量：<code>ClassName other = (ClassName) otherObject</code></li>
<li>对所有需要比较的域进行比较。使用 == 比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配，则返回 true，否则返回false。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">return</span> field1 <span style="color:#f92672">==</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">field1</span>
    <span style="color:#f92672">&amp;&amp;</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>field2<span style="color:#f92672">,</span> other<span style="color:#f92672">.</span><span style="color:#a6e22e">field2</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">...;</span>
</code></pre></div><p>如果在子类中重新定义 <code>equals</code>，就要在其中包含调用 <code>super.equals(other)</code>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="hashcode-方法"><code>hashCode</code> 方法</h3>
<ul>
<li>散列码（hash code）是由对象导出的一个整形值（可以是负数）。是<em><strong>没有规律</strong></em>的，如果x与y是两个不同的对象，则x.hashCode()与y.hashCode()基本上不会相同。</li>
<li>hashCode 方法定义在 Object 类中，因此每个对象都有一个默认的散列码方法，其返回结果是对象的存储地址。</li>
<li>一个例子：
<ul>
<li>代码：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String string1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hiwangzi&#34;</span><span style="color:#f92672">;</span>
StringBuilder stringBuilder1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">(</span>string1<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>string1<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> stringBuilder1<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>

String string2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hiwangzi&#34;</span><span style="color:#f92672">);</span>
StringBuilder stringBuilder2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">(</span>string2<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>string2<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> stringBuilder2<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
</code></pre></div></li>
<li>输出结果：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">-1232882509 1975012498
-1232882509 1808253012
</code></pre></div></li>
<li>可以看到，String 对象的散列码是相同的，这是因为字符串的散列码是由内容导出的；而 StringBuffer 对象散列码不同，这是因为 StringBuffer 类没有定义 <code>hashCode()</code> 方法，它的散列码是由默认的 Object 类的默认 <code>hashCode()</code> 方法导出的对象存储地址。</li>
</ul>
</li>
<li>如果重新定义 <code>equals</code> 方法，就<em><strong>必须</strong></em>重新定义 <code>hashCode</code> 方法，以便于可以将对象插入到散列表中。</li>
<li>可以调用 <code>Objects.hash</code> 方法并提供多个参数得到散列码（这种做法比较好）：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(){</span>
    <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> salary<span style="color:#f92672">,</span> hireDay<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li><code>equals</code> 与 <code>hashCode</code> 行为<em><strong>必须</strong></em>一致，即 x.equals(y) 与 x.hashCode() == y.hashCode() 结果一致。</li>
</ul>
<h3 id="tostring-方法"><code>toString</code> 方法</h3>
<ul>
<li>绝大多数的 toString 方法都遵循这样的格式：类的名字，随后一对方括号括起来的域值。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">(){</span>
    <span style="color:#66d9ef">return</span> getClass<span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span>
        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;[name=&#34;</span> <span style="color:#f92672">+</span> name
        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,salary=&#34;</span> <span style="color:#f92672">+</span> salary
        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,hireDay=&#34;</span> <span style="color:#f92672">+</span> hireDay
        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;]&#34;</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
]]></content:encoded></item><item><title>【Java 核心笔记】04. 面向对象</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-04/</link><pubDate>Wed, 27 Sep 2017 16:11:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-04/</guid><description>面向对象的三大特征 封装（Encapsulation）：对外部不可见 继承（Inheritance）：扩展类的功能 多态（Polymorphism）：一个对象变量可以指示多种实际类型的现象被称为多态 关于重载（Overload）、重写（Override）、多态 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，但是考虑到程序设计的一致性，重载时尽量保证方法的返回值类型相同。
重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。即外壳不变，核心重写。
区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改，但最好相同 可以有可协变的返回类型 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 参考 http://www.runoob.com/java/java-override-overload.html
关于重写（Override）的返回类型：
返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。 例如，假设Employee类有public Employee getBuddy() {}，在子类Manager中，可以按照 public Manager getBuddy() {} 方式覆盖这个方法。这样就可以说，这两个 getBuddy() 方法就有可协变的返回类型。 多态是同一个行为具有多个不同表现形式或形态的能力。
多态的三个必要条件： 继承 重写 父类引用指向子类对象 内存划分：对象创建之初 类属于引用传递类型，同样存在着“栈内存-堆内存”的引用关系</description><content:encoded><![CDATA[<h2 id="面向对象的三大特征">面向对象的三大特征</h2>
<ul>
<li>封装（Encapsulation）：对外部不可见</li>
<li>继承（Inheritance）：扩展类的功能</li>
<li>多态（Polymorphism）：一个对象变量可以指示多种实际类型的现象被称为多态</li>
</ul>
<h2 id="关于重载overload重写override多态">关于重载（Overload）、重写（Override）、多态</h2>
<ul>
<li>
<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，但是考虑到程序设计的一致性，重载时尽量保证方法的返回值类型相同。</p>
</li>
<li>
<p>重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。即外壳不变，核心重写。</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改，但最好相同</td>
<td>可以有可协变的返回类型</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考 <a href="http://www.runoob.com/java/java-override-overload.html">http://www.runoob.com/java/java-override-overload.html</a></p>
</blockquote>
</li>
<li>
<p>关于重写（Override）的返回类型：</p>
<ul>
<li>返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。</li>
<li>例如，假设<code>Employee</code>类有<code>public Employee getBuddy() {}</code>，在子类<code>Manager</code>中，可以按照 <code>public Manager getBuddy() {}</code> 方式覆盖这个方法。这样就可以说，这两个 <code>getBuddy()</code> 方法就有<strong>可协变</strong>的返回类型。</li>
</ul>
</li>
<li>
<p><strong>多态</strong>是同一个行为具有多个不同表现形式或形态的能力。</p>
<ul>
<li>多态的三个必要条件：
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存划分对象创建之初">内存划分：对象创建之初</h2>
<ul>
<li>
<p>类属于引用传递类型，同样存在着“栈内存-堆内存”的引用关系</p>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-04/resources/memory-allocation.jpg" alt="内存划分"  />
</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Person per <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Person<span style="color:#f92672">();</span>
</code></pre></div><ul>
<li>声明对象：<code>Person per</code>，栈内存中保存对象名，只开辟了栈内存的对象是无法使用的，必须有堆内存的引用才可以使用。</li>
<li>实例化对象：<code>new Person()</code>，在堆中开辟空间，所有的内容都是默认值。</li>
</ul>
</li>
<li>
<p>进一步拆分上面一行代码，可以用如下形式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Person per <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>     <span style="color:#75715e">// 声明对象
</span><span style="color:#75715e"></span>per <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Person<span style="color:#f92672">();</span>    <span style="color:#75715e">// 实例化对象
</span></code></pre></div></li>
</ul>
<h2 id="引用传递">引用传递</h2>
<ul>
<li>引用保存在栈内存</li>
<li>属性保存在堆内存</li>
<li>方法保存在全局代码区（此区域中的内容是所有对象共享的）</li>
</ul>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-04/resources/pointer.jpg" alt="内存划分"  />
</p>
<p>注意：对象间的引用传递，实际上传递的就是<strong>堆内存空间的使用权</strong>。</p>
<h2 id="垃圾产生与回收gc">垃圾产生与回收（GC）</h2>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-04/resources/gc.jpg" alt="垃圾回收"  />
</p>
<h2 id="类的一些要点">类的一些要点</h2>
<ul>
<li>使用类的方法时，会<em><strong>隐式包含一个参数</strong></em>——方法名前的类对象（方法之中使用<code>this</code>调用），这被称为隐式(implicit)参数。其他参数称为显式(explicit)参数。</li>
<li><a href="/posts/2017/09/27/core-java-03/#3-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E5%80%BC">方法接收参数的形式是按值调用(call by value)</a>。</li>
<li>可以通过「方法的签名(signature)」来完整地描述一个方法（方法名+参数类型，不包含返回类型），例如<code>String</code>类的<code>indexOf</code>方法
<ul>
<li><code>indexOf(int)</code></li>
<li><code>indexOf(int, int)</code></li>
<li><code>indexOf(String)</code></li>
<li><code>indexOf(String, int)</code></li>
</ul>
</li>
<li>默认域的初始化
<ul>
<li>如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。</li>
<li>但局部变量不可，必须明确地初始化方法中的局部变量。</li>
</ul>
</li>
<li>类中代码执行顺序原则：
<ul>
<li>静态优先（静态域、静态代码块）</li>
<li>对于非静态，顺序为：域(初始化语句)、构造代码块（初始化块）、构造方法</li>
<li>总结：<strong>父类静态元素 -&gt; 子类静态元素 -&gt; 父类非静态元素 -&gt; 子类非静态元素</strong></li>
</ul>
</li>
<li>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。</li>
</ul>
<h3 id="包">包</h3>
<ul>
<li>从编译器的角度来看，嵌套的包之间没有任何关系。</li>
<li><code>import java.time.*</code> 对代码的大小无负面影响，但会降低人可读性。</li>
<li>只能使用星号(<code>*</code>)导入 <strong>一个</strong> 包，而不能使用<code>import java.*</code>或<code>import java.*.*</code>导入以<code>java</code>为前缀的所有包。</li>
<li>在包中定位类是编译器的工作，字节码中使用完整的包名引用其他类。</li>
<li><code>import static java.lang.System.*</code>这样的写法可以导入<code>System</code>类的静态方法和静态域，可以直接使用而无需加类名前缀。</li>
</ul>
]]></content:encoded></item><item><title>【Java 核心笔记】03.01 泛型数组、包装类</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-03-01/</link><pubDate>Wed, 27 Sep 2017 16:10:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-03-01/</guid><description>泛型数组列表 ArrayList 是一个采用类型参数（type parameter）的泛型类（generic class）。
ArrayList&amp;lt;Employee&amp;gt; staff = new ArrayList&amp;lt;Employee&amp;gt;(); ArrayList&amp;lt;Employee&amp;gt; staff = new ArrayList&amp;lt;&amp;gt;(); // JavaSE 7 之后可以简写 JavaSE 5.0 以前的版本没有提供泛型类，而是有一个 ArrayList 类，其中保存类型为 Object 的元素。
如果已经清楚或者能够估计数组可能的存储元素数量，就可以在填充数组之前调用 ensureCapacity 方法
staff.ensureCapacity(100); ArrayList&amp;lt;Employee&amp;gt; staff = new ArrayList&amp;lt;&amp;gt;(100); // 或者在构造时就传入初始容量（超过100个之后自动扩展） 这样做可以预先分配100个内存空间，而不用在每次 add 的时候再去分配。
一旦可以确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法，其可以将存储区域的大小调整为当前元素数量所需要的存储空间数目，垃圾回收器将回收多余的存储空间。但要注意，在整理了存储空间大小之后，添加新元素就需要再次花费时间移动存储块。
常用方法
boolean add(E obj) // 在数组列表尾端添加一个元素，永远返回 true void add(int index, E obj) void set(int index, E obj) // 替换已经存在的元素内容 E get(int index) E remove(int index) // 删除一个元素，并返回这个被删除的元素 int size() // 返回数组列表中当前元素数量 对象包装器与自动装箱 所有的基本类型都有一个与之对应的类。这些类称为包装器（wrapper）。 Integer, Long, Float, Double, Short, Byte, Character, Void, Boolean（前6个类派生于公共的超类Number） 对象包装器类是不可变的（一旦构造了包装器，就不允许更改包装在其中的值）（个人认为类似 String） 对象包装器类是 final。 自动装箱 // 下面这个调用 list.</description><content:encoded><![CDATA[<h2 id="泛型数组列表">泛型数组列表</h2>
<ul>
<li>
<p>ArrayList 是一个采用类型参数（type parameter）的泛型类（generic class）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ArrayList<span style="color:#f92672">&lt;</span>Employee<span style="color:#f92672">&gt;</span> staff <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Employee<span style="color:#f92672">&gt;();</span>    
ArrayList<span style="color:#f92672">&lt;</span>Employee<span style="color:#f92672">&gt;</span> staff <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span> <span style="color:#75715e">// JavaSE 7 之后可以简写
</span></code></pre></div></li>
<li>
<p>JavaSE 5.0 以前的版本没有提供泛型类，而是有一个 ArrayList 类，其中保存类型为 Object 的元素。</p>
</li>
<li>
<p>如果已经清楚或者能够估计数组可能的存储元素数量，就可以在填充数组之前调用 <code>ensureCapacity</code> 方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">staff<span style="color:#f92672">.</span><span style="color:#a6e22e">ensureCapacity</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
ArrayList<span style="color:#f92672">&lt;</span>Employee<span style="color:#f92672">&gt;</span> staff <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;(</span>100<span style="color:#f92672">);</span> <span style="color:#75715e">// 或者在构造时就传入初始容量（超过100个之后自动扩展）
</span></code></pre></div><p>这样做可以预先分配100个内存空间，而不用在每次 add 的时候再去分配。</p>
</li>
<li>
<p>一旦可以确认数组列表的大小不再发生变化，就可以调用 <code>trimToSize</code> 方法，其可以将存储区域的大小调整为当前元素数量所需要的存储空间数目，垃圾回收器将回收多余的存储空间。但要注意，在整理了存储空间大小之后，添加新元素就需要再次花费时间移动存储块。</p>
</li>
<li>
<p>常用方法</p>
<ul>
<li><code>boolean add(E obj)</code> // 在数组列表尾端添加一个元素，永远返回 true</li>
<li><code>void add(int index, E obj)</code></li>
<li><code>void set(int index, E obj)</code> // 替换已经存在的元素内容</li>
<li><code>E get(int index)</code></li>
<li><code>E remove(int index)</code> // 删除一个元素，并返回这个被删除的元素</li>
<li><code>int size()</code> // 返回数组列表中当前元素数量</li>
</ul>
</li>
</ul>
<h2 id="对象包装器与自动装箱">对象包装器与自动装箱</h2>
<ul>
<li>所有的基本类型都有一个与之对应的类。这些类称为包装器（wrapper）。
<ul>
<li><code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Short</code>, <code>Byte</code>, <code>Character</code>, <code>Void</code>, <code>Boolean</code>（前6个类派生于公共的超类Number）</li>
<li>对象包装器类是不可变的（一旦构造了包装器，就不允许更改包装在其中的值）（个人认为类似 <code>String</code>）</li>
<li>对象包装器类是 <code>final</code>。</li>
</ul>
</li>
</ul>
<h3 id="自动装箱">自动装箱</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 下面这个调用
</span><span style="color:#75715e"></span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>3<span style="color:#f92672">);</span>
<span style="color:#75715e">// 将自动地变换为
</span><span style="color:#75715e"></span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>3<span style="color:#f92672">));</span>
</code></pre></div><h3 id="自动拆箱">自动拆箱</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 编译器会将下面这个调用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
<span style="color:#75715e">// 翻译成
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">).</span><span style="color:#a6e22e">intValue</span><span style="color:#f92672">();</span>
</code></pre></div><ul>
<li>注意，对于包装类，不要使用 <code>==</code> ，要使用 <code>equals</code> 进行比较。</li>
<li>如果一个条件表达式中混合使用 <code>Integer</code> 和 <code>Double</code> 类型，<code>Integer</code> 值就会拆箱，<em><strong>提升为 <code>double</code>，然后再装箱为 <code>Double</code></strong></em>。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
Double d <span style="color:#f92672">=</span> 2<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span> <span style="color:#f92672">?</span> i <span style="color:#f92672">:</span> x<span style="color:#f92672">);</span> <span style="color:#75715e">// 结果是 1.0
</span></code></pre></div></li>
<li>装箱和拆箱是<em><strong>编译器认可</strong></em>的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。而虚拟机只是执行这些字节码。</li>
</ul>
]]></content:encoded></item><item><title>【Java 核心笔记】03. 关于数组</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-03/</link><pubDate>Wed, 27 Sep 2017 16:01:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-03/</guid><description>数组的定义及使用 声明及开辟数组空间 声明数组
int score [] = null; // null表示引用数据类型的默认值 int [] score = null; // 与上一句等价 为数组开辟空间
补充：堆栈内存解释 数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是无法使用的，必须有指向的堆内存才可以使用； 要想开辟新的堆内存，则必须使用 new 关键字，之后只是将此内存的使用权交给了对应的栈内存空间，而且一个堆内存可以被多个栈内存空间指向。 数组的静态初始化 一维数组 int score[] = {1,2,3,4,5}; 二维数组 声明之后再赋值
int arr[][] = new int[4][3]; // 声明并实例化二维数组 arr[0][0] = 201604; arr[0][1] = 1; arr[1][1] = 11; arr[2][2] = 22; arr[3][1] = 31; 声明同时赋值
// 每行的数组元素个数不一样，分配空间不同 public class ArrayDemo { public static void main(String args[]){ int score[][] = { {67,61},{78,89,83},{99,100,98,66,95} }; for(int i=0; i&amp;lt;score.</description><content:encoded><![CDATA[<h1 id="数组的定义及使用">数组的定义及使用</h1>
<h2 id="声明及开辟数组空间">声明及开辟数组空间</h2>
<ol>
<li>
<p>声明数组</p>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-03/resources/declare-array.jpg" alt="声明数组"  />
</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> score <span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// null表示引用数据类型的默认值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> score <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 与上一句等价
</span></code></pre></div></li>
<li>
<p>为数组开辟空间</p>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-03/resources/allocate-memory-to-array.jpg" alt="声明数组"  />
</p>
</li>
</ol>
<ul>
<li>补充：堆栈内存解释
<ul>
<li>数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是无法使用的，必须有指向的堆内存才可以使用；</li>
<li>要想开辟新的堆内存，则必须使用 <code>new</code> 关键字，之后只是将此内存的使用权交给了对应的栈内存空间，而且一个堆内存可以被多个栈内存空间指向。</li>
</ul>
</li>
</ul>
<h2 id="数组的静态初始化">数组的静态初始化</h2>
<h3 id="一维数组">一维数组</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> score<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>3<span style="color:#f92672">,</span>4<span style="color:#f92672">,</span>5<span style="color:#f92672">};</span>
</code></pre></div><h3 id="二维数组">二维数组</h3>
<ul>
<li>
<p>声明之后再赋值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> arr<span style="color:#f92672">[][]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>4<span style="color:#f92672">][</span>3<span style="color:#f92672">];</span> <span style="color:#75715e">// 声明并实例化二维数组
</span><span style="color:#75715e"></span>arr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 201604<span style="color:#f92672">;</span>
arr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
arr<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 11<span style="color:#f92672">;</span>
arr<span style="color:#f92672">[</span>2<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 22<span style="color:#f92672">;</span>
arr<span style="color:#f92672">[</span>3<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 31<span style="color:#f92672">;</span>
</code></pre></div></li>
<li>
<p>声明同时赋值</p>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-03/resources/init-2d-array.jpg" alt="声明二维数组同时赋值"  />
</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 每行的数组元素个数不一样，分配空间不同
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayDemo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[]){</span>
        <span style="color:#66d9ef">int</span> score<span style="color:#f92672">[][]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
            <span style="color:#f92672">{</span>67<span style="color:#f92672">,</span>61<span style="color:#f92672">},{</span>78<span style="color:#f92672">,</span>89<span style="color:#f92672">,</span>83<span style="color:#f92672">},{</span>99<span style="color:#f92672">,</span>100<span style="color:#f92672">,</span>98<span style="color:#f92672">,</span>66<span style="color:#f92672">,</span>95<span style="color:#f92672">}</span>
        <span style="color:#f92672">};</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>score<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++){</span>
            <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> j<span style="color:#f92672">&lt;</span>score<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++){</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>score<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;\t&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">};</span>
</code></pre></div></li>
</ul>
<h1 id="数组的传递引用">数组的传递引用</h1>
<ul>
<li>Java程序设计语言总是采用<strong>按值调用</strong>。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</li>
</ul>
<h2 id="要点">要点</h2>
<ol>
<li>数组引用传递的是 <strong>堆内存</strong> 的使用权，可以将数组传递到方法之中，传递时不需要写 <code>[]</code>，直接写数组名。</li>
<li>方法中对数组的修改都会保留下来。</li>
<li>Java 提供了一些对数组进行操作的方法，例如数组排序，数组拷贝。</li>
</ol>
<h2 id="接收和返回数组">接收和返回数组</h2>
<p>一个方法可以接收一个数组，也可以返回一个数组。</p>
<ul>
<li>接收数组：如果方法接收一个数组的话，则在此方法中对数组做的操作都将被保留下来。</li>
<li>返回数组：方法除了可以接受数组之外，也可以通过方法返回一个数组，只需要在返回值类型上，明确的声明出返回的类型是数组即可。</li>
</ul>
<h2 id="应用举例">应用举例</h2>
<h3 id="1-数组排序">1. 数组排序</h3>
<blockquote>
<p>冒泡排序算法的运作如下：</p>
<p>a. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>b. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>c. 针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>d. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">参考：冒泡排序</a></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 标准冒泡排序法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> temp<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1 <span style="color:#f92672">-</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> temp<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> temp<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
                temp<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
                temp<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// 助记码
</span><span style="color:#75715e">// 参考 https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F#JAVA
</span><span style="color:#75715e"></span>i<span style="color:#960050;background-color:#1e0010">∈</span><span style="color:#f92672">[</span>0<span style="color:#f92672">,</span>N<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span>               <span style="color:#75715e">//循环N-1遍
</span><span style="color:#75715e"></span>    j<span style="color:#960050;background-color:#1e0010">∈</span><span style="color:#f92672">[</span>0<span style="color:#f92672">,</span>N<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>i<span style="color:#f92672">)</span>         <span style="color:#75715e">//每遍循环要处理的无序部分
</span><span style="color:#75715e"></span>        swap<span style="color:#f92672">(</span>j<span style="color:#f92672">,</span>j<span style="color:#f92672">+</span>1<span style="color:#f92672">)</span>     <span style="color:#75715e">//两两排序（升序/降序）
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Java 本身也提供了数组排序的方法（不局限于 int 数组）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> score<span style="color:#f92672">[]={</span>67<span style="color:#f92672">,</span>89<span style="color:#f92672">,</span>87<span style="color:#f92672">,</span>69<span style="color:#f92672">,</span>90<span style="color:#f92672">,</span>100<span style="color:#f92672">,</span>75<span style="color:#f92672">,</span>90<span style="color:#f92672">};</span> <span style="color:#75715e">// 定义整型数组
</span><span style="color:#75715e"></span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">util</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Arrays</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>score<span style="color:#f92672">);</span> <span style="color:#75715e">// 数组排序
</span></code></pre></div><h3 id="2-数组拷贝">2. 数组拷贝</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> i1<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 5<span style="color:#f92672">,</span> 6<span style="color:#f92672">,</span> 7<span style="color:#f92672">,</span> 8<span style="color:#f92672">,</span> 9<span style="color:#f92672">};</span>             <span style="color:#75715e">// 源数组
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> i2<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>11<span style="color:#f92672">,</span> 22<span style="color:#f92672">,</span> 33<span style="color:#f92672">,</span> 44<span style="color:#f92672">,</span> 55<span style="color:#f92672">,</span> 66<span style="color:#f92672">,</span> 77<span style="color:#f92672">,</span> 88<span style="color:#f92672">,</span> 99<span style="color:#f92672">};</span>    <span style="color:#75715e">// 目标数组
</span><span style="color:#75715e"></span>        copy<span style="color:#f92672">(</span>i1<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> i2<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span> 3<span style="color:#f92672">);</span>                              <span style="color:#75715e">// 调用拷贝方法(正常拷贝)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//copy(i1,0,i2,8,2);                                // 数组越界调用
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//System.arraycopy(i1,0,i2,8,2);                    // 系统提供的方法，同上数组越界调用
</span><span style="color:#75715e"></span>        print<span style="color:#f92672">(</span>i2<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 源数组名称，源数组开始点，目标数组名称，目标数组开始点，拷贝长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">copy</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> s<span style="color:#f92672">[],</span> <span style="color:#66d9ef">int</span> s1<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> o<span style="color:#f92672">[],</span> <span style="color:#66d9ef">int</span> s2<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> len<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> len<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            o<span style="color:#f92672">[</span>s2 <span style="color:#f92672">+</span> i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>s1 <span style="color:#f92672">+</span> i<span style="color:#f92672">];</span> <span style="color:#75715e">// 进行拷贝操作
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> temp<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 输出数组内容
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>temp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;\t&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="3-使用方法交换变量值">3. 使用方法交换变量值</h3>
<ul>
<li>Java 总是采用「<strong>按值调用(call by value)</strong>」，即方法得到的是参数值的一个拷贝。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Swap</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> a<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">};</span>
        <span style="color:#66d9ef">int</span> b<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>2<span style="color:#f92672">};</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Swap 1:&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;--Before: &#34;</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">+</span> b<span style="color:#f92672">[</span>0<span style="color:#f92672">]);</span>
        Swap1<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> b<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;--After: &#34;</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">+</span> b<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">);</span>

        a<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
        b<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Swap 2:&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;--Before: &#34;</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">+</span> b<span style="color:#f92672">[</span>0<span style="color:#f92672">]);</span>
        Swap2<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> b<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;--After: &#34;</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">+</span> b<span style="color:#f92672">[</span>0<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/*使用数组实现交换数值*/</span>
    <span style="color:#75715e">/*改变的是对应的堆空间里面的值*/</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Swap1</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num1<span style="color:#f92672">[],</span> <span style="color:#66d9ef">int</span> num2<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> num1<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
        num1<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> num2<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
        num2<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/*改变（交换）的只是num1与num2对堆空间值的引用*/</span>
    <span style="color:#75715e">/*a与b对堆内存的引用并没有改变*/</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Swap2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num1<span style="color:#f92672">[],</span> <span style="color:#66d9ef">int</span> num2<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> temp<span style="color:#f92672">[];</span>
        temp <span style="color:#f92672">=</span> num1<span style="color:#f92672">;</span>
        num1 <span style="color:#f92672">=</span> num2<span style="color:#f92672">;</span>
        num2 <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-03/resources/var-swap.png" alt="交换后结果"  />
</p>
<h2 id="可变参数">可变参数</h2>
<p>即方法中，可以接收的参数不再是固定的，而是随着需要传递。</p>
<p>格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">返回值类型 <span style="color:#a6e22e">方法名称</span><span style="color:#f92672">(</span>类型 <span style="color:#960050;background-color:#1e0010">…</span> 参数名称<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//函数体
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;不传递参数（fun()）：&#34;</span><span style="color:#f92672">);</span>
        fun<span style="color:#f92672">();</span> <span style="color:#75715e">// 不传递参数
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n传递一个参数（fun(1)）：&#34;</span><span style="color:#f92672">);</span>
        fun<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span> <span style="color:#75715e">// 传递一个参数
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n传递五个参数（fun(1,2,3,4,5)）：&#34;</span><span style="color:#f92672">);</span>
        fun<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 5<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">...</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 可变参数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arg<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 循环输出
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>arg<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 输出：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 不传递参数（fun()）：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 传递一个参数（fun(1)）：1 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 传递五个参数（fun(1,2,3,4,5)）：1 2 3 4 5 
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><h2 id="foreach">foreach</h2>
<p>数组的输出，一般都会使用 <code>for</code> 循环输出。在 <code>JDK 1.5</code> 之后，提出一种 <code>foreach</code> 语法。 格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>数据类型 变量名称<span style="color:#f92672">:</span>数组名称<span style="color:#f92672">){</span>
    <span style="color:#75715e">//函数体
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;不传递参数（fun()）：&#34;</span><span style="color:#f92672">);</span>
        fun<span style="color:#f92672">();</span> <span style="color:#75715e">// 不传递参数
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n传递一个参数（fun(1)）：&#34;</span><span style="color:#f92672">);</span>
        fun<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span> <span style="color:#75715e">// 传递一个参数
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;\n传递五个参数（fun(1,2,3,4,5)）：&#34;</span><span style="color:#f92672">);</span>
        fun<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 5<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">...</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 可变参数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg <span style="color:#f92672">:</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 使用foreach输出输出
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>arg <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content:encoded></item><item><title>【Java 核心笔记】02.01 String类</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-02-01/</link><pubDate>Wed, 27 Sep 2017 10:31:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-02-01/</guid><description>String 类的对象实例化 方式一 // 直接赋值 public class StringDemo01 { public static void main(String args[]) { String name = &amp;#34;hiwangzi&amp;#34; ; // 实例化String对象 System.out.println(&amp;#34;姓名：&amp;#34; + name) ; } } 方式二 // 使用关键字 new public class StringDemo02 { public static void main(String args[]) { String name = new String(&amp;#34;hiwangzi&amp;#34;) ; // 实例化String对象 System.out.println(&amp;#34;姓名：&amp;#34; + name) ; } } 两种实例化方法的比较 方式一 public class StringDemo07 { public static void main(String args[]) { String str1 = &amp;#34;hello&amp;#34; ; // 直接赋值 String str2 = &amp;#34;hello&amp;#34; ; // 直接赋值 String str3 = &amp;#34;hello&amp;#34; ; // 直接赋值 System.</description><content:encoded><![CDATA[<h1 id="string-类的对象实例化">String 类的对象实例化</h1>
<h2 id="方式一">方式一</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 直接赋值 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo01</span> <span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span> 
        String name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hiwangzi&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 实例化String对象 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;姓名：&#34;</span> <span style="color:#f92672">+</span> name<span style="color:#f92672">)</span> <span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="方式二">方式二</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 使用关键字 new 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo02</span> <span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span> 
        String name <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hiwangzi&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 实例化String对象 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;姓名：&#34;</span> <span style="color:#f92672">+</span> name<span style="color:#f92672">)</span> <span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="两种实例化方法的比较">两种实例化方法的比较</h1>
<h2 id="方式一-1">方式一</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo07</span> <span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span>
        String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 直接赋值 
</span><span style="color:#75715e"></span>        String str2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 直接赋值 
</span><span style="color:#75715e"></span>        String str3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 直接赋值 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str1 == str2 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str1<span style="color:#f92672">==</span>str2<span style="color:#f92672">))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str1 == str3 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str1<span style="color:#f92672">==</span>str3<span style="color:#f92672">))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str2 == str3 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str2<span style="color:#f92672">==</span>str3<span style="color:#f92672">))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true 
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span>
</code></pre></div><p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02-01/resources/1.png" alt="直接赋值实例化字符串"  />
</p>
<h2 id="方式二-1">方式二</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo08</span> <span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span> <span style="color:#f92672">{</span> 
        String str1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span>
</code></pre></div><p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02-01/resources/2.png" alt="通过new关键字实例化字符串"  />
</p>
<p>故：
使用直接赋值的方式只需要一个实例化对象即可，而使用new String()的方式则需要开辟两个内存对象空间。所以在开发中最好使用直接赋值的方式完成。</p>
<h1 id="字符串的内容不可改变">字符串的内容不可改变</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo09</span><span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[]){</span> 
        String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 声明字符串 
</span><span style="color:#75715e"></span>        str <span style="color:#f92672">=</span> str <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; world!!!&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 修改字符串 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str = &#34;</span> <span style="color:#f92672">+</span> str<span style="color:#f92672">)</span> <span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span> 
<span style="color:#f92672">}</span> 

</code></pre></div><p>运行结果：</p>
<p>表面上改变了字符串 str，而在内存中却并不如此。
str  Str =  &ldquo;hello&rdquo;  &quot; world!&quot;  &ldquo;hello world!&rdquo;  str + &quot; world!&quot;;  String str = &ldquo;hello&rdquo;;  str + &quot; world!&quot;
实际上：</p>
<ul>
<li>字符串的内容一旦声明则不可改变。</li>
<li>字符串内容的改变，实际上改变的是内存地址的引用关系。</li>
</ul>
<p>所以开发中，应避免如下的应用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo10</span><span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[]){</span> 
        String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;LiXingHua&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 声明字符串对象 
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>i<span style="color:#f92672">&lt;</span>100<span style="color:#f92672">;</span>i<span style="color:#f92672">++){</span> <span style="color:#75715e">// 循环修改内容 
</span><span style="color:#75715e"></span>                str1 <span style="color:#f92672">+=</span> i <span style="color:#f92672">;</span> <span style="color:#75715e">// 字符串的引用不断改变 
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> 
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>str1<span style="color:#f92672">)</span> <span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span> 
<span style="color:#f92672">};</span> 

</code></pre></div><p>因为：
这样的操作需要引用与值之间断开-连接100次才可以完成，性能很低，应该避免使用。
若想实现类似的操作，可以使用StringBuffer类。</p>
<h1 id="string-内容的比较">String 内容的比较</h1>
<h2 id="方式一使用--进行比较比较的是堆内存的地址">方式一：使用 == 进行比较（比较的是堆内存的地址）</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo04</span><span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[]){</span> 
        String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 直接赋值 
</span><span style="color:#75715e"></span>        String str2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 通过new赋值 
</span><span style="color:#75715e"></span>        String str3 <span style="color:#f92672">=</span> str2 <span style="color:#f92672">;</span> <span style="color:#75715e">// 传递引用 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str1 == str2 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str1<span style="color:#f92672">==</span>str2<span style="color:#f92672">))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// false 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str1 == str3 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str1<span style="color:#f92672">==</span>str3<span style="color:#f92672">))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// false 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str2 == str3 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str2<span style="color:#f92672">==</span>str3<span style="color:#f92672">))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true 
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> 
<span style="color:#f92672">};</span> 

</code></pre></div><p>OKI 001  0M 002  strl  str2  str3  String strl = &ldquo;hello&rdquo;  = new  String str2  = str2•.  String str3  &ldquo;hello&rdquo;  &ldquo;hello&rdquo;</p>
<ul>
<li>现在使用的判断相等，是判断地址空间是否相等，判断的是地址值。</li>
<li>如果要想判断其内容是否相等，则就需使用String类中提供的equals()方法。</li>
</ul>
<h2 id="方式二使用-equals-方法进行比较比较的是字符串的内容">方式二：使用 equals() 方法进行比较（比较的是字符串的内容）</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StringDemo04</span> <span style="color:#f92672">{</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[]){</span> 
        String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 直接赋值 
</span><span style="color:#75715e"></span>        String str2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// 通过new赋值 
</span><span style="color:#75715e"></span>        String str3 <span style="color:#f92672">=</span> str2 <span style="color:#f92672">;</span> <span style="color:#75715e">// 传递引用 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str1 equals str2 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>str2<span style="color:#f92672">)))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str1 equals str3 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>str3<span style="color:#f92672">)))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true 
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;str2 equals str3 --&gt; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>str2<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>str3<span style="color:#f92672">)))</span> <span style="color:#f92672">;</span> <span style="color:#75715e">// true 
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> 
<span style="color:#f92672">};</span> 

</code></pre></div>]]></content:encoded></item><item><title>【Java 核心笔记】02. 数据类型与运算符</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-02/</link><pubDate>Wed, 27 Sep 2017 10:30:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-02/</guid><description>数据类型 概述 注意：
在 Java 中，小数默认类型为 double，整数默认类型是 int 基本数据类型的默认值（开发中尽可能为每一个变量赋初值） 类型 默认值 byte (byte) 0 short (short) 0 int 0 long 0L float 0.0f double 0.0d char \u0000 boolean false 基本数据类型 整型 注意：Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。 不同进制的表示形式：
十六进制数值有一个前缀 0x 或 0X（如0xCAFE）。 八进制有一个前缀 0，例如，010 对应十进制中的 8 。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。 从Java 7开始，加上前缀 0b 或 0B 就可以写二进制数。例如， 0b1001 就是 9 。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用（1_000_000 或 0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。 浮点类型 可以使用十六进制表示浮点数值。例如，0.</description><content:encoded><![CDATA[<h1 id="数据类型">数据类型</h1>
<h2 id="概述">概述</h2>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02/resources/data-type.jpg" alt="数据类型"  />
</p>
<p>注意：</p>
<ul>
<li>在 Java 中，小数默认类型为 <code>double</code>，整数默认类型是 <code>int</code></li>
<li>基本数据类型的默认值（开发中尽可能为每一个变量赋初值）
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>(byte) 0</td>
</tr>
<tr>
<td>short</td>
<td>(short) 0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="基本数据类型">基本数据类型</h2>
<h3 id="整型">整型</h3>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02/resources/integer.jpg" alt="整型"  />
</p>
<p>注意：Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。
不同进制的表示形式：</p>
<ul>
<li>十六进制数值有一个前缀 <code>0x</code> 或 <code>0X</code>（如<code>0xCAFE</code>）。</li>
<li>八进制有一个前缀 <code>0</code>，例如，<code>010</code> 对应十进制中的 <code>8</code> 。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。</li>
<li>从Java 7开始，加上前缀 <code>0b</code> 或 <code>0B</code> 就可以写二进制数。例如， <code>0b1001</code> 就是 <code>9</code> 。另外，同样是从 <code>Java 7</code> 开始，还可以为数字字面量加下划线，如用（<code>1_000_000</code> 或 <code>0b1111_0100_0010_0100_0000</code>）表示一百万。这些下划线只是为了让人更易读。Java<strong>编译器</strong>会去除这些下划线。</li>
</ul>
<h3 id="浮点类型">浮点类型</h3>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02/resources/float.jpg" alt="浮点类型"  />
</p>
<p>可以使用十六进制表示浮点数值。例如，<code>0.125=2^(-3)</code>可以表示成<code>0x1.0p-3</code>。在十六进制表示法中，使用p表示指数，而不是e。
<strong>注意，底数采用十六进制，指数采用十进制。指数的基数是2，而不是10。</strong>
所有浮点数的计算都遵循 IEEE754 规范。表示溢出和出错情况的三个特殊的浮点数值：</p>
<ul>
<li>正无穷大（Double.POSITIVE_INFINITY）</li>
<li>负无穷大（Double.NEGATIVE_INFINITY）</li>
<li>NaN（不是一个数字，Double.NaN）</li>
</ul>
<p>判断是否是“非数值” <code>if((Double.isNaN(x)) //check whether x is &quot;not a number&quot;</code></p>
<p>IEEE 754 浮点数值不适用于无法接受舍入误差的金融计算中。例如，命令<code>System.out.println(2.0-1.1)</code> 将打印出 <code>0.8999999999999999</code>，而不是人们想象的 <code>0.9</code>。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数 <code>1/10</code>。这就好像十进制无法精确地表示分数 <code>1/3</code> 一样。如果在数值计算中不允许有任何舍入误差，就应该使用 <code>BigDecimal</code> 类。</p>
<h3 id="char-类型">char 类型</h3>
<p>char 类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些 Unicode 字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值。</p>
<p>📒 关于字符编码更多内容请参考<a href="/posts/2018/03/11/unicode-notes">《Unicode 笔记》</a>。</p>
<p>char 类型的值可以表示为十六进制值，其范围从 <code>\u0000</code> 到 <code>\uFFFF</code>。
除了转义序列 <code>\u</code> 之外，还有一些用于表示特殊字符的转义序列，请参看表3-3。</p>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02/resources/escape-sequence.png" alt="escape-sequence.png"  />
</p>
<ul>
<li>所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，<code>'\u2122'</code> 或 <code>&quot;Hello\n&quot;</code>。</li>
<li>转义序列 <code>\u</code> 还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以）。例如：<code>public static void main(String\u0058\u005D args)</code> 是符合语法规则的，因为 <code>\u0058 \u005D</code> 分别表示 <code>[  ]</code>。
<ul>
<li>Unicode转义序列会在 <strong>解析代码之前</strong> 得到处理。例如， <code>&quot;\u0022+\u0022&quot;</code> 并不是一个由引号(U+0022)包围加号构成的字符串。实际上，<code>\u0022</code> 会在解析之前转换为 <code>&quot;</code>，这会得到 <code>&quot;&quot;+&quot;&quot;</code>，也就是一个空串。</li>
<li>更隐秘地，一定要当心注释中的 <code>\u</code>。注释 <code>// \u00A0 is a newline</code> 会产生一个语法错误，因为读程序时 <code>\u00A0</code> 会替换为一个换行符。类似地，下面这个注释 <code>// look inside c:\users</code> 也会产生一个语法错误，因为 <code>\u</code> 后面并未跟着4个十六进制数。</li>
</ul>
</li>
</ul>
<h3 id="boolean类型">boolean类型</h3>
<p><em>整型值</em> 和 <em>布尔值</em> 之间<strong>不能相互转换</strong>。</p>
<h2 id="基本数据类型的转换">基本数据类型的转换</h2>
<h3 id="自动转换">自动转换</h3>
<p>条件（需要2个同时满足）：</p>
<ul>
<li>转换前的数据类型与转换后的数据类型兼容</li>
<li>转换后的数据类型的表示范围比转换前的大</li>
</ul>
<p>补充：任何类型的数据都可向 String 类型转换。例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span> <span style="color:#e6db74">&#34;1 + 2 = &#34;</span> <span style="color:#f92672">+</span> 1 <span style="color:#f92672">+</span> 2 <span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span> <span style="color:#e6db74">&#34;1 + 2 = &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span> 1 <span style="color:#f92672">+</span> 2 <span style="color:#f92672">)</span> <span style="color:#f92672">);</span>
<span style="color:#75715e">// 输出
</span><span style="color:#75715e">// 1 + 2 = 12
</span><span style="color:#75715e">// 1 + 2 = 3
</span></code></pre></div><p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02/resources/auto-type-conversion.jpg" alt="自动类型转换"  />

注：虚线箭头可能有精度的损失</p>
<h3 id="强制转换">强制转换</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// (欲转换的类型) 变量名称
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> x <span style="color:#f92672">=</span> 9<span style="color:#f92672">.</span><span style="color:#a6e22e">997</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> x<span style="color:#f92672">;</span> <span style="color:#75715e">// 变量nx的值为9。强制类型转换通过截断小数部分将浮点值转换为整型。
</span></code></pre></div><ul>
<li>
<p>如果想对浮点数进行舍入运算，以便得到最接近的整数（在很多情况下，这种操作更有用），那就需要使用Math.round方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">double</span> x <span style="color:#f92672">=</span> 9<span style="color:#f92672">.</span><span style="color:#a6e22e">997</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">round</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span> <span style="color:#75715e">// 现在，变量 nx 的值为10。当调用 round 的时候，仍然需要使用强制类型转换（int）。其原因是round 方法返回的结果为 long 类型，由于存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将 long 类型转换成 int 类型。
</span></code></pre></div></li>
</ul>
<h2 id="复合数据类型">复合数据类型</h2>
<h3 id="枚举类型">枚举类型</h3>
<p>例：
枚举类型 Size 的声明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">enum</span> Size <span style="color:#f92672">{</span> SMALL<span style="color:#f92672">,</span> MEDIUM<span style="color:#f92672">,</span> LARGE<span style="color:#f92672">,</span> EXTRA_LARGE <span style="color:#f92672">};</span>
</code></pre></div><p>声明 Size 类型变量：<code>Size s = Size.MEDIUM;</code></p>
<p>注意：Size 类型的变量只能存储这个类型声明中给定的某个枚举值，或者 null 值。</p>
<p>补充：</p>
<blockquote>
<p>跟类定义一样，枚举类型可以单独放在一个文件里，当一个枚举类型用 public 修饰时，它对其他包可见，否则只对同一个包中的类可见，这和类定义是一样的。</p>
<p>标识符 <code>SMALL</code>, <code>MEDIUM</code> 等就称为枚举常量（enumeration constants）</p>
<p>每一个枚举常量被隐式的声明成 Day 的一个 <code>public</code> 、 <code>static</code> 成员，而且其类型为 <code>Size</code> ，亦就是说这些常量是 <code>self-typed</code> 的</p>
<p><a href="http://bbs.csdn.net/topics/300112959">参考：Java 里有枚举类型吗？如何定义？</a></p>
</blockquote>
<h3 id="字符串">字符串</h3>
<ul>
<li>字符串是不可变的</li>
<li>使用<code>equals()</code>方法比较字符串内容
<ul>
<li>如果虚拟机始终将相同的字符串共享，就可以使用 <code>==</code> 运算符检测是否相等。但实际上只有字符串常量是共享的，而 <code>+</code> 或 <code>.substring(parm)</code> 等操作产生的结果并不是共享的。因此，千万不要使用 <code>==</code> 运算符测试字符串的相等性，以免在程序中出现糟糕的 bug。从表面上看，这种 bug 很像随机产生的间歇性错误。</li>
</ul>
</li>
<li>空串：<code>str.length()  == 0</code> 或 <code>str.equals(&quot;&quot;)</code></li>
<li>Null串：<code>str == null</code></li>
</ul>
<h4 id="length-方法"><code>length</code> 方法</h4>
<ul>
<li>Java 语言里 String 在内存中以是 UTF-16 方式编码</li>
<li><code>&quot;&quot;.length()</code>：The length is equal to the number of Unicode code units in the string.</li>
<li>因此，实际<code>length</code>方法在Java中返回的是UTF-16的代码单元数目。</li>
<li>BMP内的字符转义<code>\uXXXX</code>即可（Unicode转义序列会在解析代码之前得到处理）</li>
<li>增补平面内的字符转义写成 UTF-16 的代理对形式，例：<code>U+1D11E</code>写作<code>\uD834\uDD1E</code>，虽然是一个字符，但其<code>.length()</code>结果为2</li>
<li>若想得到非BMP的字符数，可以使用<code>codePointCount</code>方法。</li>
</ul>
<h4 id="getbytes-方法"><code>getBytes</code> 方法</h4>
<ul>
<li><code>.getBytes()</code> 不过是把「一种编码」的字节数组转换成「另一种编码」的字节数组。
<ul>
<li>这里的「一种编码」在 Java 中就是 UTF-16。</li>
<li>这里的「另一种编码」则由调用者来指定，不指定就用缺省（JVM的默认编码，JVM启动时如果没有明确指定，则默认使用操作系统的缺省编码）。</li>
</ul>
</li>
</ul>
<h1 id="运算符">运算符</h1>
<h2 id="逻辑运算符">逻辑运算符</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑非</td>
<td>!</td>
</tr>
<tr>
<td>逻辑与</td>
<td>&amp;</td>
</tr>
<tr>
<td>逻辑或</td>
<td>|</td>
</tr>
<tr>
<td>短路与</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>短路或</td>
<td>||</td>
</tr>
<tr>
<td>异或</td>
<td>^</td>
</tr>
</tbody>
</table>
<p>例：「短路与」示例 （若使用“与”，则会报错(10/0)，使用「短路与」则可以正常运行）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 10<span style="color:#f92672">,</span> m <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">boolean</span> k <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>n <span style="color:#f92672">!=</span> 10 <span style="color:#f92672">&amp;&amp;</span> 10<span style="color:#f92672">/</span>0 <span style="color:#f92672">==</span> 9<span style="color:#f92672">){</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(!</span>k<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>k<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="位运算符">位运算符</h2>
<pre><code>&amp;     (&quot;and&quot;)
|     (&quot;or&quot;)
^     (&quot;xor&quot;)
~     (&quot;not&quot;)
&lt;&lt;    左移
&gt;&gt;    右移（用符号位填充高位）
&gt;&gt;&gt;   (用0填充高位)
</code></pre><h2 id="运算符优先级">运算符优先级</h2>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-02/resources/operator-priority.jpg" alt="运算符优先级"  />
</p>
]]></content:encoded></item><item><title>【Java 核心笔记】01. Java介绍</title><link>https://hiwangzi.com/posts/2017/09/27/core-java-01/</link><pubDate>Wed, 27 Sep 2017 10:27:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/09/27/core-java-01/</guid><description>「白皮书」关键术语 简单性 C++&amp;ndash; 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java 发展历程 SUN公司——Stanford University Network 主设计者：James Gosling 1996年初 - 发布 Java 1.0 Java 2, JDK 1.2 有了很大的改变 - 更加接近“一次编写，随处运行”的承诺 J2SE 5.0 得到了进一步改进 - 泛型、(以下几项受 C# 启发) foreach、自动装箱、注解 2014年 - 发布 Java 8 - 重大改变：提供了一种「函数式」编程方式，可以容易地表述并发执行的计算 Java 主要技术分支 Java SE Java 2 Platform, Standard Edition 前身：J2SE，2005年更名为Java SE Java EE（主要应用） Java 2 Platform, Enterprise Edition 前身：J2EE，2005年更名为Java EE Java ME（嵌入式） Java 2 Platform, Micro Edition 前身：J2ME，2005年更名为Java ME JVM, JRE, JDK JVM(Java Virtual Machine) &amp;lt; JRE(Java Runtime Environment) &amp;lt; JDK(Java Development Kit) “跨平台” 与 “解释执行” 早期的 Java是解释型的。现在 Java 虚拟机使用了即时编译器，因此采用 Java 编写的“热点”代码其运行速度与 C++ 相差无几，有些情况下甚至更快。 Java 开发环境 Path 的主要功能是设置 JDK 的可执行命令 classpath 主要是在执行的时候起作用，告诉JVM类的保存路径，一般（默认）设置为.</description><content:encoded><![CDATA[<h2 id="白皮书关键术语">「白皮书」关键术语</h2>
<ul>
<li>简单性 C++&ndash;</li>
<li>面向对象</li>
<li>分布式</li>
<li>健壮性</li>
<li>安全性</li>
<li>体系结构中立</li>
<li>可移植性</li>
<li>解释型</li>
<li>高性能</li>
<li>多线程</li>
<li>动态性</li>
</ul>
<h2 id="java-发展历程">Java 发展历程</h2>
<ul>
<li>SUN公司——Stanford University Network</li>
<li>主设计者：James Gosling</li>
<li>1996年初 - 发布 Java 1.0</li>
<li>Java 2, JDK 1.2 有了很大的改变 - 更加接近“一次编写，随处运行”的承诺</li>
<li>J2SE 5.0 得到了进一步改进 - 泛型、(以下几项受 C# 启发) foreach、自动装箱、注解</li>
<li>2014年 - 发布 Java 8 - 重大改变：提供了一种「<strong>函数式</strong>」编程方式，可以容易地表述并发执行的计算</li>
</ul>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-01/resources/java-version.jpg" alt="Java的版本"  />
</p>
<h2 id="java-主要技术分支">Java 主要技术分支</h2>
<ul>
<li>Java SE
Java 2 Platform, Standard Edition
前身：J2SE，2005年更名为Java SE</li>
<li>Java EE（主要应用）
Java 2 Platform, Enterprise Edition
前身：J2EE，2005年更名为Java EE</li>
<li>Java ME（嵌入式）
Java 2 Platform, Micro Edition
前身：J2ME，2005年更名为Java ME</li>
</ul>
<h2 id="jvm-jre-jdk">JVM, JRE, JDK</h2>
<ul>
<li>JVM(Java Virtual Machine) &lt; JRE(Java Runtime Environment) &lt; JDK(Java Development Kit)</li>
</ul>
<h2 id="跨平台-与-解释执行">“跨平台” 与 “解释执行”</h2>
<ul>
<li>早期的 Java是解释型的。现在 Java 虚拟机使用了即时编译器，因此采用 Java 编写的“热点”代码其运行速度与 C++ 相差无几，有些情况下甚至更快。</li>
</ul>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-01/resources/java-cross-platform.png" alt="Java的跨平台性"  />
</p>
<h2 id="java-开发环境">Java 开发环境</h2>
<ol>
<li>Path 的主要功能是设置 JDK 的可执行命令</li>
<li>classpath 主要是在执行的时候起作用，告诉JVM类的保存路径，一般（默认）设置为<code>.</code>（cmd设置命令：<code>set classpath=.</code>）</li>
</ol>
<ul>
<li>注意：classpath 只在 java 命令时起作用，对 javac 无作用</li>
</ul>
<h2 id="一些术语">一些术语</h2>
<p><img loading="lazy" src="https://hiwangzi.com/posts/2017/09/27/core-java-01/resources/java-terms.jpg" alt="Java的一些术语"  />
</p>
<ul>
<li>当Oracle为解决一些紧急问题做出某些微小的版本改变时，将其称为更新。例如：Java SE 8u31是Java SE 8的第31次更新，它的内部版本号是1.8.0_31。更新不需要安装在前一个版本上，它会包含整个JDK的最新版本。</li>
</ul>
]]></content:encoded></item></channel></rss>