<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Web on WANG!</title><link>https://hiwangzi.com/tags/web/</link><description>Recent content in Web on WANG!</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 14 May 2018 00:00:00 +0800</lastBuildDate><atom:link href="https://hiwangzi.com/tags/web/index.xml" rel="self" type="application/rss+xml"/><item><title>译｜在 URLs 中使用 JSON</title><link>https://hiwangzi.com/posts/2018/05/14/json-in-urls/</link><pubDate>Mon, 14 May 2018 00:00:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2018/05/14/json-in-urls/</guid><description>除了在 URL 中使用路径作为参数或使用查询参数之外，是否还有更好的选择呢？</description><content:encoded><![CDATA[<blockquote>
<p>原文地址：<a href="https://blogs.dropbox.com/developers/2015/03/json-in-urls/">JSON in URLs | Dropbox Developer Blog</a></p>
</blockquote>
<p>基于 HTTP 的 API 经常将参数编码为 URL 路径或查询参数。例如，调用丢丢盒（Dropbox）API 搜索文件名时的路径可能如下所示：</p>
<pre><code>/1/search/auto/My+Documents?query=draft+2013
</code></pre><p>虽然对于简单的例子而言，使用 URL 编码似乎已经足够完美，但使用 JSON 可能也有一些优点。</p>
<h2 id="混乱的-url-路径">混乱的 URL 路径</h2>
<p>在上面的例子中，因为第一个 <code>+</code> 就在 URL 之中，所以其就是字面意义上的加号。而第二个 <code>+</code> 表示一个空格，因为它位于 URL 查询部分。这两者很容易混淆，因为他们的编码规则在大多数情况下是相同的，而且就像 <code>urlencode</code> 一样，有时一些库提供的函数的名字又非常模棱两可。我们 SDK 的一个早期版本就因此有过一个 bug。</p>
<p>另一个常见的错误就是误认为在路径部分 <code>/</code> 同其他普通字符一样。</p>
<ul>
<li><code>/hello-world</code> 等价于 <code>/hello%2Dworld</code></li>
<li><code>/hello/world</code> <strong>不</strong>等价于 <code>/hello%2Fworld</code></li>
</ul>
<p>符号 <code>/</code> 是保留的分界符。将其改为使用 <code>%</code> 编码的形式会改变 URL 的含义。大多数 URL 编码库并没有非常清晰地对两者作出区分。虽然大多数情况下这不重要，<a href="https://sakurity.com/blog/2015/03/15/authy_bypass.html">但某些情况却非常关键</a>。</p>
<h2 id="url-查询参数表现力不足">URL 查询参数表现力不足</h2>
<p>假设 API 参数需要一组值时，该怎么处理呢？一些 API 可能使用逗号或重复的名字来处理。</p>
<pre><code>/docs/salary.csv?columns=1,2
/docs/salary.csv?column=1&amp;column=2
</code></pre><p>对于嵌套的字段，一些 API 可能如下处理：</p>
<pre><code>/emails?from[name]=Don&amp;from[date]=1998-03-24&amp;to[name]=Norm
</code></pre><p>这些变通都是合理的，但他们仍然只是变通之举。并没有普遍的标准。但 JSON 可以一致、简单的处理嵌套。</p>
<h2 id="使用-url-编码是否很糟糕呢">使用 URL 编码是否很糟糕呢？</h2>
<p>不，它只是为不同的情况设计的：人类交互使用。</p>
<p>JSON 将一切字符串用引号包裹。这让许多事情变得更简单以及更健壮，但对于人们来说，读与写可能略显乏味单调。</p>
<p>相较于 JSON，URL 参数可以更快的开始使用。在通常情况下，这非常不错。但缺点就是更容易造成混乱，因此任何处理 URL 参数的代码都会变得很复杂。</p>
<p>这里要做一些合理的权衡。 我不会在我的浏览器地址栏使用 JSON，但对于基于 HTTP 的 API 来说，使用 JSON 来处理可能是一个更好的选择。</p>
<h2 id="所以问题在哪儿呢">所以问题在哪儿呢？</h2>
<p>当思考到这的时候，我们可以说对比于 URL 编码，使用 JSON 在某些方面更佳。对于结构化的数据，HTTP API 响应已经基本上都在使用 JSON 了。最近一次我处理 URL 编码的响应体是在 2007 年时使用 OAuth 1。目前 OAuth 2 已经使用 JSON 了。</p>
<p>API 请求体分裂成了 JSON 和 URL 编码两种形式。URL 编码的一个好处是<a href="https://stripe.com/docs/api/curl#create_charge">你可以很好的使用 <code>curl</code> 命令行工具做示例</a>。但很多 API，包括丢丢盒新一些的 API，已经开始在请求体中使用 JSON。</p>
<p>所以为什么不在 URL 中同样使用 JSON 呢？就像下面这样：</p>
<ul>
<li>URL encoded: <code>/log?a=b&amp;c=4</code></li>
<li>JSON in URL: <code>/log?%7B%22a%22:%22b%22,%22c%22:4%7D</code></li>
</ul>
<p>第一点，JSON 形式更长了。这可能会导致你的 URL 超出<a href="https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers/417184#417184">长度限制</a>。</p>
<p>同时，它看起来很丑，但这可以通过抽象来解决。例如，除非在 packet 层面上出现了错误，否则你也无需去处理原始网络 packet。同样的道理，除非你的 URL 出现错误，否则你无需去接触丑陋版本的 URL。一旦它通过了检测，你在错误消息或日志输出中看到的就只是解码过的字符串了。</p>
<p>创建一个整理抽象层需要花费额外的工作，尤其过去从未使用过类似方式。虽然在 URL 中使用 JSON 前期会有一些烦恼，但它带来的好处值得让人一试。</p>
]]></content:encoded></item><item><title>《图解HTTP》笔记——Web 基础</title><link>https://hiwangzi.com/posts/2017/12/03/http-note-web/</link><pubDate>Sun, 03 Dec 2017 10:29:00 +0800</pubDate><guid>https://hiwangzi.com/posts/2017/12/03/http-note-web/</guid><description>Web 基础 三项构建技术：
HTML：页面的文本标记语言 HTTP：文档传输协议 URL：指定文档所在地址 一些概念 HTTP（HyperText Transfer Protocol）：通常被译为“超文本传输协议”，但严谨应译为“超文本转移协议”
传输（transport）：从端到端可靠地搬运比特，属于 TCP/IP 中传输层（transport layer）协议处理的事 转移（transfer）：在客户端-服务器之间转移一些带有操作语义的原语，来执行某些操作，属于TCP/IP中应用层的事务。 HTTP 版本
HTTP/0.9：并没有作为正式标准被建立 HTTP/1.0：公布于 1996 年 5 月，记录于 RFC1945 HTTP/1.1：公布于 1997 年 1 月，最初标准为 RFC 2068，后来发布修订版 RFC2616，目前主流被使用的版本 HTTP/2.0 TCP/IP 协议族
应用层 （FTP、DNS、HTTP&amp;hellip;） 传输层 用于提供处于网络连接中的两台计算机之间的数据传输（TCP、UDP） 网络层 用来处理在网络上流动的数据包（IP） 数据链路层 用来处理连接网络的硬件部分 HTTP over TCP/IP 通信传输图解：</description><content:encoded><![CDATA[<h1 id="web-基础">Web 基础</h1>
<p>三项构建技术：</p>
<ul>
<li>HTML：页面的文本标记语言</li>
<li>HTTP：文档传输协议</li>
<li>URL：指定文档所在地址</li>
</ul>
<h2 id="一些概念">一些概念</h2>
<ul>
<li>
<p>HTTP（HyperText Transfer Protocol）：通常被译为“超文本传输协议”，但严谨应译为“超文本转移协议”</p>
<ul>
<li>传输（transport）：从端到端可靠地搬运比特，属于 TCP/IP 中传输层（transport layer）协议处理的事</li>
<li>转移（transfer）：在客户端-服务器之间转移一些带有操作语义的原语，来执行某些操作，属于TCP/IP中应用层的事务。</li>
</ul>
</li>
<li>
<p>HTTP 版本</p>
<ul>
<li>HTTP/0.9：并没有作为正式标准被建立</li>
<li>HTTP/1.0：公布于 1996 年 5 月，记录于 RFC1945</li>
<li>HTTP/1.1：公布于 1997 年 1 月，最初标准为 RFC 2068，后来发布修订版 RFC2616，目前主流被使用的版本</li>
<li>HTTP/2.0</li>
</ul>
</li>
<li>
<p>TCP/IP 协议族</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>（FTP、DNS、HTTP&hellip;）</td>
</tr>
<tr>
<td>传输层</td>
<td>用于提供处于网络连接中的两台计算机之间的数据传输（TCP、UDP）</td>
</tr>
<tr>
<td>网络层</td>
<td>用来处理在网络上流动的数据包（IP）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>用来处理连接网络的硬件部分</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>HTTP over TCP/IP 通信传输图解：</p>
<p><img loading="lazy" src="./resources/1104579-20171203102739226-772718691.jpg" alt="http-over-tcp-ip"  />
</p>
</li>
<li>
<p>各种协议与 HTTP 协议的关系：</p>
<p><img loading="lazy" src="./resources/1104579-20171203102657319-1819007375.jpg" alt="http-and-other-protocols"  />
</p>
</li>
<li>
<p>URI 和 URL</p>
<ul>
<li>URI：Uniform Resource Identifier</li>
<li>URL：Uniform Resource Locator</li>
<li>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）所以说，URL 是 URI 的子集。</li>
</ul>
</li>
<li>
<p>URI 的举例分析</p>
<p><img loading="lazy" src="./resources/1104579-20171203102808601-1312573802.jpg" alt="uri-example"  />
</p>
</li>
</ul>
]]></content:encoded></item></channel></rss>