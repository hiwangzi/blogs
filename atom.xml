<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WANG!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiwangzi.com/"/>
  <updated>2018-05-15T10:56:25.957Z</updated>
  <id>https://hiwangzi.com/</id>
  
  <author>
    <name>zill057</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「译」在 URLs 中使用 JSON</title>
    <link href="https://hiwangzi.com/2018/05/14/json-in-urls/"/>
    <id>https://hiwangzi.com/2018/05/14/json-in-urls/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-05-15T10:56:25.957Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://blogs.dropbox.com/developers/2015/03/json-in-urls/" target="_blank" rel="noopener">JSON in URLs | Dropbox Developer Blog</a></p></blockquote><p>基于 HTTP 的 API 经常将参数编码为 URL 路径或查询参数。例如，调用丢丢盒（Dropbox）API 搜索文件名时的路径可能如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/1/search/auto/My+Documents?query=draft+2013</span><br></pre></td></tr></table></figure><p>虽然对于简单的例子而言，使用 URL 编码似乎已经足够完美，但使用 JSON 可能也有一些优点。</p><h2 id="混乱的-URL-路径"><a href="#混乱的-URL-路径" class="headerlink" title="混乱的 URL 路径"></a>混乱的 URL 路径</h2><p>在上面的例子中，因为第一个 <code>+</code> 就在 URL 之中，所以其就是字面意义上的加号。而第二个 <code>+</code> 表示一个空格，因为它位于 URL 查询部分。这两者很容易混淆，因为他们的编码规则在大多数情况下是相同的，而且就像 <code>urlencode</code> 一样，有时一些库提供的函数的名字又非常模棱两可。我们 SDK 的一个早期版本就因此有过一个 bug。</p><p>另一个常见的错误就是误认为在路径部分 <code>/</code> 同其他普通字符一样。</p><ul><li><code>/hello-world</code> 等价于 <code>/hello%2Dworld</code></li><li><code>/hello/world</code> <strong>不</strong>等价于 <code>/hello%2Fworld</code></li></ul><p>符号 <code>/</code> 是保留的分界符。将其改为使用 <code>%</code> 编码的形式会改变 URL 的含义。大多数 URL 编码库并没有非常清晰地对两者作出区分。虽然大多数情况下这不重要，<a href="https://sakurity.com/blog/2015/03/15/authy_bypass.html" target="_blank" rel="noopener">但某些情况却非常关键</a>。</p><h2 id="URL-查询参数表现力不足"><a href="#URL-查询参数表现力不足" class="headerlink" title="URL 查询参数表现力不足"></a>URL 查询参数表现力不足</h2><p>假设 API 参数需要一组值时，该怎么处理呢？一些 API 可能使用逗号或重复的名字来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/docs/salary.csv?columns=1,2</span><br><span class="line">/docs/salary.csv?column=1&amp;column=2</span><br></pre></td></tr></table></figure><p>对于嵌套的字段，一些 API 可能如下处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/emails?from[name]=Don&amp;from[date]=1998-03-24&amp;to[name]=Norm</span><br></pre></td></tr></table></figure><p>这些变通都是合理的，但他们仍然只是变通之举。并没有普遍的标准。但 JSON 可以一致、简单的处理嵌套。</p><h2 id="使用-URL-编码是否很糟糕呢？"><a href="#使用-URL-编码是否很糟糕呢？" class="headerlink" title="使用 URL 编码是否很糟糕呢？"></a>使用 URL 编码是否很糟糕呢？</h2><p>不，它只是为不同的情况设计的：人类交互使用。</p><p>JSON 将一切字符串用引号包裹。这让许多事情变得更简单以及更健壮，但对于人们来说，读与写可能略显乏味单调。</p><p>相较于 JSON，URL 参数可以更快的开始使用。在通常情况下，这非常不错。但缺点就是更容易造成混乱，因此任何处理 URL 参数的代码都会变得很复杂。</p><p>这里要做一些合理的权衡。 我不会在我的浏览器地址栏使用 JSON，但对于基于 HTTP 的 API 来说，使用 JSON 来处理可能是一个更好的选择。</p><h2 id="所以问题在哪儿呢？"><a href="#所以问题在哪儿呢？" class="headerlink" title="所以问题在哪儿呢？"></a>所以问题在哪儿呢？</h2><p>当思考到这的时候，我们可以说对比于 URL 编码，使用 JSON 在某些方面更佳。对于结构化的数据，HTTP API 响应已经基本上都在使用 JSON 了。最近一次我处理 URL 编码的响应体是在 2007 年时使用 OAuth 1。目前 OAuth 2 已经使用 JSON 了。</p><p>API 请求体分裂成了 JSON 和 URL 编码两种形式。URL 编码的一个好处是<a href="https://stripe.com/docs/api/curl#create_charge" target="_blank" rel="noopener">你可以很好的使用 <code>curl</code> 命令行工具做示例</a>。但很多 API，包括丢丢盒新一些的 API，已经开始在请求体中使用 JSON。</p><p>所以为什么不在 URL 中同样使用 JSON 呢？就像下面这样：</p><ul><li>URL encoded: <code>/log?a=b&amp;c=4</code></li><li>JSON in URL: <code>/log?%7B%22a%22:%22b%22,%22c%22:4%7D</code></li></ul><p>第一点，JSON 形式更长了。这可能会导致你的 URL 超出<a href="https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers/417184#417184" target="_blank" rel="noopener">长度限制</a>。</p><p>同时，它看起来很丑，但这可以通过抽象来解决。例如，除非在 packet 层面上出现了错误，否则你也无需去处理原始网络 packet。同样的道理，除非你的 URL 出现错误，否则你无需去接触丑陋版本的 URL。一旦它通过了检测，你在错误消息或日志输出中看到的就只是解码过的字符串了。</p><p>创建一个整理抽象层需要花费额外的工作，尤其过去从未使用过类似方式。虽然在 URL 中使用 JSON 前期会有一些烦恼，但它带来的好处值得让人一试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://blogs.dropbox.com/developers/2015/03/json-in-urls/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JSON in URLs | Drop
      
    
    </summary>
    
    
      <category term="Web" scheme="https://hiwangzi.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>「译」if(a-b&amp;lt;0) 与 if(a&amp;lt;b) 的区别</title>
    <link href="https://hiwangzi.com/2018/05/08/difference-between-if-a-b-0-and-if-a-b/"/>
    <id>https://hiwangzi.com/2018/05/08/difference-between-if-a-b-0-and-if-a-b/</id>
    <published>2018-05-07T16:00:00.000Z</published>
    <updated>2018-05-14T06:44:30.629Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#问题">问题</a></li><li><a href="#赞同最多的回答">赞同最多的回答</a></li></ul><!-- /TOC --><blockquote><p>原文地址：<a href="https://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b" target="_blank" rel="noopener">java - Difference between if (a - b &lt; 0) and if (a &lt; b) - Stack Overflow</a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在阅读 Java 的 <code>ArrayList</code> 源代码时，我注意到在 <code>if</code> 语句中的一些比较语句。</p><p>在 Java 7 之中，<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/ArrayList.java#ArrayList.grow%28int%29" target="_blank" rel="noopener"><code>grow(int)</code></a> 方法使用了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br></pre></td></tr></table></figure><p>在 Java 6 中，没有 <code>grow</code> 方法。但方法 <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/util/ArrayList.java#ArrayList.ensureCapacity%28int%29" target="_blank" rel="noopener"><code>ensureCapacity(int)</code></a> 却使用如下方式比较数值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newCapacity &lt; minCapacity)</span><br><span class="line">    newCapacity = minCapacity;</span><br></pre></td></tr></table></figure><p>变更比较语句写法的原因是什么呢？为了性能还是说只是代码风格的变化？</p><p>我可以理解，与 0 作比较速度更快，但同时却需多执行一个减法，这不是额外的开销吗？同时对于编译后的字节码来说，做差比较需要涉及两个指令（<code>ISUB</code> 和 <code>IF_ICMPGE</code>），而直接比较只需要涉及 <code>IFGE</code> 一条指令。</p><h2 id="赞同最多的回答"><a href="#赞同最多的回答" class="headerlink" title="赞同最多的回答"></a>赞同最多的回答</h2><p><code>a &lt; b</code> 与 <code>a - b &lt; 0</code> 可以表示不同的含义。</p><p>考虑如下场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> b = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    System.out.println(<span class="string">"a &lt; b"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a - b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"a - b &lt; 0"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是：只会打印 <code>a - b &lt; 0</code>。因为 <code>a &lt; b</code> 显然是 false，但 <code>a - b</code> 产生了溢出，结果是 <code>-1</code>，因此结果为 true。</p><ul><li>译者注：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">//  2147483647</span></span><br><span class="line"><span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br></pre></td></tr></table></figure></li></ul><p>说回问题本身，我们假设数组长度本身已经非常接近于 <code>Integer.MAX_VALUE</code> 来看一看。<code>ArrayList</code> 之中的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：可以查看问题中的第一个链接 grow(int) 方法</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br></pre></td></tr></table></figure><p><code>oldCapacity</code> 非常接近 <code>Integer.MAX_VALUE</code>，因此 <code>newCapacity</code>（即<code>oldCapacity + 0.5 * oldCapacity</code>）有可能产生溢出，假设溢出后值为 <code>Integer.MIN_VALUE</code> (负值)。然后，减去 <code>minCapacity</code> 又<strong>下溢</strong>变为正值（译者注：假设参数<code>minCapacity</code>为正值）。</p><p>因此第一个 <code>if</code> 块中的代码将不会被执行。但假设代码条件写作 <code>if (newCapacity &lt; minCapacity)</code>，结果将会是 <code>true</code>（因为 <code>newCapacity</code> 是负值），这将导致 <code>newCapacity</code> 被强行指定为 <code>minCapacity</code> 而没有考虑 <code>minCapacity</code>。</p><p>这个溢出问题将会被下一个 <code>if</code> 语句所处理。当 <code>newCapacity</code> 溢出后，此 <code>if</code> 的结果为 <code>true</code>：<code>MAX_ARRAY_SIZE</code> 为 <code>Integer.MAX_VALUE - 8</code>，所以 <code>Integer.MIN_VALUE - (Integer.MAX_VALUE - 8) &gt; 0</code> 为 <code>true</code>。因此 <code>newCapacity</code> 可以被正确的处理：<code>hugeCapacity</code> 方法将返回 <code>MAX_ARRAY_SIZE</code> 或 <code>Integer.MAX_VALUE</code>。</p><p>注意：这就是对应 Java 代码中注释 <code>// overflow-conscious</code> 的含义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#问题&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#赞同最多的回答&quot;&gt;赞同最多的回答&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;
&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="Java" scheme="https://hiwangzi.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>安装 Arch 中遇到的 Broadcom b43(BCM43228) 网卡问题</title>
    <link href="https://hiwangzi.com/2018/03/25/arch-install-with-bcm/"/>
    <id>https://hiwangzi.com/2018/03/25/arch-install-with-bcm/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-05-04T08:21:29.789Z</updated>
    
    <content type="html"><![CDATA[<p>之前按照以 <a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">官方 Wiki 的方式安装 ArchLinux</a>，并结合 <a href="https://wiki.archlinux.org/index.php/installation_guide" target="_blank" rel="noopener">官方文档</a>，成功的在 VirtualBox 环境下安装好了 Arch。虚拟机限于内存、显卡等因素，体验不够好，因此今天准备在旧笔记本实机安装。在第一步联网过程中，就遇到了阻碍，特此记录。</p><h2 id="查看网卡类型"><a href="#查看网卡类型" class="headerlink" title="查看网卡类型"></a>查看网卡类型</h2><p>在之前的虚拟机环境下，采用 NAT 模式联网，网卡自动识别并加载，只需要执行 <code>dhcpcd</code> 获取 IP 后即可成功连接互联网。但这次，系统并不能自动驱动硬件工作，所以我们需要先检查一下网卡类型。</p><ul><li><p>执行 <code>lspci -k</code> 查看 Network controller 这一项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02:00.0 Network controller: Broadcom Limited BCM43228 802.11a/b/g/n</span><br><span class="line">Subsystem: Foxconn International, Inc. BCM43228 802.11a/b/g/n</span><br><span class="line">Kernel driver in use: bcma-pci-bridge</span><br><span class="line">Kernel moudles: bcma</span><br></pre></td></tr></table></figure></li><li><p>检查 <code>ip link</code> 输出结果中有没有 <code>wlan0</code> 或 <code>wlps21</code> 一类的设备。如果有的话，只需要执行 <code>ip link set &lt;设备名&gt; up</code> 即可，无需再额外安装驱动程序。</p></li><li><p>如果没有，即需要检查内核的固件信息 <code>dmesg | grep firmware</code>，得到更多提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b43-phy0 ERROR: You must go to http://wireless.kernel.or/en/users/Drivers/b43#devicefirmware and download the correct firmware for this driver version.</span><br></pre></td></tr></table></figure><ul><li>如果没有这样的信息，可以先尝试执行 <code>iwlwifi</code> 一类命令，然后查找对应的错误信息 <code>dmesg | grep iwlwifi</code></li><li>获得提示信息后，例如上面的网站，可以访问得到进一步的信息。此处根据上述 <code>ERROR</code> 中的网站给出的指导，执行 <code>lspci -nn -d 14e4:</code> 获得详细的硬件型号，并下载<a href="https://aur.archlinux.org/packages/b43-firmware/" target="_blank" rel="noopener">对应的驱动</a>。关于博通无线网卡，可以查阅 <a href="https://wiki.archlinux.org/index.php/Broadcom_wireless" target="_blank" rel="noopener">Wiki</a> 页面 获得更多信息</li></ul></li></ul><h2 id="下载并安装驱动"><a href="#下载并安装驱动" class="headerlink" title="下载并安装驱动"></a>下载并安装驱动</h2><ul><li>没网络怎么下载 ❓ 可以下载至安装U盘的根目录，安装时切换至 <code>/run/archiso/bootmnt</code>，即可看到下载的内容，将其拷贝至 <code>/root</code> 解压。</li><li>如何来安装驱动 ❓ <a href="https://www.cnblogs.com/clouds008/p/7460928.html" target="_blank" rel="noopener">更多参考</a> 在上一步解压完成后，会得到一个 <code>.o</code> 结尾的问题，执行 <code>b43-fwcutter -w /lib/firmware xxx.o</code> 即可完成安装。</li><li><p>安装后怎么启动 ❓ <a href="http://linuxwireless.sipsolutions.net/en/users/Drivers/b43/" target="_blank" rel="noopener">更多参考</a> 卸载之前的驱动，然后再加载新安装的驱动。</p><ul><li><p>卸载旧驱动（如果你知道你正在使用的驱动名称的话，只需执行对应的命令即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modprobe -r b43 bcma</span><br><span class="line">modprobe -r brcmsmac bcma</span><br><span class="line">modprobe -r wl</span><br></pre></td></tr></table></figure></li><li><p>加载新驱动（只需执行对应的驱动命令即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modprobe b43</span><br><span class="line">modprobe brcmsmac</span><br><span class="line">modprobe wl</span><br></pre></td></tr></table></figure></li></ul></li><li><p>安装完成后可以通过 <code>ip link</code> 查看是否有新增加的网络接口信息。</p></li></ul><h2 id="安装完成后的联网过程"><a href="#安装完成后的联网过程" class="headerlink" title="安装完成后的联网过程"></a>安装完成后的联网过程</h2><blockquote><p>此部分内容主要参考了 <a href="https://linux.cn/article-4015-1.html" target="_blank" rel="noopener">在命令行中管理 Wifi 连接</a></p></blockquote><ul><li>通过 <code>ip link set &lt;设备名&gt; up</code> 启动接口服务。</li><li>可以通过 <code>iw dev &lt;设备名&gt; scan | less</code> 扫描附近网络。</li><li><p>联网（方式 1）无加密网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iw dev &lt;设备名&gt; connect &lt;网络 SSID&gt;</span><br></pre></td></tr></table></figure></li><li><p>联网（方式 2）WEP 加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iw dev &lt;设备名&gt; connect &lt;网络 SSID&gt; key 0:&lt;WEP密钥&gt;</span><br></pre></td></tr></table></figure></li><li><p>联网（方式 3）WPA/WPA2 加密（现在最常见）</p><ul><li><p><code>vim /etc/wpasupplicant/wpa_supplicant.conf</code> 编辑文件（其实放在别的位置也行），增加如下内容（注意包含引号）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;&lt;网络 SSID&gt;&quot;</span><br><span class="line">    psk=&quot;&lt;密码&gt;&quot;</span><br><span class="line">    priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>wpa_supplicant -i &lt;设备名&gt; -c /etc/wpa_supplicant/wpa_supplicant.conf &amp;</code> 后台启动网络连接</p></li></ul></li><li><p>获取 IP：<code>dhcpcd &lt;设备名&gt;</code> 自动获取 IP 地址</p></li><li>测试网络：<code>ping hiwangzi.com</code> 测试网络连接是否正常~</li></ul>]]></content>
    
    <summary type="html">
    
      之前按照《以官方 Wiki 的方式安装 ArchLinux》，并结合官方文档，成功的在 VirtualBox 环境下安装好了 Arch。虚拟机限于内存、显卡等因素，体验不够好，因此今天准备在旧笔记本实机安装。在第一步联网过程中，就遇到了阻碍，特此记录。
    
    </summary>
    
    
      <category term="Linux" scheme="https://hiwangzi.com/tags/Linux/"/>
    
  </entry>
  
</feed>
