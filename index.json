[{"content":"目的  不想掏出手机扫描二维码 不想保存成文件，再使用解析工具（太麻烦  目标  截图后可以自动识别二维码内容  使用说明  需要安装：pngpaste, zbar (使用 homebrew 安装: brew install pngpaste zbar） 使用截图软件，保存至剪贴板后，执行以下命令  pngpaste - | zbarimg -q PNG:- | awk -F 'QR-Code:' '{print $2}' 演示  我使用的截图软件 Xnip 此处我为上述命令定义了别名 dqr 演示中的二维码（你也可以试一试   ","permalink":"https://hiwangzi.com/posts/2020/05/21/mac-scan-qr-code-from-pasteboard-after-screen-capture/","summary":"macOS中截图后识别二维码","title":"截图 | 识别二维码"},{"content":"因为切换了博客生成器，订阅地址发生了变化，请订阅 新地址。\n昨天晚上开始折腾将 Hexo 替换为 Hugo 来生成博客，以下是关于我对于 Hugo 的一些配置。\n 修改 archetypes/default.md，默认模版增加了 summary、tags 字段。 建立 config 目录代替原有的 config.toml，根据官方文档说明，创建了默认（均先加载该配置，然后加载其他配置）以及两个环境下的配置目录（development、production）。这样就可以实现默认情况下 hugo server 调用 development 配置，hugo 调用 production 配置。 通过 Git 子模块的形式，引入主题 tale，根据主题的文档说明，做了如下操作：  覆盖了部分页面配置，目的是自定义菜单栏、加载 Disqus 评论插件。 覆盖了 favicon 静态资源，实现自定义站点 icon 图标。   通过修改配置文件，将生成结果放置到 docs 目录下。这样可以通过配置 GitHub 项目的 Pages 获取方式，来实现页面的渲染。  通过 Hugo 的 taxonomies 机制，实现标签。  感受  比起 Hexo，Hugo 的速度真的快很多。 项目中可以摆脱复杂的 npm 依赖，也可以减少一个系统级的 npm 包。  ","permalink":"https://hiwangzi.com/posts/2019/04/17/hugo-now/","summary":"从 Hexo 切换到 Hugo！","title":"Hugo Now"},{"content":"最近看到 V2EX 上一个帖子《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。\n帖子正文中贴出的代码为：\nimport java.util.ArrayList; import java.util.List; public class ForeachTest { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; test = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { test.add(i); } System.out.println(test); for (int i = 0; i \u0026lt; 50; i++) { for (int t : test) { System.out.println(t); test.remove(t); break; } } System.out.println(test); } } 我预测的执行结果：\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 0 1 2 3 ……此处省略 47 48 49 [50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 实际执行结果：\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 0 1 1 1 ……此处省略 1 1 1 [1, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 我预测的理由是，每次最内层的循环只执行一次，并且移除第一个元素。但我忽略了一点，楼主贴出的代码之中，实际调用的是 remove(int) 方法，而不是 remove(Object) 方法。前者是根据下标移除对应元素，后者是移除对应的元素。第一次循环之中，移除了第0个元素（test.get(0)值为0），随后的循环，均移除第1个元素（test.get(0)值为1）。\n因此，将 for (int t : test) 更改为 for (Integer t : test)，即可实现预测中的输出。\n","permalink":"https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/","summary":"最近看到 V2EX 上一个帖子《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。","title":"java.util.List 的 remove(int) 与 remove(Object)"},{"content":" 原文地址：JSON in URLs | Dropbox Developer Blog\n 基于 HTTP 的 API 经常将参数编码为 URL 路径或查询参数。例如，调用丢丢盒（Dropbox）API 搜索文件名时的路径可能如下所示：\n/1/search/auto/My+Documents?query=draft+2013 虽然对于简单的例子而言，使用 URL 编码似乎已经足够完美，但使用 JSON 可能也有一些优点。\n混乱的 URL 路径 在上面的例子中，因为第一个 + 就在 URL 之中，所以其就是字面意义上的加号。而第二个 + 表示一个空格，因为它位于 URL 查询部分。这两者很容易混淆，因为他们的编码规则在大多数情况下是相同的，而且就像 urlencode 一样，有时一些库提供的函数的名字又非常模棱两可。我们 SDK 的一个早期版本就因此有过一个 bug。\n另一个常见的错误就是误认为在路径部分 / 同其他普通字符一样。\n /hello-world 等价于 /hello%2Dworld /hello/world 不等价于 /hello%2Fworld  符号 / 是保留的分界符。将其改为使用 % 编码的形式会改变 URL 的含义。大多数 URL 编码库并没有非常清晰地对两者作出区分。虽然大多数情况下这不重要，但某些情况却非常关键。\nURL 查询参数表现力不足 假设 API 参数需要一组值时，该怎么处理呢？一些 API 可能使用逗号或重复的名字来处理。\n/docs/salary.csv?columns=1,2 /docs/salary.csv?column=1\u0026amp;column=2 对于嵌套的字段，一些 API 可能如下处理：\n/emails?from[name]=Don\u0026amp;from[date]=1998-03-24\u0026amp;to[name]=Norm 这些变通都是合理的，但他们仍然只是变通之举。并没有普遍的标准。但 JSON 可以一致、简单的处理嵌套。\n使用 URL 编码是否很糟糕呢？ 不，它只是为不同的情况设计的：人类交互使用。\nJSON 将一切字符串用引号包裹。这让许多事情变得更简单以及更健壮，但对于人们来说，读与写可能略显乏味单调。\n相较于 JSON，URL 参数可以更快的开始使用。在通常情况下，这非常不错。但缺点就是更容易造成混乱，因此任何处理 URL 参数的代码都会变得很复杂。\n这里要做一些合理的权衡。 我不会在我的浏览器地址栏使用 JSON，但对于基于 HTTP 的 API 来说，使用 JSON 来处理可能是一个更好的选择。\n所以问题在哪儿呢？ 当思考到这的时候，我们可以说对比于 URL 编码，使用 JSON 在某些方面更佳。对于结构化的数据，HTTP API 响应已经基本上都在使用 JSON 了。最近一次我处理 URL 编码的响应体是在 2007 年时使用 OAuth 1。目前 OAuth 2 已经使用 JSON 了。\nAPI 请求体分裂成了 JSON 和 URL 编码两种形式。URL 编码的一个好处是你可以很好的使用 curl 命令行工具做示例。但很多 API，包括丢丢盒新一些的 API，已经开始在请求体中使用 JSON。\n所以为什么不在 URL 中同样使用 JSON 呢？就像下面这样：\n URL encoded: /log?a=b\u0026amp;c=4 JSON in URL: /log?%7B%22a%22:%22b%22,%22c%22:4%7D  第一点，JSON 形式更长了。这可能会导致你的 URL 超出长度限制。\n同时，它看起来很丑，但这可以通过抽象来解决。例如，除非在 packet 层面上出现了错误，否则你也无需去处理原始网络 packet。同样的道理，除非你的 URL 出现错误，否则你无需去接触丑陋版本的 URL。一旦它通过了检测，你在错误消息或日志输出中看到的就只是解码过的字符串了。\n创建一个整理抽象层需要花费额外的工作，尤其过去从未使用过类似方式。虽然在 URL 中使用 JSON 前期会有一些烦恼，但它带来的好处值得让人一试。\n","permalink":"https://hiwangzi.com/posts/2018/05/14/json-in-urls/","summary":"除了在 URL 中使用路径作为参数或使用查询参数之外，是否还有更好的选择呢？","title":"译｜在 URLs 中使用 JSON"},{"content":"目录  问题 赞同最多的回答   原文地址：java - Difference between if (a - b \u0026lt; 0) and if (a \u0026lt; b) - Stack Overflow\n 问题 在阅读 Java 的 ArrayList 源代码时，我注意到在 if 语句中的一些比较语句。\n在 Java 7 之中，grow(int) 方法使用了如下代码：\nif (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; 在 Java 6 中，没有 grow 方法。但方法 ensureCapacity(int) 却使用如下方式比较数值：\nif (newCapacity \u0026lt; minCapacity) newCapacity = minCapacity; 变更比较语句写法的原因是什么呢？为了性能还是说只是代码风格的变化？\n我可以理解，与 0 作比较速度更快，但同时却需多执行一个减法，这不是额外的开销吗？同时对于编译后的字节码来说，做差比较需要涉及两个指令（ISUB 和 IF_ICMPGE），而直接比较只需要涉及 IFGE 一条指令。\n赞同最多的回答 a \u0026lt; b 与 a - b \u0026lt; 0 可以表示不同的含义。\n考虑如下场景：\nint a = Integer.MAX_VALUE; int b = Integer.MIN_VALUE; if (a \u0026lt; b) { System.out.println(\u0026#34;a \u0026lt; b\u0026#34;); } if (a - b \u0026lt; 0) { System.out.println(\u0026#34;a - b \u0026lt; 0\u0026#34;); } 执行结果是：只会打印 a - b \u0026lt; 0。因为 a \u0026lt; b 显然是 false，但 a - b 产生了溢出，结果是 -1，因此结果为 true。\n 译者注： int max = Integer.MAX_VALUE; // 2147483647 int min = Integer.MIN_VALUE; // -2147483648   说回问题本身，我们假设数组长度本身已经非常接近于 Integer.MAX_VALUE 来看一看。ArrayList 之中的代码如下：\n// 译者注：可以查看问题中的第一个链接 grow(int) 方法 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); oldCapacity 非常接近 Integer.MAX_VALUE，因此 newCapacity（即oldCapacity + 0.5 * oldCapacity）有可能产生溢出，假设溢出后值为 Integer.MIN_VALUE (负值)。然后，减去 minCapacity 又下溢变为正值（译者注：假设参数minCapacity为正值）。\n因此第一个 if 块中的代码将不会被执行。但假设代码条件写作 if (newCapacity \u0026lt; minCapacity)，结果将会是 true（因为 newCapacity 是负值），这将导致 newCapacity 被强行指定为 minCapacity 而没有考虑 minCapacity。\n这个溢出问题将会被下一个 if 语句所处理。当 newCapacity 溢出后，此 if 的结果为 true：MAX_ARRAY_SIZE 为 Integer.MAX_VALUE - 8，所以 Integer.MIN_VALUE - (Integer.MAX_VALUE - 8) \u0026gt; 0 为 true。因此 newCapacity 可以被正确的处理：hugeCapacity 方法将返回 MAX_ARRAY_SIZE 或 Integer.MAX_VALUE。\n注意：这就是对应 Java 代码中注释 // overflow-conscious 的含义。\n","permalink":"https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/","summary":"一个针对此问题 Stack Overflow 上的回答。","title":"译｜if(a - b \u003c 0) 与 if(a \u003c b) 的区别"},{"content":"之前按照以 官方 Wiki 的方式安装 ArchLinux，并结合 官方文档，成功的在 VirtualBox 环境下安装好了 Arch。虚拟机限于内存、显卡等因素，体验不够好，因此今天准备在旧笔记本实机安装。在第一步联网过程中，就遇到了阻碍，特此记录。\n查看网卡类型 在之前的虚拟机环境下，采用 NAT 模式联网，网卡自动识别并加载，只需要执行 dhcpcd 获取 IP 后即可成功连接互联网。但这次，系统并不能自动驱动硬件工作，所以我们需要先检查一下网卡类型。\n 执行 lspci -k 查看 Network controller 这一项。  02:00.0 Network controller: Broadcom Limited BCM43228 802.11a/b/g/n Subsystem: Foxconn International, Inc. BCM43228 802.11a/b/g/n Kernel driver in use: bcma-pci-bridge Kernel moudles: bcma   检查 ip link 输出结果中有没有 wlan0 或 wlps21 一类的设备。如果有的话，只需要执行 ip link set \u0026lt;设备名\u0026gt; up 即可，无需再额外安装驱动程序。\n  如果没有，即需要检查内核的固件信息 dmesg | grep firmware，得到更多提示\n  b43-phy0 ERROR: You must go to http://wireless.kernel.or/en/users/Drivers/b43#devicefirmware and download the correct firmware for this driver version.  如果没有这样的信息，可以先尝试执行 iwlwifi 一类命令，然后查找对应的错误信息 dmesg | grep iwlwifi 获得提示信息后，例如上面的网站，可以访问得到进一步的信息。此处根据上述 ERROR 中的网站给出的指导，执行 lspci -nn -d 14e4: 获得详细的硬件型号，并下载对应的驱动。关于博通无线网卡，可以查阅 Wiki 页面 获得更多信息  下载并安装驱动   没网络怎么下载 ❓ 可以下载至安装U盘的根目录，安装时切换至 /run/archiso/bootmnt，即可看到下载的内容，将其拷贝至 /root 解压。\n  如何来安装驱动 ❓ 更多参考 在上一步解压完成后，会得到一个 .o 结尾的问题，执行 b43-fwcutter -w /lib/firmware xxx.o 即可完成安装。\n  安装后怎么启动 ❓ 更多参考 卸载之前的驱动，然后再加载新安装的驱动。\n 卸载旧驱动（如果你知道你正在使用的驱动名称的话，只需执行对应的命令即可） modprobe -r b43 bcma modprobe -r brcmsmac bcma modprobe -r wl  加载新驱动（只需执行对应的驱动命令即可） modprobe b43 modprobe brcmsmac modprobe wl     安装完成后可以通过 ip link 查看是否有新增加的网络接口信息。\n  安装完成后的联网过程  此部分内容主要参考了 在命令行中管理 Wifi 连接\n   通过 ip link set \u0026lt;设备名\u0026gt; up 启动接口服务。\n  可以通过 iw dev \u0026lt;设备名\u0026gt; scan | less 扫描附近网络。\n  联网（方式 1）无加密网络\niw dev \u0026lt;设备名\u0026gt; connect \u0026lt;网络 SSID\u0026gt;   联网（方式 2）WEP 加密\niw dev \u0026lt;设备名\u0026gt; connect \u0026lt;网络 SSID\u0026gt; key 0:\u0026lt;WEP密钥\u0026gt;   联网（方式 3）WPA/WPA2 加密（现在最常见）\nnetwork={ ssid=\u0026#34;\u0026lt;网络 SSID\u0026gt;\u0026#34; psk=\u0026#34;\u0026lt;密码\u0026gt;\u0026#34; priority=1 }  vim /etc/wpasupplicant/wpa_supplicant.conf 编辑文件（其实放在别的位置也行），增加以上内容（注意包含引号） wpa_supplicant -i \u0026lt;设备名\u0026gt; -c /etc/wpa_supplicant/wpa_supplicant.conf \u0026amp; 后台启动网络连接    获取 IP：dhcpcd \u0026lt;设备名\u0026gt; 自动获取 IP 地址\n  测试网络：ping hiwangzi.com 测试网络连接是否正常~\n  ","permalink":"https://hiwangzi.com/posts/2018/03/25/arch-install-with-bcm/","summary":"之前按照《以官方 Wiki 的方式安装 ArchLinux》，并结合官方文档，成功的在 VirtualBox 环境下安装好了 Arch。虚拟机限于内存、显卡等因素，体验不够好，因此今天准备在旧笔记本实机安装。在第一步联网过程中，就遇到了阻碍，特此记录。","title":"安装 Arch 中遇到的 Broadcom b43(BCM43228) 网卡问题"},{"content":" 难以想象的晴朗  ","permalink":"https://hiwangzi.com/about/","summary":"about","title":"值得探访的星球"}]