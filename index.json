[{"content":"距离2021结束还有2个多小时，此刻的我已经昏昏沉沉，眼皮耷拉。\n或许是只有近期才会记忆深刻，或许是上半年确实没什么值得记忆，只有最近几个月的事还留在脑海中。\n  十月份，去长沙玩耍了一趟   虽然2021里也没有什么特别值得述说的故事，但心态还是有所成长，尤其是在和亲密的人产生争执独处的日子里。或许是开心的日子，就迷迷糊糊一不留神，就从指尖溜走；又或许是那些快乐也只是庸人的傻乐。但总之，2021让我真正再次审视自己是发生在最后的两个月里。\n以下是12月月初写下的文字：\n 2021年，最后30天，即将跟25岁告别，还是挺恍惚的，一个数字就这样到了自己的眼前。\n前段时间看的一期圆桌派，窦文涛讲到，重大的心态改变或者说人生转变，都是发生在旅途中，或者是突然出现的意外后。大意是说，只有当自己独处之时，才会真正地思考自己。\n那最近这段日子，或许就属于我的这个阶段吧。\n历史上自己想做过的事情很多，而真正做成的事情寥寥无几，仿佛生命无限长，总是能有那么一个未来，成为自己想象中的自己。以上这种想法也并不是第一次才想到，之前每次的结论都是相似，在“要从现在开始珍惜每一天，认真做事，过好每一天”这样的话语下，继续在一天天的生活和无痕的时光里，沉湎。\n而这次，感觉似乎有那么一些不一样。此刻的我，开始觉得，生活或许就是这样，值得纪念的日子总是少数。之前总是崇尚于宏大话题，忘记了宏大是由一点点小事构成的，反复提及宏大，或许只是因为从未迈开过第三步，第一步壮志凌云，第二步咬牙切齿，然后，就没有然后了。\n何苦迷恋于自己心中的完美呢。60分OK，80分很棒，总会有日子，成为值得纪念的某天。\n不过，切实可行的目标，还是要有的，希望在这2021年的尾巴里，做成以下几件事：\n 再减重5KG Target: 82KG 读完《Java编程的逻辑》 学完《赖世雄音标》 读完《Animal Farm》  谨此。以上。\n 那现在，要对自己做一个汇报。\n在汇报开始之前，要纠正上文中的一个高预期错误，希望做成的第一件事中的82KG就是加倍之后的要求，11月30日的体重是89KG，所以实际目标应该为84KG。对于目标，总是盲目乐观，是自己的一个问题，希望在2022年，能慢慢调整这一点。至少，目标估计得要准确一些。\n对了，还有自己在这段时间里，想到了「自己为什么不喜欢打游戏」这个问题的答案。是因为自己总想成为一个天赋者，总希望自己能被大家道出 wow。然而现实是，我在知道自己是不是所谓天赋者的反面之前，就因为不能实现这个高高的目标，在笨拙之中离开，似乎使自己保留了一种体面。然而现在意识到之后，很想对当时的自己说，「大可不必，没有那么多聚光灯投射在身上，做自己就好了。而且终有一天，你会说出『I don’t give a shit』」。\n  2021年12月31日 体重 86.5 KG   虽然目标1没有达成，但11月开始的努力还是力挽狂澜，控制住了发福K线图😂\n目标2《Java编程的逻辑》这本书也没读完，在阅读过程之中，发现还是需要再复习一下数据结构与算法，就开始看《数据结构与算法图解》了。\n目标3可以说初步完成，但是后半部分的辅音，尤其是这 [ʒ] [n] [ŋ] [l] 四个，对我来说很难，还是需要再多多练习。\n目标4在12月14日时，决定放到元旦之后进行。\n总结一下，40%的完成率是有的，对于自己还是一个可以接受的结果。虽然过程不总是如意，但有计划指导，还是好过前半年的得过且过。\n  11月后开始记录的观影记录     2021年的读书记录     2021年的跑步记录   对于2022年，我的愿望/目标：\n 精进技术，读完之前列的书单 学好英语，能够真正地使用使用这门语言 体魄健壮，生活能够更加健康（80KG以下、每天有效睡眠8小时、吃得健康自律）  那再来2个小目标吧：\n 读书12本（4本英文书） 跑量达到365✖️2 = 730KM  不管如何，最重要的是认真生活。愿我的朋友们、家人们，愿每个人，都有自己喜欢的生活！\n","permalink":"https://hiwangzi.com/posts/2021/12/31/goodbye-2021/","summary":"距离2021结束还有2个多小时，此刻的我已经昏昏沉沉，眼皮耷拉。\n或许是只有近期才会记忆深刻，或许是上半年确实没什么值得记忆，只有最近几个月的事还留在脑海中。\n  十月份，去长沙玩耍了一趟   虽然2021里也没有什么特别值得述说的故事，但心态还是有所成长，尤其是在和亲密的人产生争执独处的日子里。或许是开心的日子，就迷迷糊糊一不留神，就从指尖溜走；又或许是那些快乐也只是庸人的傻乐。但总之，2021让我真正再次审视自己是发生在最后的两个月里。\n以下是12月月初写下的文字：\n 2021年，最后30天，即将跟25岁告别，还是挺恍惚的，一个数字就这样到了自己的眼前。\n前段时间看的一期圆桌派，窦文涛讲到，重大的心态改变或者说人生转变，都是发生在旅途中，或者是突然出现的意外后。大意是说，只有当自己独处之时，才会真正地思考自己。\n那最近这段日子，或许就属于我的这个阶段吧。\n历史上自己想做过的事情很多，而真正做成的事情寥寥无几，仿佛生命无限长，总是能有那么一个未来，成为自己想象中的自己。以上这种想法也并不是第一次才想到，之前每次的结论都是相似，在“要从现在开始珍惜每一天，认真做事，过好每一天”这样的话语下，继续在一天天的生活和无痕的时光里，沉湎。\n而这次，感觉似乎有那么一些不一样。此刻的我，开始觉得，生活或许就是这样，值得纪念的日子总是少数。之前总是崇尚于宏大话题，忘记了宏大是由一点点小事构成的，反复提及宏大，或许只是因为从未迈开过第三步，第一步壮志凌云，第二步咬牙切齿，然后，就没有然后了。\n何苦迷恋于自己心中的完美呢。60分OK，80分很棒，总会有日子，成为值得纪念的某天。\n不过，切实可行的目标，还是要有的，希望在这2021年的尾巴里，做成以下几件事：\n 再减重5KG Target: 82KG 读完《Java编程的逻辑》 学完《赖世雄音标》 读完《Animal Farm》  谨此。以上。\n 那现在，要对自己做一个汇报。\n在汇报开始之前，要纠正上文中的一个高预期错误，希望做成的第一件事中的82KG就是加倍之后的要求，11月30日的体重是89KG，所以实际目标应该为84KG。对于目标，总是盲目乐观，是自己的一个问题，希望在2022年，能慢慢调整这一点。至少，目标估计得要准确一些。\n对了，还有自己在这段时间里，想到了「自己为什么不喜欢打游戏」这个问题的答案。是因为自己总想成为一个天赋者，总希望自己能被大家道出 wow。然而现实是，我在知道自己是不是所谓天赋者的反面之前，就因为不能实现这个高高的目标，在笨拙之中离开，似乎使自己保留了一种体面。然而现在意识到之后，很想对当时的自己说，「大可不必，没有那么多聚光灯投射在身上，做自己就好了。而且终有一天，你会说出『I don’t give a shit』」。\n  2021年12月31日 体重 86.5 KG   虽然目标1没有达成，但11月开始的努力还是力挽狂澜，控制住了发福K线图😂\n目标2《Java编程的逻辑》这本书也没读完，在阅读过程之中，发现还是需要再复习一下数据结构与算法，就开始看《数据结构与算法图解》了。\n目标3可以说初步完成，但是后半部分的辅音，尤其是这 [ʒ] [n] [ŋ] [l] 四个，对我来说很难，还是需要再多多练习。\n目标4在12月14日时，决定放到元旦之后进行。\n总结一下，40%的完成率是有的，对于自己还是一个可以接受的结果。虽然过程不总是如意，但有计划指导，还是好过前半年的得过且过。\n  11月后开始记录的观影记录     2021年的读书记录     2021年的跑步记录   对于2022年，我的愿望/目标：","title":"再见 2021"},{"content":"目的  不想掏出手机扫描二维码 不想保存成文件，再使用解析工具（太麻烦  目标  截图后可以自动识别二维码内容  使用说明  需要安装：pngpaste, zbar (使用 homebrew 安装: brew install pngpaste zbar） 使用截图软件，保存至剪贴板后，执行以下命令  pngpaste - | zbarimg -q PNG:- | awk -F 'QR-Code:' '{print $2}' 演示  我使用的截图软件 Xnip 此处我为上述命令定义了别名 dqr 演示中的二维码（你也可以试一试   ","permalink":"https://hiwangzi.com/posts/2020/05/21/mac-scan-qr-code-from-pasteboard-after-screen-capture/","summary":"macOS中截图后识别二维码","title":"截图 | 识别二维码"},{"content":"因为切换了博客生成器，订阅地址发生了变化，请订阅 新地址。\n昨天晚上开始折腾将 Hexo 替换为 Hugo 来生成博客，以下是关于我对于 Hugo 的一些配置。\n 修改 archetypes/default.md，默认模版增加了 summary、tags 字段。 建立 config 目录代替原有的 config.toml，根据官方文档说明，创建了默认（均先加载该配置，然后加载其他配置）以及两个环境下的配置目录（development、production）。这样就可以实现默认情况下 hugo server 调用 development 配置，hugo 调用 production 配置。 通过 Git 子模块的形式，引入主题 tale，根据主题的文档说明，做了如下操作：  覆盖了部分页面配置，目的是自定义菜单栏、加载 Disqus 评论插件。 覆盖了 favicon 静态资源，实现自定义站点 icon 图标。   通过修改配置文件，将生成结果放置到 docs 目录下。这样可以通过配置 GitHub 项目的 Pages 获取方式，来实现页面的渲染。  通过 Hugo 的 taxonomies 机制，实现标签。  感受  比起 Hexo，Hugo 的速度真的快很多。 项目中可以摆脱复杂的 npm 依赖，也可以减少一个系统级的 npm 包。  ","permalink":"https://hiwangzi.com/posts/2019/04/17/hugo-now/","summary":"从 Hexo 切换到 Hugo！","title":"Hugo Now"},{"content":"最近看到 V2EX 上一个帖子《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。\n帖子正文中贴出的代码为：\nimport java.util.ArrayList; import java.util.List; public class ForeachTest { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; test = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { test.add(i); } System.out.println(test); for (int i = 0; i \u0026lt; 50; i++) { for (int t : test) { System.out.println(t); test.remove(t); break; } } System.out.println(test); } } 我预测的执行结果：\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 0 1 2 3 ……此处省略 47 48 49 [50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 实际执行结果：\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 0 1 1 1 ……此处省略 1 1 1 [1, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 我预测的理由是，每次最内层的循环只执行一次，并且移除第一个元素。但我忽略了一点，楼主贴出的代码之中，实际调用的是 remove(int) 方法，而不是 remove(Object) 方法。前者是根据下标移除对应元素，后者是移除对应的元素。第一次循环之中，移除了第0个元素（test.get(0)值为0），随后的循环，均移除第1个元素（test.get(0)值为1）。\n因此，将 for (int t : test) 更改为 for (Integer t : test)，即可实现预测中的输出。\n","permalink":"https://hiwangzi.com/posts/2018/07/08/java-util-list-remove-int-remove-object/","summary":"最近看到 V2EX 上一个帖子《关于 Java foreach 循环删除多个元素的有趣问题（不是抛异常哦）》，我根据代码预测的执行结果与实际楼主贴出的并不相同。看了评论，才发现自己忽略了一点，觉得有点意思，因此记录一下。","title":"java.util.List 的 remove(int) 与 remove(Object)"},{"content":" 原文地址：JSON in URLs | Dropbox Developer Blog\n 基于 HTTP 的 API 经常将参数编码为 URL 路径或查询参数。例如，调用丢丢盒（Dropbox）API 搜索文件名时的路径可能如下所示：\n/1/search/auto/My+Documents?query=draft+2013 虽然对于简单的例子而言，使用 URL 编码似乎已经足够完美，但使用 JSON 可能也有一些优点。\n混乱的 URL 路径 在上面的例子中，因为第一个 + 就在 URL 之中，所以其就是字面意义上的加号。而第二个 + 表示一个空格，因为它位于 URL 查询部分。这两者很容易混淆，因为他们的编码规则在大多数情况下是相同的，而且就像 urlencode 一样，有时一些库提供的函数的名字又非常模棱两可。我们 SDK 的一个早期版本就因此有过一个 bug。\n另一个常见的错误就是误认为在路径部分 / 同其他普通字符一样。\n /hello-world 等价于 /hello%2Dworld /hello/world 不等价于 /hello%2Fworld  符号 / 是保留的分界符。将其改为使用 % 编码的形式会改变 URL 的含义。大多数 URL 编码库并没有非常清晰地对两者作出区分。虽然大多数情况下这不重要，但某些情况却非常关键。\nURL 查询参数表现力不足 假设 API 参数需要一组值时，该怎么处理呢？一些 API 可能使用逗号或重复的名字来处理。\n/docs/salary.csv?columns=1,2 /docs/salary.csv?column=1\u0026amp;column=2 对于嵌套的字段，一些 API 可能如下处理：\n/emails?from[name]=Don\u0026amp;from[date]=1998-03-24\u0026amp;to[name]=Norm 这些变通都是合理的，但他们仍然只是变通之举。并没有普遍的标准。但 JSON 可以一致、简单的处理嵌套。\n使用 URL 编码是否很糟糕呢？ 不，它只是为不同的情况设计的：人类交互使用。\nJSON 将一切字符串用引号包裹。这让许多事情变得更简单以及更健壮，但对于人们来说，读与写可能略显乏味单调。\n相较于 JSON，URL 参数可以更快的开始使用。在通常情况下，这非常不错。但缺点就是更容易造成混乱，因此任何处理 URL 参数的代码都会变得很复杂。\n这里要做一些合理的权衡。 我不会在我的浏览器地址栏使用 JSON，但对于基于 HTTP 的 API 来说，使用 JSON 来处理可能是一个更好的选择。\n所以问题在哪儿呢？ 当思考到这的时候，我们可以说对比于 URL 编码，使用 JSON 在某些方面更佳。对于结构化的数据，HTTP API 响应已经基本上都在使用 JSON 了。最近一次我处理 URL 编码的响应体是在 2007 年时使用 OAuth 1。目前 OAuth 2 已经使用 JSON 了。\nAPI 请求体分裂成了 JSON 和 URL 编码两种形式。URL 编码的一个好处是你可以很好的使用 curl 命令行工具做示例。但很多 API，包括丢丢盒新一些的 API，已经开始在请求体中使用 JSON。\n所以为什么不在 URL 中同样使用 JSON 呢？就像下面这样：\n URL encoded: /log?a=b\u0026amp;c=4 JSON in URL: /log?%7B%22a%22:%22b%22,%22c%22:4%7D  第一点，JSON 形式更长了。这可能会导致你的 URL 超出长度限制。\n同时，它看起来很丑，但这可以通过抽象来解决。例如，除非在 packet 层面上出现了错误，否则你也无需去处理原始网络 packet。同样的道理，除非你的 URL 出现错误，否则你无需去接触丑陋版本的 URL。一旦它通过了检测，你在错误消息或日志输出中看到的就只是解码过的字符串了。\n创建一个整理抽象层需要花费额外的工作，尤其过去从未使用过类似方式。虽然在 URL 中使用 JSON 前期会有一些烦恼，但它带来的好处值得让人一试。\n","permalink":"https://hiwangzi.com/posts/2018/05/14/json-in-urls/","summary":"除了在 URL 中使用路径作为参数或使用查询参数之外，是否还有更好的选择呢？","title":"译｜在 URLs 中使用 JSON"},{"content":"目录  问题 赞同最多的回答   原文地址：java - Difference between if (a - b \u0026lt; 0) and if (a \u0026lt; b) - Stack Overflow\n 问题 在阅读 Java 的 ArrayList 源代码时，我注意到在 if 语句中的一些比较语句。\n在 Java 7 之中，grow(int) 方法使用了如下代码：\nif (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; 在 Java 6 中，没有 grow 方法。但方法 ensureCapacity(int) 却使用如下方式比较数值：\nif (newCapacity \u0026lt; minCapacity) newCapacity = minCapacity; 变更比较语句写法的原因是什么呢？为了性能还是说只是代码风格的变化？\n我可以理解，与 0 作比较速度更快，但同时却需多执行一个减法，这不是额外的开销吗？同时对于编译后的字节码来说，做差比较需要涉及两个指令（ISUB 和 IF_ICMPGE），而直接比较只需要涉及 IFGE 一条指令。\n赞同最多的回答 a \u0026lt; b 与 a - b \u0026lt; 0 可以表示不同的含义。\n考虑如下场景：\nint a = Integer.MAX_VALUE; int b = Integer.MIN_VALUE; if (a \u0026lt; b) { System.out.println(\u0026#34;a \u0026lt; b\u0026#34;); } if (a - b \u0026lt; 0) { System.out.println(\u0026#34;a - b \u0026lt; 0\u0026#34;); } 执行结果是：只会打印 a - b \u0026lt; 0。因为 a \u0026lt; b 显然是 false，但 a - b 产生了溢出，结果是 -1，因此结果为 true。\n 译者注： int max = Integer.MAX_VALUE; // 2147483647 int min = Integer.MIN_VALUE; // -2147483648   说回问题本身，我们假设数组长度本身已经非常接近于 Integer.MAX_VALUE 来看一看。ArrayList 之中的代码如下：\n// 译者注：可以查看问题中的第一个链接 grow(int) 方法 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); oldCapacity 非常接近 Integer.MAX_VALUE，因此 newCapacity（即oldCapacity + 0.5 * oldCapacity）有可能产生溢出，假设溢出后值为 Integer.MIN_VALUE (负值)。然后，减去 minCapacity 又下溢变为正值（译者注：假设参数minCapacity为正值）。\n因此第一个 if 块中的代码将不会被执行。但假设代码条件写作 if (newCapacity \u0026lt; minCapacity)，结果将会是 true（因为 newCapacity 是负值），这将导致 newCapacity 被强行指定为 minCapacity 而没有考虑 minCapacity。\n这个溢出问题将会被下一个 if 语句所处理。当 newCapacity 溢出后，此 if 的结果为 true：MAX_ARRAY_SIZE 为 Integer.MAX_VALUE - 8，所以 Integer.MIN_VALUE - (Integer.MAX_VALUE - 8) \u0026gt; 0 为 true。因此 newCapacity 可以被正确的处理：hugeCapacity 方法将返回 MAX_ARRAY_SIZE 或 Integer.MAX_VALUE。\n注意：这就是对应 Java 代码中注释 // overflow-conscious 的含义。\n","permalink":"https://hiwangzi.com/posts/2018/05/08/difference-between-if-a-b-0-and-if-a-b/","summary":"一个针对此问题 Stack Overflow 上的回答。","title":"译｜if(a - b \u003c 0) 与 if(a \u003c b) 的区别"},{"content":"之前按照以 官方 Wiki 的方式安装 ArchLinux，并结合 官方文档，成功的在 VirtualBox 环境下安装好了 Arch。虚拟机限于内存、显卡等因素，体验不够好，因此今天准备在旧笔记本实机安装。在第一步联网过程中，就遇到了阻碍，特此记录。\n查看网卡类型 在之前的虚拟机环境下，采用 NAT 模式联网，网卡自动识别并加载，只需要执行 dhcpcd 获取 IP 后即可成功连接互联网。但这次，系统并不能自动驱动硬件工作，所以我们需要先检查一下网卡类型。\n 执行 lspci -k 查看 Network controller 这一项。  02:00.0 Network controller: Broadcom Limited BCM43228 802.11a/b/g/n Subsystem: Foxconn International, Inc. BCM43228 802.11a/b/g/n Kernel driver in use: bcma-pci-bridge Kernel moudles: bcma   检查 ip link 输出结果中有没有 wlan0 或 wlps21 一类的设备。如果有的话，只需要执行 ip link set \u0026lt;设备名\u0026gt; up 即可，无需再额外安装驱动程序。\n  如果没有，即需要检查内核的固件信息 dmesg | grep firmware，得到更多提示\n  b43-phy0 ERROR: You must go to http://wireless.kernel.or/en/users/Drivers/b43#devicefirmware and download the correct firmware for this driver version.  如果没有这样的信息，可以先尝试执行 iwlwifi 一类命令，然后查找对应的错误信息 dmesg | grep iwlwifi 获得提示信息后，例如上面的网站，可以访问得到进一步的信息。此处根据上述 ERROR 中的网站给出的指导，执行 lspci -nn -d 14e4: 获得详细的硬件型号，并下载对应的驱动。关于博通无线网卡，可以查阅 Wiki 页面 获得更多信息  下载并安装驱动   没网络怎么下载 ❓ 可以下载至安装U盘的根目录，安装时切换至 /run/archiso/bootmnt，即可看到下载的内容，将其拷贝至 /root 解压。\n  如何来安装驱动 ❓ 更多参考 在上一步解压完成后，会得到一个 .o 结尾的问题，执行 b43-fwcutter -w /lib/firmware xxx.o 即可完成安装。\n  安装后怎么启动 ❓ 更多参考 卸载之前的驱动，然后再加载新安装的驱动。\n 卸载旧驱动（如果你知道你正在使用的驱动名称的话，只需执行对应的命令即可） modprobe -r b43 bcma modprobe -r brcmsmac bcma modprobe -r wl  加载新驱动（只需执行对应的驱动命令即可） modprobe b43 modprobe brcmsmac modprobe wl     安装完成后可以通过 ip link 查看是否有新增加的网络接口信息。\n  安装完成后的联网过程  此部分内容主要参考了 在命令行中管理 Wifi 连接\n   通过 ip link set \u0026lt;设备名\u0026gt; up 启动接口服务。\n  可以通过 iw dev \u0026lt;设备名\u0026gt; scan | less 扫描附近网络。\n  联网（方式 1）无加密网络\niw dev \u0026lt;设备名\u0026gt; connect \u0026lt;网络 SSID\u0026gt;   联网（方式 2）WEP 加密\niw dev \u0026lt;设备名\u0026gt; connect \u0026lt;网络 SSID\u0026gt; key 0:\u0026lt;WEP密钥\u0026gt;   联网（方式 3）WPA/WPA2 加密（现在最常见）\nnetwork={ ssid=\u0026#34;\u0026lt;网络 SSID\u0026gt;\u0026#34; psk=\u0026#34;\u0026lt;密码\u0026gt;\u0026#34; priority=1 }  vim /etc/wpasupplicant/wpa_supplicant.conf 编辑文件（其实放在别的位置也行），增加以上内容（注意包含引号） wpa_supplicant -i \u0026lt;设备名\u0026gt; -c /etc/wpa_supplicant/wpa_supplicant.conf \u0026amp; 后台启动网络连接    获取 IP：dhcpcd \u0026lt;设备名\u0026gt; 自动获取 IP 地址\n  测试网络：ping hiwangzi.com 测试网络连接是否正常~\n  ","permalink":"https://hiwangzi.com/posts/2018/03/25/arch-install-with-bcm/","summary":"之前按照《以官方 Wiki 的方式安装 ArchLinux》，并结合官方文档，成功的在 VirtualBox 环境下安装好了 Arch。虚拟机限于内存、显卡等因素，体验不够好，因此今天准备在旧笔记本实机安装。在第一步联网过程中，就遇到了阻碍，特此记录。","title":"安装 Arch 中遇到的 Broadcom b43(BCM43228) 网卡问题"},{"content":"「字符集」与「字符集编码」  charset: character set encoding: charset encoding  字符的编号（code）在Unicode中：码点（code point）  Unicode provides a unique number for every character. 目前码点的范围 U+0000~U+10FFFF（Unicode 官方表示以后不再扩充） 代码单元（code unit）：指一种转换格式（UTF）中最小的一个分隔。  UTF-8：一字节为一个单元，UTF-8可以包含一个单元、二个单元、三个单元及四个单元 UTF-16：两字节为一个单元，UTF-16可以包含一个单元、二个单元 UTF-32：四字节为一个单元，UTF-32只包含一个单元这一种即可    三种编码方案  UTF-8：变长，1-4 字节； UTF-16：变长，2 或 4 字节； UTF-32：定长，4 字节。  UTF-16 为何变长了  UTF-16 的前身 UCS-2 是 16 位定长的编码，它与码点在形式上完全一样 但后来字符扩充，目前的码点数 17 × 65536 ≈ 111 万，而 16 位定长最多 65536 个字符  变长（Variable-length）的编码方案  利用高位作区分 利用代理区作区分  Unicode 的平面   Unicode 共有码点数 17 × 65536，为了便于管理，每 65536 个码点划分为一个平面。\n  BMP（Basic Multilingual Plane 基本多语言平面），也叫 Plane 0，日常用到的字符绝大多数都落在此平面。（UTF-16只需要两字节编码此平面字符）\n  SP（Supplementary Planes 增补平面），码点值超过了 U+FFFF。（UTF-16需要四字节编码这些字符）\n  Unicode 与 UTF 转换  UTF 即是 Unicode 转换格式（Unicode (or UCS) Transformation Format）。  UTF-32  直接对码点补0，补够32位即可。 简单但占空间太大。  UTF-8   可以有 1，2，3，4 四种字节组合。\n  采用的即是「高位保留」的方式区分不同变长。\n  转换举例\n  如果看到一串的 16 进制有如下的形式：EX XX XX EX XX XX…每三个三个字节前面都是 E 打头，那么它很可能就是一串汉字的 UTF-8 编码了。\n  UTF-16  UTF-16 是一种变长的 2 或 4 字节编码模式。 BMP 内的字符使用 2 字节编码，其它平面使用 4 字节组成代理对来编码。 其采用的便是「代理区」形式区分不同变长。 BMP 内的代理区  高代理区（D800-DBFF） 低代理区（DC00-DFFF）    BOM   BOM = Byte Order Mark\n   Encoding Representation (hexadecimal)     UTF-8 EF BB BF   UTF-16 (BE) FE FF   UTF-16 (LE) FF FE   UTF-32 (BE) 00 00 FE FF   UTF-32 (LE) FF FE 00 00      BOM 其实就是 U+FEFF (zero-width non-breaking space)这个码点，EF BB BF是该码点在 UTF-8 下的编码。\n  该码点用作 BOM 后，Unicode 不再建议解释为“零宽度非换行空格”。\n  UTF-16 和 UTF-32 的处理单元分别是 2 个字节和 4 个字节，在 C 语言中的定义就决定了这两个超过 8 位的整数需要考虑存储和网络传输的字节序。而 UTF-8 的编码是以 1 个字节为单位处理的，需要考虑下一位时就地址 +1，不会受 CPU 大小端的影响。（参考：为什么 UTF-8 不存在字节序的问题？ - 孙笑凡的回答 - 知乎）\n  参考资料  字符集与编码（一）——charset vs encoding 字符集与编码（二）——编号 vs 编码 字符集与编码（三）——定长与变长 字符集与编码（四）——Unicode 字符集与编码（五）——代码单元及 length 方法 字符集与编码（七）——BOM  ","permalink":"https://hiwangzi.com/posts/2018/03/11/unicode-notes/","summary":"自己关于 Unicode 的笔记整理，主要总结自「肖国栋的i自留地」系列博客","title":"Unicode 笔记"},{"content":"关于内核  当计算机启动时，计算机要经历一系列动作，这些动作构成了引导过程。引导过程的最后一个动作是启动一个非常复杂的程序，该程序就被称为内核（Kernel）。 内核的作用是控制计算机，提供基础服务，是操作系统的核心。 内核有许多种类型，但基本可以分为两大类：  单内核：一个庞大的程序自身可以完成所有的事 微内核：一个非常小的程序只执行最基本的任务，其余通过调用其他程序（称为服务器(server)）实现   内核的使用：  大多数 Unix 系统使用的是某种类型的单内核，一些 Unix （例如 OS X，Minix）使用微内核。 Linux 是单内核。 补：Linus 阅读了 Andrew Tanenbaum 的《Operating System: Design and Implementation》，该书解释了 Minix 的设计原则。Linus 选择使用单内核设计 Linux，而 Andrew Tanenbaum 设计的 Minix 使用的是微内核。在 Linux 开始引起注意后不久，Tanenbaum 公开批判这种设计决策。直到今天，Tanenbaum 仍然在批评这种单内核设计。    关于 Unix  Unix = Unix 内核 + Unix 实用工具 Unix 过去是属于 AT\u0026amp;T 的商标（必须为大写 UNIX，以下的全大写均指 AT\u0026amp;T 公司的 Unix） 现在可以理解为指代任何 “类Unix” 系统 关于 “类Unix” 的两种理解：  如果操作系统既包含一个 Unix 内核以及一些 Unix 实用工具，又可以运行能够在其他 Unix 操作系统上运行的程序，那么它就是 Unix 系统 如果理解 Unix 的人说这个系统是 Unix，那么它就是 Unix    Unix 的历史   20世纪70年代的 Unix：由贝尔实验室转向 Berkeley\n 1974年，Berkeley 的 Bob Fabry 教授获得了一份 UNIX 副本，该校的学生们开始增强该系统。 1977年，Bill Joy 装配了第一版的 Berkeley Unix，被称为 BSD(Berkeley Software Distribution) 1979年，AT\u0026amp;T 公司宣布将 UNIX 作为一个商品销售（UNIX System III(\u0026ldquo;Three\u0026rdquo;), UNIX System V(\u0026ldquo;Five\u0026rdquo;)） 1979年，所有的 BSD 用户都被要求购买一个 AT\u0026amp;T 公司的许可证，并且之后每年都在提高许可证的价格。因此，BSD 程序员越来越难以忍受 AT\u0026amp;T 公司的束缚。    20世纪80年代的 Unix：BSD 与 System V\n 截止至1980年，美国东海岸 Unix（AT\u0026amp;T 的 UNIX）和西海岸的 Unix（BSD）平分秋色，都发展很快。 此时的 UNIX：AT\u0026amp;T 目标是使 UNIX 成为一个成功的商业产品，只面向能够为许可证付大量金钱的公司。1982年，发行了 UNIX System III。1983年，发行了 System V，到年末，System V 安装了 45,000 份。1984年，System V Release 2(SVR2) 发行时，大约安装了 100,000 份。 此时的 BSD：1980年，Berkeley 的 Bob Fabry 教授接到美国国防部高级研究计划局（DARPA，补：1972年前，该机构名为 ARPA，Internet的祖先 Arpanet 也由该机构创造）的一个大合同。Fabry 随后建立了 CSRG(Computer System Research Group) ，该小组一直延续到 1994 年，且在这段时间，对 BSD 和 Unix 在全球的发展产生了重要影响。随后该小组发布的 Unix 版本都受到了学术界与研究社区的高度关注。1982年，4.1BSD支持TCP/IP，成为 Internet 的基础。1983年，4.2BSD发布，全球已有1000份安装。 到 1985 年，Unix 流派就是以上两类。其他形式的 Unix 也都派生自以上两类。 在20世纪80年代末，Unix世界的两大特征：Unix 总体的快速增长和不同类型 Unix 的增殖扩散。    AT\u0026amp;T 公司的限制\n 1979年，AT\u0026amp;T不允许其公司之外的人查看 UNIX 的源代码 1984年之一：x86 架构的 Minix 操作系统开始编写并于两年后诞生 1984年之二：GNU 计划与 FSF(Free Software Foundation) 基金会的成立 1991年：芬兰大学生 Linux Torvalds 发布了一则简讯，Linux 世界自此开始，随后发展出了数百个发行版 1992年：Bill Jolitz 替换了最后的 6 个 AT\u0026amp;T 公司的内核文件，发行了一个完全与 AT\u0026amp;T 无关的 Unix：386/BSD。后来更名为 FreeBSD。后来衍生出了 NetBSD(可移植到许多种类的计算机)，OpenBSD(关注安全与密码学)。    为何 Linux 成为了更加流行的 Unix？  Linux 是基于 GNU GPL 许可发行的，而 GPL 禁止任何人使用 Linux 创建及发行专有系统。而 BSD 许可证远没有 GPL 严格，在 BSD 许可证之下，允许使用部分 BSD 创建新产品而不共享新产品，因此这种情况下，其他人无法从新产品获得好处，也无法使用与修改新产品（但也因为 BSD 许可证的灵活，所以应用也非常广泛）。 Linux 比 FreeBSD 更成功的关键在于发行时机，Linux Torvalds 在 1991 年发行了 Linux 内核，而完全开放源代码的 386/BSD 直到 1992 年才发行。  ","permalink":"https://hiwangzi.com/posts/2018/02/03/what-is-unix/","summary":"关于内核  当计算机启动时，计算机要经历一系列动作，这些动作构成了引导过程。引导过程的最后一个动作是启动一个非常复杂的程序，该程序就被称为内核（Kernel）。 内核的作用是控制计算机，提供基础服务，是操作系统的核心。 内核有许多种类型，但基本可以分为两大类：  单内核：一个庞大的程序自身可以完成所有的事 微内核：一个非常小的程序只执行最基本的任务，其余通过调用其他程序（称为服务器(server)）实现   内核的使用：  大多数 Unix 系统使用的是某种类型的单内核，一些 Unix （例如 OS X，Minix）使用微内核。 Linux 是单内核。 补：Linus 阅读了 Andrew Tanenbaum 的《Operating System: Design and Implementation》，该书解释了 Minix 的设计原则。Linus 选择使用单内核设计 Linux，而 Andrew Tanenbaum 设计的 Minix 使用的是微内核。在 Linux 开始引起注意后不久，Tanenbaum 公开批判这种设计决策。直到今天，Tanenbaum 仍然在批评这种单内核设计。    关于 Unix  Unix = Unix 内核 + Unix 实用工具 Unix 过去是属于 AT\u0026amp;T 的商标（必须为大写 UNIX，以下的全大写均指 AT\u0026amp;T 公司的 Unix） 现在可以理解为指代任何 “类Unix” 系统 关于 “类Unix” 的两种理解：  如果操作系统既包含一个 Unix 内核以及一些 Unix 实用工具，又可以运行能够在其他 Unix 操作系统上运行的程序，那么它就是 Unix 系统 如果理解 Unix 的人说这个系统是 Unix，那么它就是 Unix    Unix 的历史   20世纪70年代的 Unix：由贝尔实验室转向 Berkeley","title":"什么是 Unix"},{"content":" 跳转最后一行 :$ 或 shift+g 跳转第一行 :1 或 gg 设置自动换行 :set wrap 设置不自动换行 :set nowrap  ","permalink":"https://hiwangzi.com/posts/2017/12/07/vim-newbie-note/","summary":" 跳转最后一行 :$ 或 shift+g 跳转第一行 :1 或 gg 设置自动换行 :set wrap 设置不自动换行 :set nowrap  ","title":"vim 常用操作笔记"},{"content":"Web 基础 三项构建技术：\n HTML：页面的文本标记语言 HTTP：文档传输协议 URL：指定文档所在地址  一些概念   HTTP（HyperText Transfer Protocol）：通常被译为“超文本传输协议”，但严谨应译为“超文本转移协议”\n 传输（transport）：从端到端可靠地搬运比特，属于 TCP/IP 中传输层（transport layer）协议处理的事 转移（transfer）：在客户端-服务器之间转移一些带有操作语义的原语，来执行某些操作，属于TCP/IP中应用层的事务。    HTTP 版本\n HTTP/0.9：并没有作为正式标准被建立 HTTP/1.0：公布于 1996 年 5 月，记录于 RFC1945 HTTP/1.1：公布于 1997 年 1 月，最初标准为 RFC 2068，后来发布修订版 RFC2616，目前主流被使用的版本 HTTP/2.0    TCP/IP 协议族\n         应用层 （FTP、DNS、HTTP\u0026hellip;）   传输层 用于提供处于网络连接中的两台计算机之间的数据传输（TCP、UDP）   网络层 用来处理在网络上流动的数据包（IP）   数据链路层 用来处理连接网络的硬件部分      HTTP over TCP/IP 通信传输图解：\n  各种协议与 HTTP 协议的关系：\n  URI 和 URL\n URI：Uniform Resource Identifier URL：Uniform Resource Locator URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）所以说，URL 是 URI 的子集。    URI 的举例分析\n  ","permalink":"https://hiwangzi.com/posts/2017/12/03/http-note-web/","summary":"Web 基础 三项构建技术：\n HTML：页面的文本标记语言 HTTP：文档传输协议 URL：指定文档所在地址  一些概念   HTTP（HyperText Transfer Protocol）：通常被译为“超文本传输协议”，但严谨应译为“超文本转移协议”\n 传输（transport）：从端到端可靠地搬运比特，属于 TCP/IP 中传输层（transport layer）协议处理的事 转移（transfer）：在客户端-服务器之间转移一些带有操作语义的原语，来执行某些操作，属于TCP/IP中应用层的事务。    HTTP 版本\n HTTP/0.9：并没有作为正式标准被建立 HTTP/1.0：公布于 1996 年 5 月，记录于 RFC1945 HTTP/1.1：公布于 1997 年 1 月，最初标准为 RFC 2068，后来发布修订版 RFC2616，目前主流被使用的版本 HTTP/2.0    TCP/IP 协议族\n         应用层 （FTP、DNS、HTTP\u0026hellip;）   传输层 用于提供处于网络连接中的两台计算机之间的数据传输（TCP、UDP）   网络层 用来处理在网络上流动的数据包（IP）   数据链路层 用来处理连接网络的硬件部分      HTTP over TCP/IP 通信传输图解：","title":"《图解HTTP》笔记——Web 基础"},{"content":"例如：当表中不存在某记录时，才插入这条记录。\nINSERT INTO 表名(列名1, 列名2) SELECT \u0026#39;值1\u0026#39;, \u0026#39;值2\u0026#39; WHERE NOT EXISTS ( SELECT * FROM 表名 WHERE 列名1 = \u0026#39;值1\u0026#39;, 列名2 = \u0026#39;值2\u0026#39; ); 参考   PostgreSQL: Documentation: 10: INSERT\n This example inserts some rows into table films from a table tmp_films with the same column layout as films:\nINSERT INTO films SELECT * FROM tmp_films WHERE date_prod \u0026lt; '2004-05-07';     database - Conditional INSERT INTO statement in postgres - Stack Overflow\n  ","permalink":"https://hiwangzi.com/posts/2017/11/23/conditional-insert-into-statement-in-postgres/","summary":"例如：当表中不存在某记录时，才插入这条记录。\nINSERT INTO 表名(列名1, 列名2) SELECT \u0026#39;值1\u0026#39;, \u0026#39;值2\u0026#39; WHERE NOT EXISTS ( SELECT * FROM 表名 WHERE 列名1 = \u0026#39;值1\u0026#39;, 列名2 = \u0026#39;值2\u0026#39; ); 参考   PostgreSQL: Documentation: 10: INSERT\n This example inserts some rows into table films from a table tmp_films with the same column layout as films:\nINSERT INTO films SELECT * FROM tmp_films WHERE date_prod \u0026lt; '2004-05-07';     database - Conditional INSERT INTO statement in postgres - Stack Overflow","title":"PostgreSQL 满足条件时插入数据"},{"content":"   编号 命令 描述     1 DEL key 此命令删除一个指定键(如果存在)。   2 DUMP key 此命令返回存储在指定键的值的序列化版本。   3 EXISTS key 此命令检查键是否存在。   4 EXPIRE key seconds 设置键在指定时间秒数之后到期/过期。   5 EXPIREAT key timestamp 设置在指定时间戳之后键到期/过期。这里的时间是Unix时间戳格式。   6 PEXPIRE key milliseconds 设置键的到期时间(以毫秒为单位)。   7 PEXPIREAT key milliseconds-timestamp 以Unix时间戳形式来设置键的到期时间(以毫秒为单位)。   8 KEYS pattern 查找与指定模式匹配的所有键。   9 MOVE key db 将键移动到另一个数据库。   10 PERSIST key 删除指定键的过期时间，得永生。   11 PTTL key 获取键的剩余到期时间(以毫秒为单位)。   12 RANDOMKEY 从Redis返回一个随机的键。   13 RENAME key newkey 更改键的名称。   14 RENAMENX key newkey 如果新键不存在，重命名键。   15 TYPE key 返回存储在键中的值的数据类型。    ","permalink":"https://hiwangzi.com/posts/2017/11/21/redis-command/","summary":"   编号 命令 描述     1 DEL key 此命令删除一个指定键(如果存在)。   2 DUMP key 此命令返回存储在指定键的值的序列化版本。   3 EXISTS key 此命令检查键是否存在。   4 EXPIRE key seconds 设置键在指定时间秒数之后到期/过期。   5 EXPIREAT key timestamp 设置在指定时间戳之后键到期/过期。这里的时间是Unix时间戳格式。   6 PEXPIRE key milliseconds 设置键的到期时间(以毫秒为单位)。   7 PEXPIREAT key milliseconds-timestamp 以Unix时间戳形式来设置键的到期时间(以毫秒为单位)。   8 KEYS pattern 查找与指定模式匹配的所有键。   9 MOVE key db 将键移动到另一个数据库。   10 PERSIST key 删除指定键的过期时间，得永生。   11 PTTL key 获取键的剩余到期时间(以毫秒为单位)。   12 RANDOMKEY 从Redis返回一个随机的键。   13 RENAME key newkey 更改键的名称。   14 RENAMENX key newkey 如果新键不存在，重命名键。   15 TYPE key 返回存储在键中的值的数据类型。    ","title":"【Redis 笔记】常用命令"},{"content":"REmote DIctionary Server(Redis)，一个 key-value 存储系统。\n数据类型 Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\n  string\n string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，一个键最大能存储 512MB。 相关命令：set, get 127.0.0.1:6379\u0026gt; set str1 hello OK 127.0.0.1:6379\u0026gt; get str1 \u0026#34;hello\u0026#34;     hash\n hash 是键值对的集合。 每个 hash 可以存储 2^32 - 1 个（超过 40 亿个）键值对。 相关命令：hmset, hmget, hgetall 127.0.0.1:6379\u0026gt; hmset hashmap1 name hiwangzi blog hiwangzi.com OK 127.0.0.1:6379\u0026gt; hmget hashmap1 name 1) \u0026#34;hiwangzi\u0026#34; 127.0.0.1:6379\u0026gt; hgetall hashmap1 1) \u0026#34;name\u0026#34; 2) \u0026#34;hiwangzi\u0026#34; 3) \u0026#34;blog\u0026#34; 4) \u0026#34;hiwangzi.com\u0026#34;     list\n list 是字符串列表，按插入顺序排序。 列表的最大长度为 2^32 - 1 个元素。 相关命令：lpush, lrange 127.0.0.1:6379\u0026gt; lpush list1 a b (integer) 2 127.0.0.1:6379\u0026gt; lrange list1 0 100 1) \u0026#34;b\u0026#34; 2) \u0026#34;a\u0026#34; 127.0.0.1:6379\u0026gt; lpush list1 c (integer) 3 127.0.0.1:6379\u0026gt; lrange list1 0 2 1) \u0026#34;c\u0026#34; 2) \u0026#34;b\u0026#34; 3) \u0026#34;a\u0026#34;     set\n set 是字符串的无序集合。 添加，删除和验证成员是否存在的时间O(1)复杂性。 set 的最大成员数量为 2^32 - 1 个元素。 相关命令：sadd, smembers 127.0.0.1:6379\u0026gt; sadd set1 a b (integer) 2 127.0.0.1:6379\u0026gt; smembers set1 1) \u0026#34;b\u0026#34; 2) \u0026#34;a\u0026#34; 127.0.0.1:6379\u0026gt; sadd set1 c (integer) 1 127.0.0.1:6379\u0026gt; smembers set1 1) \u0026#34;b\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;a\u0026#34; 127.0.0.1:6379\u0026gt; sadd set1 a (integer) 0 127.0.0.1:6379\u0026gt; smembers set1 1) \u0026#34;b\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;a\u0026#34; # a 被添加了两次，但集合有唯一属性，所以只会存储一个。     zset\n zset = sorted set Redis可排序集合类似于Redis集合，是不重复的字符集合。 不同之处在于，排序集合的每个成员都与分数相关联，这个分数用于按最小分数到最大分数来排序的排序集合。虽然成员是唯一的，但分数值可以重复。 相关命令：zadd, zrange, zrangebyscore 127.0.0.1:6379\u0026gt; zadd zset_test 0 redis (integer) 1 127.0.0.1:6379\u0026gt; zadd zset_test 0 mongodb (integer) 1 127.0.0.1:6379\u0026gt; zadd zset_test 1 sqllite (integer) 1 127.0.0.1:6379\u0026gt; zadd zset_test 1 sqllite (integer) 0 127.0.0.1:6379\u0026gt; zrange zset_test 0 1000 1) \u0026#34;mongodb\u0026#34; 2) \u0026#34;redis\u0026#34; 3) \u0026#34;sqllite\u0026#34; 127.0.0.1:6379\u0026gt; zrangebyscore zset_test 0 1000 1) \u0026#34;mongodb\u0026#34; 2) \u0026#34;redis\u0026#34; 3) \u0026#34;sqllite\u0026#34;     参考  Redis数据类型 - Redis教程  ","permalink":"https://hiwangzi.com/posts/2017/11/21/redis-data-type/","summary":"REmote DIctionary Server(Redis)，一个 key-value 存储系统。\n数据类型 Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\n  string\n string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，一个键最大能存储 512MB。 相关命令：set, get 127.0.0.1:6379\u0026gt; set str1 hello OK 127.0.0.1:6379\u0026gt; get str1 \u0026#34;hello\u0026#34;     hash\n hash 是键值对的集合。 每个 hash 可以存储 2^32 - 1 个（超过 40 亿个）键值对。 相关命令：hmset, hmget, hgetall 127.0.0.1:6379\u0026gt; hmset hashmap1 name hiwangzi blog hiwangzi.com OK 127.0.0.1:6379\u0026gt; hmget hashmap1 name 1) \u0026#34;hiwangzi\u0026#34; 127.","title":"【Redis 笔记】数据类型"},{"content":"基础 # -n 可以去掉换行符 echo -n \u0026#39;777777\u0026#39; RSA算法   加密\n# 利用管道命令传递字符串加密 echo -n \u0026#39;777777\u0026#39; | openssl rsautl -encrypt -pubin -inkey public_key.pem \u0026gt; message.encrypted # （或）利用文件传递字符串加密 echo -n \u0026#39;777777\u0026#39; \u0026gt; message.txt openssl rsautl -encrypt -pubin -inkey public_key.pem -in message.txt \u0026gt; message.encrypted   解密\nopenssl rsautl -decrypt -inkey private_key.pem -in message.encrypted -out message.decrypted   Base64   编码\nopenssl enc -base64 -e -in message.txt \u0026gt; message.base64e   解码\nopenssl enc -base64 -d -in message.base64 \u0026gt; message.base64d   Hash   MD5\necho -n \u0026#39;777777\u0026#39; | md5sum   ","permalink":"https://hiwangzi.com/posts/2017/11/20/calculate-rsa-base64-hash-in-terminal/","summary":"OpenSSL 是个好工具 👍","title":"命令行计算 RSA, Base64, Hash"},{"content":" 抑制偏见，拥抱世界。\n\u0026mdash; Zi WANG (@zill057) October 29, 2017  有了记录之后，仍然会觉得，时间眨眼飞逝。\n去年的今天，写下了 我的十月 这篇博文，再读来，真的觉得当时的自己的生活还算称得上有趣啦。也许就如花花所说，我一直在粉饰自己过去的时光，所以才总是会觉得现在的自己真是大不如从前。\n人虽然总是在变化，可变化有时却没那么快。或许未来的自己会觉得今天的我也并非充足的努力，可此刻的我还是愿意鼓励自我的现状。或许没有去年的十月那么多值得记录的事情，但我知道，自己在踏实的前进。\n没有什么更多的事说了，如此\u0026hellip;\n","permalink":"https://hiwangzi.com/posts/2017/10/31/so/","summary":"抑制偏见，拥抱世界。\n\u0026mdash; Zi WANG (@zill057) October 29, 2017  有了记录之后，仍然会觉得，时间眨眼飞逝。\n去年的今天，写下了 我的十月 这篇博文，再读来，真的觉得当时的自己的生活还算称得上有趣啦。也许就如花花所说，我一直在粉饰自己过去的时光，所以才总是会觉得现在的自己真是大不如从前。\n人虽然总是在变化，可变化有时却没那么快。或许未来的自己会觉得今天的我也并非充足的努力，可此刻的我还是愿意鼓励自我的现状。或许没有去年的十月那么多值得记录的事情，但我知道，自己在踏实的前进。\n没有什么更多的事说了，如此\u0026hellip;","title":"如此"},{"content":"MEAN: MongoDB - Express - AngularJs - Node.js\n MongoDB 是一个面向文档的、 NoSQL 类型的数据库。MongoDB 颠覆了传统的基于表的数据存储方式，而采取了类似 JSON 的文档结构来存储数据，因而它在存储数据时可以更加灵活。 Express 是一个 Node.js 框架，可以创建灵活的 Web 服务，比如单页面应用程序、多页面应用程序和混合型 App。 AngularJS 是一个开源的 JavaScript 框架，由 Google 和开源社区共同维护，它用来创建单页面应用程序。它的目标是使用 model-view-controller 模式来规范 Web 应用程序，让开发和测试富交互的单页面应用程序变得更加轻松。 Node.js 是一个运行在服务器端的 JavaScript 运行环境，它的底层是基于 Chrome 的 JavaScript 运行环境——V8 引擎。Node.js 可以作为服务器端语言，用来创建快速、可扩展的应用程序。Node.js 也可以在本机运行，做一些本地操作，比如加速本地开发流程，或者实现一键发布。  MEAN 可以说是传统的 LAMP 方案的有力竞争者。因为从服务器端到页面端都采用同样的语言（JavaScript）和同样的架构模式（MVC），所以一个擅长 JavaScript 的工程师可以兼顾前后端的开发，并且前端代码和后台代码是可以复用的。\n","permalink":"https://hiwangzi.com/posts/2017/10/25/mean/","summary":"MEAN: MongoDB - Express - AngularJs - Node.js\n MongoDB 是一个面向文档的、 NoSQL 类型的数据库。MongoDB 颠覆了传统的基于表的数据存储方式，而采取了类似 JSON 的文档结构来存储数据，因而它在存储数据时可以更加灵活。 Express 是一个 Node.js 框架，可以创建灵活的 Web 服务，比如单页面应用程序、多页面应用程序和混合型 App。 AngularJS 是一个开源的 JavaScript 框架，由 Google 和开源社区共同维护，它用来创建单页面应用程序。它的目标是使用 model-view-controller 模式来规范 Web 应用程序，让开发和测试富交互的单页面应用程序变得更加轻松。 Node.js 是一个运行在服务器端的 JavaScript 运行环境，它的底层是基于 Chrome 的 JavaScript 运行环境——V8 引擎。Node.js 可以作为服务器端语言，用来创建快速、可扩展的应用程序。Node.js 也可以在本机运行，做一些本地操作，比如加速本地开发流程，或者实现一键发布。  MEAN 可以说是传统的 LAMP 方案的有力竞争者。因为从服务器端到页面端都采用同样的语言（JavaScript）和同样的架构模式（MVC），所以一个擅长 JavaScript 的工程师可以兼顾前后端的开发，并且前端代码和后台代码是可以复用的。","title":"全栈框架——MEAN"},{"content":"如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：买服务器，安装服务器软件，编写网站程序。\n现在你追随潮流，采用流行的云计算，如果你采用 IaaS 服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件\n而如果你采用 PaaS 的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序\n如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为 SaaS 。\n作者：John Wang 链接：https://www.zhihu.com/question/20387284/answer/28514161 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","permalink":"https://hiwangzi.com/posts/2017/10/25/iaas-paas-saas/","summary":"如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：买服务器，安装服务器软件，编写网站程序。\n现在你追随潮流，采用流行的云计算，如果你采用 IaaS 服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件\n而如果你采用 PaaS 的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序\n如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为 SaaS 。\n作者：John Wang 链接：https://www.zhihu.com/question/20387284/answer/28514161 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","title":"(转载) IaaS, PaaS, Saas"},{"content":" 反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。 能够分析类能力的程序称为反射(reflective)，其可以：  在运行中分析类 在运行中查看对象 编写泛型数组代码 调用任意方法   java.lang.Class 类用于描述 JVM 中使用的类。 不要过多地使用反射，其不适合编写应用程序。反射是很脆弱的，编译器很难帮助人们发现程序中的错误，因此很有可能会导致运行时出现异常。  在运行中分析类  获取Class对象的三种方式（JVM为每个类型管理一个 Class 对象）： // 1. 通过实例对象获取 Random random = new Random(); Class cl = random.getClass(); System.out.println(cl.getName()); // 输出为 java.util.Random  // 2. 通过静态方法 forName 获得类名对应的 Class 对象 Class cl = Class.forName(\u0026#34;java.util.Random\u0026#34;); // 3. 通过`类.class`获取（例如cl2，基本类型也可以） Class cl1 = Random.class; Class cl2 = int.class; Class cl3 = Double[].class; // 历史原因，getName 方法有时会返回一个奇怪的名字 Double[].class.getName(); // 返回结果为 \u0026#34;[Ljava.lang.Double;\u0026#34; int[].class.getName(); // 返回结果为 \u0026#34;[I\u0026#34;  java.lang.reflect中三个重要的类Field、Method、Constructor分别用于描述类的域、方法、构造器。 Class类对象的  getFields、getMethods、getConstructors方法将分别返回类提供的public 域、方法和构造器数组（包含超类的公有成员） getDeclaredFields、getDeclaredMethods、getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器数组（但不包含超类的成员）。   可以通过 newInstance 方法动态地创建一个类的实例 e.getClass().newInstance(); // 调用默认的无参构造器  如果没有无参构造，则会抛出异常; 而对于基本类型来说，例如：int.class.newInstance() 会抛出 InstantiationException 异常 如果希望提供参数，则应使用 Constructor 类中的 newInstance 方法。    在运行中分析对象  在获取Field对象后，通过其get方法，可以得到某个对象该字段的值。 直接访问私有域，get方法会抛出IllegalAccessException异常。但如果一个Java程序没有受到安全管理器的控制，就可以通过Field对象的setAccessible方法覆盖访问控制（Method、Constructor同理）。 通过get方法得到的是Object。如果字段为基本类型，会将其打包为包装类型，并以Object形式返回。 通过set方法可以修改字段的值。 在编写程序时，如果知道想要查看的对象的域名称，查看指定的域是一个很容易的事，而利用反射机制可以查看在编译时还不清楚的对象域。 Employee tank = new Employee(\u0026#34;man\u0026#34;, 35000, 6, 4, 1989); Class cl = tank.getClass(); Field f = cl.getDeclaredField(\u0026#34;name\u0026#34;); f.setAccessible(true); // 使得可以访问私有域 Object obj = f.get(tank); // 结果为\u0026#34;man\u0026#34; f.set(tank, \u0026#34;hero\u0026#34;); // 修改域 Object obj = f.get(tank); // 结果为\u0026#34;hero\u0026#34;   编写泛型数组代码 例子目标：实现一个通用的数组拷贝方法 public static void main(String[] args) { int[] a = {1, 2, 3}; a = (int[]) goodCopyOf(a, 10); System.out.println(Arrays.toString(a)); String[] b = {\u0026#34;Andy\u0026#34;, \u0026#34;Haley\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;Jerry\u0026#34;}; b = (String[]) goodCopyOf(b, 10); System.out.println(Arrays.toString(b)); b = (String[]) badCopyOf(b, 10); // 将抛出异常，原因如下 } 限制下的 badCopyOf  将一个对象数组（String[]）临时地转换成 Object[] 数组， 然后再把它转换回来是可以的。 但最开始就是 Object[] 的数组却永远不能转换成对象数组。 不过可以通过进行单个元素的转换，循环处理得到目标类型数组。 import java.util.Arrays; String[] strArray = {\u0026#34;Tom\u0026#34;, \u0026#34;Jerry\u0026#34;}; Object[] objArray = (Object[]) strArray; Arrays.toString(objArray); // ✅ \u0026#34;[Tom, Jerry]\u0026#34; Arrays.toString((String[]) objArray); // ✅ \u0026#34;[Tom, Jerry]\u0026#34;  Object[] objArrayCopy = new Object[2]; System.arraycopy(strArray, 0, objArrayCopy, 0, strArray.length); Arrays.toString(objArrayCopy); // ✅ \u0026#34;[Tom, Jerry]\u0026#34; Arrays.toString((String[]) objArrayCopy); // ❌ java.lang.ClassCastException: class [Ljava.lang.Object; cannot be cast to class [Ljava.lang.String; ([Ljava.lang.Object; and [Ljava.lang.String; are in module java.base of loader \u0026#39;bootstrap\u0026#39;)  String[] strArrayCopy = new String[2]; for (int i = 0; i \u0026lt; objArrayCopy.length; i++) { strArrayCopy[i] = (String) objArrayCopy[i]; } Arrays.toString(strArrayCopy); // ✅ \u0026#34;[Tom, Jerry]\u0026#34;  因此，下面方法的返回值的数组类型 Object [] 不能直接被转换为目标类型数组： public static Object[] badCopyOf(Object[] a, int newLength) { Object[] newArray = new Object[newLength]; System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength)); return newArray; }   利用反射实现 goodCopyOf // 1. 参数 array 的类型为 Object，而不是 Object[] 的原因：整型数组类型int[]可以被转换成Object，但不能转换成对象数组。 // 2. 返回值的类型为 Object，而不是 Object[] 的原因：最开始就定义为 `Object []` 的数组不能直接被转换为目标类型数组。 private static Object goodCopyOf(Object array, int newLength) { Objects.requireNonNull(array); Class clazz = array.getClass(); if (clazz.isArray()) { Class componentTypeClazz = clazz.getComponentType(); int length = Array.getLength(array); Object newArray = Array.newInstance(componentTypeClazz, newLength); System.arraycopy(array, 0, newArray, 0, Math.min(length, newLength)); return newArray; } else { throw new IllegalArgumentException(\u0026#34;First parameter should be an array.\u0026#34;); } } 调用任意方法 // `name` 为方法名，`parameterTypes`为该方法的参数类型（因为可能存在重载）  Method getMethod(String name, Class... parameterTypes) // 该方法属于`Class`类的实例对象 // `obj` 为该方法所属的对象，如果为静态方法，传入`null`即可，后面的`args`为该方法所需的参数 // 返回值如果为基本类型，会自动包装后返回  public Object invoke(Object obj, Object... args) // 该方法属于 `Method` 类的实例对象 ","permalink":"https://hiwangzi.com/posts/2017/10/14/core-java-04-07/","summary":"反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。 能够分析类能力的程序称为反射(reflective)，其可以：  在运行中分析类 在运行中查看对象 编写泛型数组代码 调用任意方法   java.lang.Class 类用于描述 JVM 中使用的类。 不要过多地使用反射，其不适合编写应用程序。反射是很脆弱的，编译器很难帮助人们发现程序中的错误，因此很有可能会导致运行时出现异常。  在运行中分析类  获取Class对象的三种方式（JVM为每个类型管理一个 Class 对象）： // 1. 通过实例对象获取 Random random = new Random(); Class cl = random.getClass(); System.out.println(cl.getName()); // 输出为 java.util.Random  // 2. 通过静态方法 forName 获得类名对应的 Class 对象 Class cl = Class.forName(\u0026#34;java.util.Random\u0026#34;); // 3. 通过`类.class`获取（例如cl2，基本类型也可以） Class cl1 = Random.class; Class cl2 = int.class; Class cl3 = Double[].class; // 历史原因，getName 方法有时会返回一个奇怪的名字 Double[].","title":"【Java 核心笔记】04.07. 反射"},{"content":"类间关系  依赖(dependence)（uses-a）：例如Order对象使用Account对象查看账户的信用状态 聚合(aggregation)（has-a）：例如Order对象包含了一些Item对象 继承(inheritance)（is-a）  对应的 UML 符号   有些方法学家不喜欢聚合这个概念，而更加喜欢「关联(association)」这个术语。但「has-a」更加形象，同时「关联」的 UML 符号不易区分。\n  以下是一个UML类图的示例：\n  类的一些要点补充  使用类的方法时，会隐式包含一个参数——方法名前的类对象（方法之中使用this调用），这被称为隐式(implicit)参数。其他参数称为显式(explicit)参数。 方法接收参数的形式是按值调用(call by value)。 可以通过「方法的签名(signature)」来完整地描述一个方法（方法名+参数类型，不包含返回类型），例如String类的indexOf方法  indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int)   默认域的初始化  如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。 但局部变量不可，必须明确地初始化方法中的局部变量。   类中代码执行顺序原则：  静态优先（静态域、静态代码块） 对于非静态，顺序为：域(初始化语句)、构造代码块（初始化块）、构造方法 总结：父类静态元素 -\u0026gt; 子类静态元素 -\u0026gt; 父类非静态元素 -\u0026gt; 子类非静态元素   装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。  包  从编译器的角度来看，嵌套的包之间没有任何关系。 import java.time.* 对代码的大小无负面影响，但会降低人可读性。 只能使用星号(*)导入 一个 包，而不能使用import java.*或import java.*.*导入以java为前缀的所有包。 在包中定位类是编译器的工作，字节码中使用完整的包名引用其他类。 import static java.lang.System.*这样的写法可以导入System类的静态方法和静态域，可以直接使用而无需加类名前缀。  ","permalink":"https://hiwangzi.com/posts/2017/10/14/core-java-04-06/","summary":"类间关系  依赖(dependence)（uses-a）：例如Order对象使用Account对象查看账户的信用状态 聚合(aggregation)（has-a）：例如Order对象包含了一些Item对象 继承(inheritance)（is-a）  对应的 UML 符号   有些方法学家不喜欢聚合这个概念，而更加喜欢「关联(association)」这个术语。但「has-a」更加形象，同时「关联」的 UML 符号不易区分。\n  以下是一个UML类图的示例：\n  类的一些要点补充  使用类的方法时，会隐式包含一个参数——方法名前的类对象（方法之中使用this调用），这被称为隐式(implicit)参数。其他参数称为显式(explicit)参数。 方法接收参数的形式是按值调用(call by value)。 可以通过「方法的签名(signature)」来完整地描述一个方法（方法名+参数类型，不包含返回类型），例如String类的indexOf方法  indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int)   默认域的初始化  如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。 但局部变量不可，必须明确地初始化方法中的局部变量。   类中代码执行顺序原则：  静态优先（静态域、静态代码块） 对于非静态，顺序为：域(初始化语句)、构造代码块（初始化块）、构造方法 总结：父类静态元素 -\u0026gt; 子类静态元素 -\u0026gt; 父类非静态元素 -\u0026gt; 子类非静态元素   装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。  包  从编译器的角度来看，嵌套的包之间没有任何关系。 import java.time.* 对代码的大小无负面影响，但会降低人可读性。 只能使用星号(*)导入 一个 包，而不能使用import java.*或import java.*.*导入以java为前缀的所有包。 在包中定位类是编译器的工作，字节码中使用完整的包名引用其他类。 import static java.","title":"【Java 核心笔记】04.06. UML、类的一些要点补充"},{"content":"在类的内部还可以定义另一个类。如果在类 Outter 的内部再定义一个类 Inner ，此时类 Inner 就称为内部类，而类 Outter 则称为外部类。 内部类可声明为 public 或 private。当内部类声明为 public 或 private 时，对其访问的限制与成员变量和成员方法完全相同。\nclass Outer { // 定义外部类  private String info = \u0026#34;hello world\u0026#34;; // 定义外部类的私有属性  class Inner { // 定义内部类  public void print(){ // 定义内部类的方法  System.out.println(info); // 直接访问外部类的私有属性  } } public void fun() { // 定义外部类的方法  new Inner().print(); // 通过内部类的实例化对象调用方法  } } public class InnerClassDemo01 { public static void main(String args[]){ new Outer().fun(); // 调用外部类的fun()方法  } } // 以上程序中，Inner 类作为 Outter 的内部类存在， // 并且在外部类的 fun() 方法之中直接实例化内部类的对象并调用 print() 方法。 内部类存在的特点：\n 缺点：破坏了程序的结构 优点：可以方便的访问外部类中的私有属性  在其他类中调用内部类 一个内部类除了可以通过外部类访问，也可以直接在其他类中调用（这里指的是在声明了外部类对象后，通过外部类对象调用内部类构造方法来实例化一个内部类对象），调用的格式如下：\n外部类.内部类 内部类对象 = 外部类实例.new 内部类(); class Outer { // 定义外部类  private String info = \u0026#34;hello world\u0026#34;; // 定义外部类的私有属性  class Inner{ // 定义内部类  public void print() { // 定义内部类的方法  System.out.println(info); // 直接访问外部类的私有属性  } } public void fun() { // 定义外部类的方法  new Inner().print(); // 通过内部类的实例化对象调用方法  } } public class InnerClassDemo04 { public static void main(String args[]) { Outer out = new Outer(); // 外部类实例化对象  Outer.Inner in = out.new Inner(); // 实例化内部类对象  in.print(); // 调用内部类的方法  new Outer().new Inner().print(); // 与上面的代码等效  } } 使用 static 声明内部类 如果一个内部类使用 static 关键字声明，则此内部类称为静态内部类（内部类访问控制是 public 的情况下相当于一个外部类，可以直接通过外部类.内部类进行访问）\nclass Outer{ // 定义外部类  private static String info = \u0026#34;hello world\u0026#34;; // 定义外部类的私有属性  static class Inner { // 使用static定义内部类为外部类  public void print() { // 定义内部类的方法  System.out.println(info); // 直接访问外部类的私有属性  } } } public class InnerClassDemo03 { public static void main(String args[]) { new Outer.Inner().print(); } } 在方法中定义内部类 一个内部类可以在任意的位置定义，下面在方法中定义内部类。\nclass Outer { // 定义外部类  private String info = \u0026#34;hello world\u0026#34;; // 定义外部类的私有属性  public void fun(final int temp) { // 定义外部类的方法  class Inner { // 在方法中定义的内部类  public void print() { // 定义内部类的方法  System.out.println(\u0026#34;类中属性：\u0026#34; + info); // 直接访问外部类的私有属性  System.out.println(\u0026#34;方法中参数：\u0026#34; + temp); } } new Inner().print() ; // 通过内部类的实例化对象调用方法  } } public class InnerClassDemo05{ public static void main(String args[]){ new Outer().fun(30) ; // 调用外部类的方法  } } 以上代码还可以写作「匿名对象」的形式：\nclass Outer{ // 定义外部类  private String info = \u0026#34;hello world\u0026#34; ; // 定义外部类的私有属性  public void fun(final int temp){ // 定义外部类的方法  new Object(){ public void print(){ // 定义内部类的方法  System.out.println(\u0026#34;类中的属性：\u0026#34; + info); // 直接访问外部类的私有属性  System.out.println(\u0026#34;方法中的参数：\u0026#34; + temp); } }.print(); } } 补充：Java 1.8 后还可以考虑使用 lambda 表达式。\n","permalink":"https://hiwangzi.com/posts/2017/10/14/core-java-04-05/","summary":"在类的内部还可以定义另一个类。如果在类 Outter 的内部再定义一个类 Inner ，此时类 Inner 就称为内部类，而类 Outter 则称为外部类。 内部类可声明为 public 或 private。当内部类声明为 public 或 private 时，对其访问的限制与成员变量和成员方法完全相同。\nclass Outer { // 定义外部类  private String info = \u0026#34;hello world\u0026#34;; // 定义外部类的私有属性  class Inner { // 定义内部类  public void print(){ // 定义内部类的方法  System.out.println(info); // 直接访问外部类的私有属性  } } public void fun() { // 定义外部类的方法  new Inner().print(); // 通过内部类的实例化对象调用方法  } } public class InnerClassDemo01 { public static void main(String args[]){ new Outer().","title":"【Java 核心笔记】04.05. 内部类"},{"content":"代码块就是使用 {} 括起来的一段代码，根据位置不同，可分为四类：\n 普通代码块 构造代码块 静态代码块 同步代码块  普通代码块 直接定义在方法中的代码块称为普通代码块。\npublic class Demo { public static void main(String args[]) { { // 普通代码块  int x = 30; // 属于局部变量  System.out.println(\u0026#34;普通代码块 --\u0026gt; x = \u0026#34; + x); } int x = 100; // 与局部变量名称相同  System.out.println(\u0026#34;代码块之外 --\u0026gt; x = \u0026#34; + x); } } // 输出 // 普通代码块 --\u0026gt; x = 30 // 代码块之外 --\u0026gt; x = 100 构造代码块 直接在类中定义的代码块，称为构造块。\npublic class Demo { public static void main(String args[]) { new JustClass(); // 实例化对象  new JustClass(); // 实例化对象  new JustClass(); // 实例化对象  } } class JustClass { { // 直接在类中编写代码块，称为构造块  System.out.println(\u0026#34;1. 构造块。\u0026#34;); } public JustClass() { // 定义构造方法  System.out.println(\u0026#34;2. 构造方法。\u0026#34;); } } // 输出 // 1. 构造块。 // 2. 构造方法。 // 1. 构造块。 // 2. 构造方法。 // 1. 构造块。 // 2. 构造方法。 可以发现，\n 构造块优先于构造方法执行（代码先后顺序无影响），且执行多次。 只要有实例化对象产生，就执行构造块中的语句。  静态代码块 使用 static 关键字声明的代码块就称为静态代码块。\npublic class Demo { static { // 在主方法所在的类中定义静态块  System.out.println(\u0026#34;在主方法所在类中定义的代码块\u0026#34;); } public static void main(String args[]) { new JustClass(); // 实例化对象  new JustClass(); // 实例化对象  new JustClass(); // 实例化对象  } } class JustClass { { // 直接在类中编写代码块，称为构造块  System.out.println(\u0026#34;1. 构造块。\u0026#34;); } static { // 使用static，称为静态代码块  System.out.println(\u0026#34;0. 静态代码块\u0026#34;); } public JustClass() { // 定义构造方法  System.out.println(\u0026#34;2. 构造方法。\u0026#34;); } } // 输出 // 在主方法所在类中定义的代码块 // 0. 静态代码块 // 1. 构造块。 // 2. 构造方法。 // 1. 构造块。 // 2. 构造方法。 // 1. 构造块。 // 2. 构造方法。 注意：\n 静态块优先于主方法执行。 不管有多少个实例化对象产生，静态代码块只执行一次。 静态代码块的主要功能是为静态属性初始化。  ","permalink":"https://hiwangzi.com/posts/2017/10/14/core-java-04-04/","summary":"代码块就是使用 {} 括起来的一段代码，根据位置不同，可分为四类：\n 普通代码块 构造代码块 静态代码块 同步代码块  普通代码块 直接定义在方法中的代码块称为普通代码块。\npublic class Demo { public static void main(String args[]) { { // 普通代码块  int x = 30; // 属于局部变量  System.out.println(\u0026#34;普通代码块 --\u0026gt; x = \u0026#34; + x); } int x = 100; // 与局部变量名称相同  System.out.println(\u0026#34;代码块之外 --\u0026gt; x = \u0026#34; + x); } } // 输出 // 普通代码块 --\u0026gt; x = 30 // 代码块之外 --\u0026gt; x = 100 构造代码块 直接在类中定义的代码块，称为构造块。","title":"【Java 核心笔记】04.04. 代码块"},{"content":" 安全复制（英语：Secure copy，缩写SCP）是指在本地主机与远程主机或者两台远程主机之间基于Secure Shell（SSH）协议安全地传输电脑文件。“SCP”通常指安全复制协议或者程序本身。安全复制 - 维基百科，自由的百科全书\n   其使用方法类似于 cp 命令。\n  复制文件或目录命令：\n  复制文件：\n 将本地文件拷贝到远程 scp 文件名 --用户名@计算机IP或者计算机名称:远程路径 从远程将文件拷回本地 scp --用户名@计算机IP或者计算机名称:文件名 本地路径    复制目录：\n 将本地目录拷贝到远程 scp -r 目录名 用户名@计算机IP或者计算机名称:远程路径 从远程将目录拷回本地 scp -r 用户名@计算机IP或者计算机名称:目录名 本地路径      注意，如果远程主机使用非默认端口22，可以在命令中指定。例如，从远程主机复制一个文件到本地。\nscp -P 2222 user@host:directory/SourceFile TargetFile   ","permalink":"https://hiwangzi.com/posts/2017/10/11/scp-newbie-note/","summary":" 安全复制（英语：Secure copy，缩写SCP）是指在本地主机与远程主机或者两台远程主机之间基于Secure Shell（SSH）协议安全地传输电脑文件。“SCP”通常指安全复制协议或者程序本身。安全复制 - 维基百科，自由的百科全书\n   其使用方法类似于 cp 命令。\n  复制文件或目录命令：\n  复制文件：\n 将本地文件拷贝到远程 scp 文件名 --用户名@计算机IP或者计算机名称:远程路径 从远程将文件拷回本地 scp --用户名@计算机IP或者计算机名称:文件名 本地路径    复制目录：\n 将本地目录拷贝到远程 scp -r 目录名 用户名@计算机IP或者计算机名称:远程路径 从远程将目录拷回本地 scp -r 用户名@计算机IP或者计算机名称:目录名 本地路径      注意，如果远程主机使用非默认端口22，可以在命令中指定。例如，从远程主机复制一个文件到本地。\nscp -P 2222 user@host:directory/SourceFile TargetFile   ","title":"scp 命令简明介绍"},{"content":"键入命令 [zill@hiwangzi.com ~]$ command [-options] parameter1 parameter2 ... 指令 选项 参数(1) 参数(2) 注意：有时也可以使用 + 放置于选项或参数之前\n例如：\nzill@zill-pc:~$ date +%Y/%m/%d 2017/10/09 zill@zill-pc:~$ date +%H:%M 17:32 几个程序  显示日期与时间的指令： date 显示日历的指令： cal 简单好用的计算器： bc（进入交互界面后 scale=number 设置小数点位数）  几个按键  [Tab]：主要用于自动补全 [Ctrl]-c：中断当前程序 [Ctrl]-d：通常代表「键盘输入结束（End Of File, EOF 或 End Of Input）」的意思（可以代替手动输入 exit） [Shift]+{[PageUP]|[Page Down]}：向前翻页|向后翻页  关于帮助文档 1. man 表格的第一行，可以看到「DATE(1)」，其中(1)代表「一般使用者可以使用的指令」。\n常见代号及含义（可以通过 man man 获得更详细的说明）：\n   代号 代表内容     1 使用者在shell环境中可以操作的指令   2 系统核心可调用的函数与工具等   3 一些常用的函數(function)与函数库(library)，大部分为C的函数库(libc)   4 硬件的说明，通常在/dev下的文件   5 设置文件或者是某些文件的格式   6 游戏(games)   7 惯例与协定，例如Linux文件系统、网络协议、ASCII code等等的说明   8 系统管理员可以使用的管理指令   9 跟kernel有关的文件    可以使用 man -f 指令 查找相关指令（名称完全相同）。 可以使用 man -k 指令 搜索相关指令。\n2. info page Linux 里额外提供的一种线上求助的方法，和 man 的用途差不多，但与man page输出全部信息不同，info page阅读起来更友好。\n3. /usr/share/doc 系统状态  查看在线的用户：who 查看网络的连接状态：netstat -a 查看后台程序：ps -aux  关机  将数据写入硬盘的指令： sync（目前的 shutdown/reboot/halt 等等指令均已在关机前对 sync 进行了调用） 常用关机指令： shutdown 重新开机、关机： reboot, halt, poweroff 还可以使用管理工具 systemctl 关机 [root@study ~]# systemctl [指令] 指令項目包括如下： halt 進入系統停止的模式，螢幕可能會保留一些訊息，這與你的電源管理模式有關 poweroff 進入系統關機模式，直接關機沒有提供電力喔！ reboot 直接重新開機 suspend 進入休眠模式   ","permalink":"https://hiwangzi.com/posts/2017/10/09/vbird-linux-04/","summary":"键入命令 [zill@hiwangzi.com ~]$ command [-options] parameter1 parameter2 ... 指令 选项 参数(1) 参数(2) 注意：有时也可以使用 + 放置于选项或参数之前\n例如：\nzill@zill-pc:~$ date +%Y/%m/%d 2017/10/09 zill@zill-pc:~$ date +%H:%M 17:32 几个程序  显示日期与时间的指令： date 显示日历的指令： cal 简单好用的计算器： bc（进入交互界面后 scale=number 设置小数点位数）  几个按键  [Tab]：主要用于自动补全 [Ctrl]-c：中断当前程序 [Ctrl]-d：通常代表「键盘输入结束（End Of File, EOF 或 End Of Input）」的意思（可以代替手动输入 exit） [Shift]+{[PageUP]|[Page Down]}：向前翻页|向后翻页  关于帮助文档 1. man 表格的第一行，可以看到「DATE(1)」，其中(1)代表「一般使用者可以使用的指令」。\n常见代号及含义（可以通过 man man 获得更详细的说明）：\n   代号 代表内容     1 使用者在shell环境中可以操作的指令   2 系统核心可调用的函数与工具等   3 一些常用的函數(function)与函数库(library)，大部分为C的函数库(libc)   4 硬件的说明，通常在/dev下的文件   5 设置文件或者是某些文件的格式   6 游戏(games)   7 惯例与协定，例如Linux文件系统、网络协议、ASCII code等等的说明   8 系统管理员可以使用的管理指令   9 跟kernel有关的文件    可以使用 man -f 指令 查找相关指令（名称完全相同）。 可以使用 man -k 指令 搜索相关指令。","title":"《鸟哥的Linux私房菜》笔记——04. 简单命令行"},{"content":"  Everything is a file.\n  常见硬件对应于 Linux 下的文件（/dev目录下）\n   装置 装置在Linux内的档名     SCSI/SATA/U盘硬盘机 /dev/sd[a-p]   U盘 /dev/sd[a-p]（与SATA相同）   VirtI/O界面 /dev/vd[a-p]（用于虚拟机内）   软盘机 /dev/fd[0-1]   打印机 25针: /dev/lp[0-2]; USB: /dev/usb/lp[0-15]   鼠标 PS2: /dev/psaux; USB: /dev/usb/mouse[0-15]   CDROM/DVDROM /dev/scd[0-1]（通用）; /dev/sr[0-1]（通用，CentOS较常见）   当前CDROM/DVDROM /dev/cdrom   当前的鼠标 /dev/mouse   磁带机 IDE: /dev/ht0; SATA/SCSI: /dev/st0   IDE硬盘机 /dev/hd[a-d]（近乎被淘汰）      MBR 分区方式   硬盘的第一个扇区主要记录了两个重要的信息，分别是：\n 主要启动记录区(Master Boot Record, MBR)：可以安装启动管理程序的地方，有446 bytes 分割表(partition table)：记录整块硬盘分割的状态，有64 bytes    关于磁盘分区表(partition table)：\n 磁盘分区的最小单位是磁柱。 在分割表所在的64 bytes容量中，总共分为四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。    假设下面的硬盘文件名为/dev/hda，那么这四个分区的文件名就如下所示：\n P1: /dev/hda1 P2: /dev/hda2 P3: /dev/hda3 P4: /dev/hda4    以上提到的四个分区指的是主分区，如果需要，可以通过扩展分区来实现：\n  在上图中，四个主分区记录区仅使用其中两个，P2通过扩展分区，分配出五个逻辑分区。\n  扩展分配的目的是使用额外的磁区来记录分割信息，扩展分配本身并不能被拿来格式化。\n  其在Linux系统中文件名如下：\n P1: /dev/hda1 P2: /dev/hda2 L1: /dev/hda5 L2: /dev/hda6 L3: /dev/hda7 L4: /dev/hda8 L5: /dev/hda9 其中没有出现/dev/hda3与/dev/hda4，是因为前面四个数字保留给主分区/扩展分区使用。    小总结：\n 主要分割与扩展分配最多可以有四笔(硬盘的限制) 扩展分配最多只能有一个(操作系统的限制) 逻辑分割是由扩展分配持续切割出来的分割槽； 能够被格式化后，作为数据存取的分割槽为主要分割与逻辑分割。扩展分配无法格式化； 逻辑分割的数量依操作系统而不同，在Linux系统中，IDE硬盘最多有59个逻辑分割(5号到63号)， SATA硬盘则有11个逻辑分割(5号到15号)。    缺点：\n 操作系统无法识别大于 2.2T 以上的磁盘容量； MBR 仅有一个区块，若被破坏后，无法或很难恢复； 存放 boot loader 的区块仅有 446 bytes，无法容纳较多的代码。      GUID partition table, GPT 分区方式   过去一个扇区大小为512bytes，而目前已经出现了4k的扇区设计。为了兼容于所有的硬盘，在扇区的定义上，大多使用逻辑区块地址（Logical Block Address, LBA）来处理。GPT将硬盘所有区块以此LBA（预设为512bytes）来规划，第一个LBA称为LBA0。\n  与MBR仅仅使用第一个512bytes来记录不同，GPT使用了34个LBA区块来记录硬盘分割信息，同时整个硬盘的最后33个LBA被用来作为另一个备份。\n LBA0（MBR兼容区块）： 与MBR模式类似，也分为两部分，一部分是与之前446bytes相似的区块，存储第一阶段的boot loader程序。但在原本的磁盘分割表记录区中，仅仅放入一个特殊标志分割，以此表明当前为GPT分区方式。 LBA1（GPT表头记录）： 这个部分记录了分割表本身的位置与大小，同时记录了备份用的GPT分割放置的位置，以及校验码（CRC32）。操作系统可以根据校验码判断GPT是否正确，若有错误，则可以取得备份来恢复。 LBA2-33（实际记录分割记录信息处）： 从LBA2区块开始，每个LBA都可以记录4个分割记录，所以在默认情况下，可以记录4*32=128个记录。每一个记录除了记录所需要的标志码与相关记录意外，还分别提供了64bits来记录开始/结束的区块号码。因此对一单一的分区来说，最大容量限制在「264 × 512bytes = 263 × 1Kbytes = 233 × TB = 8 ZB 」    系统启动流程（BIOS + MBR/GPT） 简单的说，整个启动流程到操作系统之前的动作应该是这样的：\n BIOS：启动主动运行的韧体，会认识第一个可启动的装置； MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序； 启动管理程序(boot loader)：一支可读取核心文件来运行的软件； 核心文件：开始操作系统的功能\u0026hellip;  关于第二点，如果分区方式为GPT的话，BIOS同样可以在MBR兼容区块（LBA0）读取到boot loader程序，如果boot loader可以识别GPT分区的话，就可以正常启动系统。\n由于MBR仅有446 bytes，所以boot loader非常精简，其主要任务是：\n 提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能！ 加载核心文件：直接指向可启动的程序区段来开始操作系统； 转交其他loader：将启动管理功能转交给其他loader负责。  正是因为有第三点的功能，才能实现「多系统」功能。\n举例，计算机只有一个硬盘，分为四个分区，其中第一、二分区分别安装了Windows与Linux。如何在启动时选择启动哪个操作系统呢？\n假设MBR内安装的是可以同时认识Windows与Linux操作系统的启动管理程序，整个流程就如下图所示：\nMBR的启动管理程序提供两个菜单，菜单一(M1)可以直接加载Windows的核心文件来启动； 菜单二(M2)则是将启动管理工作交给第二个分割槽的启动磁区(boot sector)。\n当使用者在启动的时候选择菜单二时， 那么整个启动管理工作就会交给第二分割槽的启动管理程序了。 当第二个启动管理程序启动后，该启动管理程序内(上图中)仅有一个启动菜单，因此就能够使用Linux的核心文件来启动。\n 小总结：  每个分割槽都拥有自己的启动磁区(boot sector) 图中的系统槽为第一及第二分割槽， 实际可启动的核心文件是放置到各分割槽内的！ loader只会认识自己的系统槽内的可启动核心文件，以及其他loader而已； loader可直接指向或者是间接将管理权转交给另一个管理程序。    系统启动流程（UEFI + GPT） 事实上，BIOS 并不能识别GPT，其是通过GPT的兼容实现（LBA0）来加载boot loader。同时，BIOS仅仅为16位程序，功能较弱。因此UEFI(Unified Extensible Firmware Interface) 这个可扩展的界面产生。其基本上可以说是一个低级层次的小型操作系统。\n   比较项目 传统 BIOS UEFI     使用程序语言 汇编语言 C 语言   硬件资源控制 使用中断 (IRQ) 管理; 不可变的内存存取; 不可变得输入/输出存取 使用驱动程序与协定   处理器运行环境 16 位元 CPU 保护模式   扩展方式 通过 IRQ 连接 直接載入驱动程序   第三方厂商支持 较差 较好且可支持多平台   图形化能力 较差 较好   內建简化操作系统前环境 不支持 支持    另外，与BIOS相比，虽然UEFI可以直接读取GPT的分割表，不过最好依然拥有BIOS boot的分区支持（LBA0）。同时为了兼容Windows，并提供其他第三方厂商所使用的UEFI程序存储空间，必须格式化一个vfat的文件系统，大约提供512MB到1G左右的容量，以便让其他UEFI程序执行较为方便。\n关于挂载（mount）   Linux 的目录树结构\n  文件系统与目录树的关系 所谓的「挂载」就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说，进入该目录就可以读取该分区的意思。这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。\n  上图中假设硬盘分为两个分区，partition 1是挂载到根目录，而partition 2则是挂载到/home这个目录。 这也就是说，当数据放置在/home内的各次目录时，数据是放置到partition 2的，如果不是放在/home底下的目录， 那么数据就会被放置到partition 1。\n其实判断某个文件在那个partition底下是很简单的，透过反向追踪即可。以上图来说， 当我想要知道/home/vbird/test这个文件在那个partition时，由test \u0026ndash;\u0026gt; vbird \u0026ndash;\u0026gt; home \u0026ndash;\u0026gt; /，看那个『进入点』先被查到那就是使用的进入点了。 所以test使用的是/home这个进入点而不是/。\n","permalink":"https://hiwangzi.com/posts/2017/10/09/vbird-linux-03/","summary":"Everything is a file.\n  常见硬件对应于 Linux 下的文件（/dev目录下）\n   装置 装置在Linux内的档名     SCSI/SATA/U盘硬盘机 /dev/sd[a-p]   U盘 /dev/sd[a-p]（与SATA相同）   VirtI/O界面 /dev/vd[a-p]（用于虚拟机内）   软盘机 /dev/fd[0-1]   打印机 25针: /dev/lp[0-2]; USB: /dev/usb/lp[0-15]   鼠标 PS2: /dev/psaux; USB: /dev/usb/mouse[0-15]   CDROM/DVDROM /dev/scd[0-1]（通用）; /dev/sr[0-1]（通用，CentOS较常见）   当前CDROM/DVDROM /dev/cdrom   当前的鼠标 /dev/mouse   磁带机 IDE: /dev/ht0; SATA/SCSI: /dev/st0   IDE硬盘机 /dev/hd[a-d]（近乎被淘汰）      MBR 分区方式   硬盘的第一个扇区主要记录了两个重要的信息，分别是：","title":"《鸟哥的Linux私房菜》笔记——03. 磁盘分区"},{"content":"匿名对象  匿名对象：只在堆内存中开辟空间，不存在栈内存的引用。 由于匿名对象没有对应的栈内存引用所指向，所以使用一次之后，就等待被垃圾回收了。 例：一个单独的字符串就是一个 String 的匿名对象。System.out.println(\u0026quot;Hi\u0026quot;);  字符串缓冲池 public class Test { public static void main(String[] args) { String str = \u0026#34;hello\u0026#34; ; System.out.println(\u0026#34;hello\u0026#34;.equals(str)) ; // true  System.out.println(\u0026#34;hello\u0026#34; == str); // true  // String 池：Java为了优化字符串操作 提供了一个缓冲池；  // str 指向字符串 “hello” ,第二句中字符串 “hello” ，因为字符串在常量池中已经存在，第二句中字符串 “hello” 就不再开辟空间。  // 所以不管是 equals 比较内容， == 比较内存地址都为 true  // 但请不要使用这种方式比较字符串，不稳键  } }  下面的代码验证了我去「XXXX」面试时真的是乱吹🙈：  /* * 当时我以为 JVM 的缓冲池可以实现“变量(a)连接字符串(\u0026#34;b\u0026#34;)可以与\u0026#34;ab\u0026#34;使用同一个堆内存” * 但是事实是并不可行 */ public class StringTest{ public static void main(String [] args){ String ab=\u0026#34;ab\u0026#34;; String a=\u0026#34;a\u0026#34;; // 「变量」与「变量连接字符串（匿名对象）」比较  System.out.println(ab.equals((a+\u0026#34;b\u0026#34;))); // true  System.out.println(ab==(a+\u0026#34;b\u0026#34;)); // false  // 「字符串（匿名对象）」与「字符串（匿名对象）连接字符串（匿名对象）」比较  System.out.println(); System.out.println(\u0026#34;ab\u0026#34;.equals((\u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;))); // true  System.out.println(\u0026#34;ab\u0026#34;==(\u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;)); // true  // 「变量」与「字符串（匿名对象）连接字符串（匿名对象）」比较  System.out.println(); System.out.println(ab.equals((\u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;))); // true  System.out.println(ab==(\u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;)); // true  // 「字符串（匿名对象）」与「变量」比较  System.out.println(); System.out.println(\u0026#34;ab\u0026#34;.equals(ab)); // true  System.out.println(\u0026#34;ab\u0026#34;==ab); // true  // 「变量」与「字符串（匿名对象）」比较  System.out.println(); System.out.println(ab.equals(\u0026#34;ab\u0026#34;)); // true  System.out.println(ab==\u0026#34;ab\u0026#34;); // true  } }  时光恍惚，当时还在用着 Deepin（上图） 现在看来（2018年4月13日），道理也并不复杂  像 \u0026quot;a\u0026quot;+\u0026quot;b\u0026quot; 这种代码，在编译的时候必然可以优化为 \u0026quot;ab\u0026quot; 但 a+\u0026quot;b\u0026quot; 显式的开辟了两个堆内存空间（分别存储\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;），并且还需要再次开辟堆空间存储连接后的值     What is String pool in Java\nThis prints true (even though we don\u0026rsquo;t use equals method: correct way to compare strings)\nString s = \u0026#34;a\u0026#34; + \u0026#34;bc\u0026#34;; String t = \u0026#34;ab\u0026#34; + \u0026#34;c\u0026#34;; System.out.println(s == t); When compiler optimizes your string literals, it sees that both s and t have same value and thus you need only one string object. It\u0026rsquo;s safe because String is immutable in Java.\nAs result, both s and t point to the same object and some little memory saved.\nName \u0026lsquo;string pool\u0026rsquo; comes from the idea that all already defined string are stored in some \u0026lsquo;pool\u0026rsquo; and before creating new String object compiler checks if such string is already defined.\n参考：https://stackoverflow.com/questions/3801343/what-is-string-pool-in-java#3801355\n   ","permalink":"https://hiwangzi.com/posts/2017/10/07/core-java-04-03/","summary":"匿名对象  匿名对象：只在堆内存中开辟空间，不存在栈内存的引用。 由于匿名对象没有对应的栈内存引用所指向，所以使用一次之后，就等待被垃圾回收了。 例：一个单独的字符串就是一个 String 的匿名对象。System.out.println(\u0026quot;Hi\u0026quot;);  字符串缓冲池 public class Test { public static void main(String[] args) { String str = \u0026#34;hello\u0026#34; ; System.out.println(\u0026#34;hello\u0026#34;.equals(str)) ; // true  System.out.println(\u0026#34;hello\u0026#34; == str); // true  // String 池：Java为了优化字符串操作 提供了一个缓冲池；  // str 指向字符串 “hello” ,第二句中字符串 “hello” ，因为字符串在常量池中已经存在，第二句中字符串 “hello” 就不再开辟空间。  // 所以不管是 equals 比较内容， == 比较内存地址都为 true  // 但请不要使用这种方式比较字符串，不稳键  } }  下面的代码验证了我去「XXXX」面试时真的是乱吹🙈：  /* * 当时我以为 JVM 的缓冲池可以实现“变量(a)连接字符串(\u0026#34;b\u0026#34;)可以与\u0026#34;ab\u0026#34;使用同一个堆内存” * 但是事实是并不可行 */ public class StringTest{ public static void main(String [] args){ String ab=\u0026#34;ab\u0026#34;; String a=\u0026#34;a\u0026#34;; // 「变量」与「变量连接字符串（匿名对象）」比较  System.","title":"【Java 核心笔记】04.03. 匿名对象与字符串缓冲池"},{"content":"方法的覆写   当子类定义了与父类方法名称相同、参数的类型及个数、返回值相同的方法时，就被称为方法的覆写。\n  被覆写的方法不能拥有比父类方法更严格的访问权限。private \u0026lt; default \u0026lt; protected \u0026lt; public\n 如果父类中的方法使用了 private 声明，而子类中同样的方法使用了 public 声明，这样属于覆写么？不属于。 class A { public void fun() { print(); } /*①*/ void print() { System.out.println(\u0026#34;父类中的 print() 方法\u0026#34;); } } class B extends A { /*②*/ void print() { // 覆写的是 print() 方法  System.out.println(\u0026#34;子类中的 print() 方法\u0026#34;); } } public class OverrideDemo { public static void main(String [] args) { B b = new B(); b.print(); b.fun(); } } // ① public; ② public 属于重写，输出结果为“子类；子类” // ① public; ② private 不属于重写，因为不符合重写原则，无法编译通过 // ① private; ② public 不属于重写，因为如果父类中方法使用了 private 声明， // 那这个方法对于子类而言是不可见的，即使它符合了覆写的访问限制要求， // 但仍然不能够动态的实现重写的效果，输出结果为“子类；父类”。 // 此时子类中的方法相当于子类新定义了一个方法，与父类中的同名方法无关     关于 this.方法() 与 super.方法()  使用 this.方法() 会首先查找本类中是否存在有要调用的方法名称，如果存在则直接调用，如果不存在则查找父类中是否具有此方法，如果有就调用，如果没有，则会出现编译时错误。 使用 super.方法() 明确的表示调用的方法不是子类中的方法（不查找子类），而直接调用父类中的指定方法。  属性的覆盖（了解）  子类定义了和父类完全相同的属性名称时，就称为属性的覆盖。 与方法的覆盖表现不同，实际上不能实现「动态多态」  public class VarOverrideDemo { public static void main(String [] args) { B b = new B(); b.print(); // Hello  // 100  System.out.println(c.str); // C  System.out.println(d.str); // D  System.out.println(c.getStr()); // D  System.out.println(d.getStr()); // D  } } class A { String info = \u0026#34;Hello\u0026#34;; } class B extends A { int info = 100; // 名称与父类中变量相同  public void print(){ System.out.println(super.info); System.out.println(this.info); } } class C { String str = \u0026#34;C\u0026#34;; public String getStr() { return str; } } class D extends C { String str = \u0026#34;D\u0026#34;; // 即使不加Override注解，也能实现动态绑定  // @Override  public String getStr() { return str; } } 但其实在实际开发中，这种特性意义不是很大，因为绝大多数情况，属性都是被封装的，而被限制为 private 后，对于子类而言不可见，因此不会相互影响。\n关于 this 与 super 的小总结    区别 this super     功能 调用本类构造、本类方法、本类属性 子类调用父类构造、父类方法、父类属性   形式 先查找本类中时候存在指定的调用结构，有则调用，无则调用父类定义 不查找子类，直接调用父类调用结构   特殊 表示本类的当前对象     建议在开发中，加上 this. 或者 super.，这样便于区分。\n","permalink":"https://hiwangzi.com/posts/2017/10/07/core-java-04-02/","summary":"方法的覆写   当子类定义了与父类方法名称相同、参数的类型及个数、返回值相同的方法时，就被称为方法的覆写。\n  被覆写的方法不能拥有比父类方法更严格的访问权限。private \u0026lt; default \u0026lt; protected \u0026lt; public\n 如果父类中的方法使用了 private 声明，而子类中同样的方法使用了 public 声明，这样属于覆写么？不属于。 class A { public void fun() { print(); } /*①*/ void print() { System.out.println(\u0026#34;父类中的 print() 方法\u0026#34;); } } class B extends A { /*②*/ void print() { // 覆写的是 print() 方法  System.out.println(\u0026#34;子类中的 print() 方法\u0026#34;); } } public class OverrideDemo { public static void main(String [] args) { B b = new B(); b.","title":"【Java 核心笔记】04.02. Override 的补充"},{"content":"继承  Java 中只允许单继承。  继承的UML类图表示，关于UML  在使用继承的时候应该注意的是：子类不能直接访问父类中的私有成员，但是子类可以调用父类中的非私有方法。（详见下文访问控制） 使用super()方法调用父类构造函数 class A { A(String str) { System.out.println(str); } } class B extends A { B() { // 1. 因为A类缺少默认构造方法，所以必须显示调用父类A的构造函数，  // 否则无法编译通过。  // 2. 另外，使用super，显示调用父类构造函数时，必须在方法体首行。  super(\u0026#34;default\u0026#34;); System.out.println(\u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;World\u0026#34;); } B(String str) { // 此处调用本类的无参构造函数，已经传递调用了父类A的构造函数。  this(); } } public class SuperTest { public static void main(String [] args) { B b = new B(\u0026#34;Hi\u0026#34;); } // 输出结果如下：  // default  // Hello  // World }  一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。 子类不能覆盖父类中 final 修饰的方法（final 类中所有方法自动地成为 final 方法，并且 final 类不能被继承）。 在父类转子类的类型转换前，可以先借助 instanceof 操作符，查看是否能够转换成功。 if (staff instanceof Manager) { boss = (Manager) staff; }  在超类（父类）设计合理的情况下，很少会使用到类型转换和 instanceof 运算符。  动态绑定、静态绑定  在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。 如果是 private 方法、static 方法、final 方法或者构造器，编译器可以准确知道应该调用哪个方法，此种调用方式称为静态绑定（static binding）。  抽象类  包含一个或多个抽象方法的类本身必须被声明为抽象的（abstract）。  除了抽象方法，抽象类还可以包含具体数据和具体方法。 扩展抽象类有两种选择：  一是部分实现抽象方法，此时子类仍需标记为抽象类； 二是定义全部抽象方法。   类即使不包含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。    访问控制   仅对本类可见—— private\n  对本包可见——默认，不需要修饰符（package private）\n  对本包和所有子类可见—— protected\n  对所有类可见—— public\n  如果没有明确地指出父类，则Object就被认为是这个类的超类，其常见几个方法：\n equals 方法 hashcode 方法 toString 方法    关于 protected 的补充：\n 即使两个子类继承自同一个父类，也不能在一个子类中访问另一个子类的protected方法   Protected access requires a little more elaboration. Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important). Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to. This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them.\n——《Java in a Nutshell》\n     equals 方法  equals 方法示例  // 代码来自《Java核心技术 卷I 第十版》P167 // 父类 public class Employee{ ... public boolean equals(Object otherObject){ // a quick test to see if the objects are identical  if(this == otherObject) return true; // must return false if the explicit parameter is null  if(otherObject == null) return false; // if the classes don\u0026#39;t match, they can\u0026#39;t be equal  // 笔者注：子类Manager通过super.equals方法调用到此处时，  // getClass()的结果是子类，这是动态绑定的体现  if(getClass() != otherObject.getClass()) return false; // now we know otherObject is a non-null Employee  Employee other = (Employee) otherObject; // test whether the fields hava identicial values  // 笔者注：此处使用Objects.equals方法是为了防备name或hireDay可能为null的情况  return Objects.equals(name, other.name) \u0026amp;\u0026amp; salary == other.salary \u0026amp;\u0026amp; Objects.equals(hireDate, other.hireDate); } } // 子类 // 1. 先调用父类的equals，如果返回false，对象则不可能相等 // 2. 如果父类中的域都相等，再比较子类中新增的实例域 public class Manager extends Employee{ ... public boolean equals(Object otherObject){ if(!super.equals(otherObject)) return false; // super.equals checked that this and otherObject belong to the same class  Manager other = (Manager) otherObject; return bonus == other.bonus; } }   Java 语言规范要求 equals 方法具有以下特性：\n 自反性：x.equals(x) 应当返回 true 对称性：x.equals(y) 与 y.equals(x) 返回应当相同 传递性：如果 x.equals(y) 返回 true，且 y.equals(z) 也返回 true，则 x.equals(z) 也应返回 true 一致性：如果 x 与 y 引用的对象没有发生变化，则 x.eqauls(y) 也不应变化 对于任意的非空引用 x，x.equals(null) 应当返回 false    在上面的例子中，if(getClass() != otherObject.getClass()) return false; 如果发现类型不一致，就返回 false。\n 但有一些程序员喜欢采用以下代码进行检测 if(!(otherObject instanceof Employee)) return false; 但这样存在问题，父类对象与子类对象比较时，不满足对称性，如下示例代码： import java.util.Objects; public class SuperTest { public static void main(String[] args) { Parent parent = new Parent(\u0026#34;Hi\u0026#34;); Child child = new Child(\u0026#34;Hi\u0026#34;); System.out.println(parent.equals(child)); System.out.println(child.equals(parent)); } } class Parent { private final String strParent; Parent(String str) { this.strParent = str; } @Override public boolean equals(Object otherObject) { if (this == otherObject) return true; if (otherObject == null) return false; // ⬇️ 最终输出会得到 true、java.lang.ClassCastException，不满足对称性  if (!(otherObject instanceof Parent)) return false; // ⬇️ 使用该种判断，最终输出会得到 false、false  // if (getClass() != otherObject.getClass()) return false;  Parent other = (Parent) otherObject; return Objects.equals(strParent, other.strParent); } } class Child extends Parent { private final String strChild; Child(String str) { super(str); this.strChild = str; } @Override public boolean equals(Object otherObject) { if (!super.equals(otherObject)) return false; Child other = (Child) otherObject; return Objects.equals(strChild, other.strChild); } }     关于 getClass 与 instanceof 两种检测方法：\n 如果子类能够拥有自己的相等概念，则对称性需求将强制采用 getClass 进行检测。 如果由超类决定相等的概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。 @Override public boolean equals(Object otherObject) { if (!super.equals(otherObject)) return false; // 为了实现「由超类决定相等的概念」，可以通过以下两种方式：  // 1. 直接移除子类的equals重载，因为既然都是父类决定，子类没有必要进行重载操作，比较推荐这种方式 👍  // 2. 基于上面的例子，通过在子类equals中增加instance判断（下面这行代码）  if (!(otherObject instanceof Child)) return true; Child other = (Child) otherObject; return Objects.equals(strChild, other.strChild); }  造成二者之间差异的根本原因：  子对象 instanceof 父类结果为true，父对象 instanceof 子类结果为false getClass得到的结果是动态绑定后的子类      编写完美的 equals 方法的建议：\n 显式参数命名为 otherObject，稍后需要将它转换为另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象：return this == otherObject; 检测 otherObject 是否为 null，是则返回 false。 比较 this 与 otherObject 是否属于同一个类：  如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：return getClass() != otherObject.getClass(); 如果所有的子类都拥有统一的语义，就使用 instanceof 检测：return (!(otherObject instanceof ClassName));   将 otherObject 转换为相应的类类型变量：ClassName other = (ClassName) otherObject 对所有需要比较的域进行比较。使用 == 比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配，则返回 true，否则返回false。 return field1 == other.field1 \u0026amp;\u0026amp; Objects.equals(field2, other.field2) \u0026amp;\u0026amp; ...; 如果在子类中重新定义 equals，就要在其中包含调用 super.equals(other)。\n    hashCode 方法  散列码（hash code）是由对象导出的一个整形值（可以是负数）。是没有规律的，如果x与y是两个不同的对象，则x.hashCode()与y.hashCode()基本上不会相同。 hashCode 方法定义在 Object 类中，因此每个对象都有一个默认的散列码方法，其返回结果是对象的存储地址。 一个例子：  代码： String string1 = \u0026#34;hiwangzi\u0026#34;; StringBuilder stringBuilder1 = new StringBuilder(string1); System.out.println(string1.hashCode() + \u0026#34; \u0026#34; + stringBuilder1.hashCode()); String string2 = new String(\u0026#34;hiwangzi\u0026#34;); StringBuilder stringBuilder2 = new StringBuilder(string2); System.out.println(string2.hashCode() + \u0026#34; \u0026#34; + stringBuilder2.hashCode());  输出结果： -1232882509 1975012498 -1232882509 1808253012  可以看到，String 对象的散列码是相同的，这是因为字符串的散列码是由内容导出的；而 StringBuffer 对象散列码不同，这是因为 StringBuffer 类没有定义 hashCode() 方法，它的散列码是由默认的 Object 类的默认 hashCode() 方法导出的对象存储地址。   如果重新定义 equals 方法，就必须重新定义 hashCode 方法，以便于可以将对象插入到散列表中。 可以调用 Objects.hash 方法并提供多个参数得到散列码（这种做法比较好）： public int hashCode(){ return Objects.hash(name, salary, hireDay); }  equals 与 hashCode 行为必须一致，即 x.equals(y) 与 x.hashCode() == y.hashCode() 结果一致。  toString 方法  绝大多数的 toString 方法都遵循这样的格式：类的名字，随后一对方括号括起来的域值。 public String toString(){ return getClass().getName() + \u0026#34;[name=\u0026#34; + name + \u0026#34;,salary=\u0026#34; + salary + \u0026#34;,hireDay=\u0026#34; + hireDay + \u0026#34;]\u0026#34;; }   ","permalink":"https://hiwangzi.com/posts/2017/10/07/core-java-04-01/","summary":"继承  Java 中只允许单继承。  继承的UML类图表示，关于UML  在使用继承的时候应该注意的是：子类不能直接访问父类中的私有成员，但是子类可以调用父类中的非私有方法。（详见下文访问控制） 使用super()方法调用父类构造函数 class A { A(String str) { System.out.println(str); } } class B extends A { B() { // 1. 因为A类缺少默认构造方法，所以必须显示调用父类A的构造函数，  // 否则无法编译通过。  // 2. 另外，使用super，显示调用父类构造函数时，必须在方法体首行。  super(\u0026#34;default\u0026#34;); System.out.println(\u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;World\u0026#34;); } B(String str) { // 此处调用本类的无参构造函数，已经传递调用了父类A的构造函数。  this(); } } public class SuperTest { public static void main(String [] args) { B b = new B(\u0026#34;Hi\u0026#34;); } // 输出结果如下：  // default  // Hello  // World }  一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。 子类不能覆盖父类中 final 修饰的方法（final 类中所有方法自动地成为 final 方法，并且 final 类不能被继承）。 在父类转子类的类型转换前，可以先借助 instanceof 操作符，查看是否能够转换成功。 if (staff instanceof Manager) { boss = (Manager) staff; }  在超类（父类）设计合理的情况下，很少会使用到类型转换和 instanceof 运算符。  动态绑定、静态绑定  在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。 如果是 private 方法、static 方法、final 方法或者构造器，编译器可以准确知道应该调用哪个方法，此种调用方式称为静态绑定（static binding）。  抽象类  包含一个或多个抽象方法的类本身必须被声明为抽象的（abstract）。  除了抽象方法，抽象类还可以包含具体数据和具体方法。 扩展抽象类有两种选择：  一是部分实现抽象方法，此时子类仍需标记为抽象类； 二是定义全部抽象方法。   类即使不包含抽象方法，也可以将类声明为抽象类。 抽象类不能被实例化。    访问控制   仅对本类可见—— private","title":"【Java 核心笔记】04.01. 继承与多态、重写Object类方法"},{"content":"Unix 历史  1969年以前：伟大的梦想——Bell, MIT 与 GE 的「Multics」系统 1969年：Ken Thompson 的小型 file server system 1973年：Unix 正式诞生（Ritchie等人以 C 语言写出第一个正式 Unix核心） 1977年：重要的 Unix 分支——BSD 的诞生 1979年：重要的 System V 架构（支持x86）与版权宣告 1984年之一：x86 架构的 Minix 操作系统开始编写并于两年后诞生 1984年之二：GNU 计划与 FSF(Free Software Foundation) 基金会的成立 1988年：图形界面 XFree86(X Window System + Free + x86) 计划 1991年：芬兰大学生 Linux Torvalds 的一则简讯  Linux 的核心版本 2.6.18-92.el5 主版本.次版本.释出版本-修改版本 核心被分为两个分支：\n 主、次版本为奇数：发展中版本(development)  如2.5.xx，这种核心版本主要用在测试与发展新功能，所以通常这种版本仅有核心开发工程师会使用。 如果有新增的核心程序代码，会加到这种版本当中，等到众多工程师测试没问题后，才加入下一版的稳定核心中；   主、次版本为偶数：稳定版本(stable)  如2.6.xx，等到核心功能发展成熟后会加到这类的版本中，主要用在一般家庭计算机以及企业版本中。 重点在于提供使用者一个相对稳定的Linux作业环境平台。    Linux 是一个操作系统最底层的核心以及其提供的核心工具。他是 GNU GPL 授权模式，所以，任何人均可取得源代码，并且可以修改。\n此外，因为 Linux 参考 POSIX 设计规范，于是兼容于 Unix 操作系统，故亦可称之为 Unix Like 的一种。\n关于开源 Open source 的代表授权为 GNU 的 GPL 授权及 BSD 等等，底下列出知名的 Open Source 授权网页：\n  GNU General Public License：http://www.gnu.org/licenses/licenses.html#GPL\n 目前有version 2, version 3两种版本，Linux使用的是version 2这一版。    Berkeley Software Distribution (BSD)：http://en.wikipedia.org/wiki/BSD_license\n  Apache License, Version 2.0：http://www.apache.org/licenses/LICENSE-2.0\n  关于闭源 免费的专利软件代表的授权模式有：\n  Freeware： http://en.wikipedia.org/wiki/Freeware 不同于 Free software，Freeware为『免费软件』而非『自由软件！』\n  Shareware： http://en.wikipedia.org/wiki/Shareware 与免费软件有点类似的是，Shareware在使用初期，它也是免费的，但是，到了所谓的『试用期限』之后，你就必须要选择『付费后继续使用』或者『将它移除』。 通常，这些共享件都会自行撰写失效程序，让你在试用期限之后就无法使用该软件。\n  ","permalink":"https://hiwangzi.com/posts/2017/10/02/vbird-linux-02/","summary":"Unix 历史  1969年以前：伟大的梦想——Bell, MIT 与 GE 的「Multics」系统 1969年：Ken Thompson 的小型 file server system 1973年：Unix 正式诞生（Ritchie等人以 C 语言写出第一个正式 Unix核心） 1977年：重要的 Unix 分支——BSD 的诞生 1979年：重要的 System V 架构（支持x86）与版权宣告 1984年之一：x86 架构的 Minix 操作系统开始编写并于两年后诞生 1984年之二：GNU 计划与 FSF(Free Software Foundation) 基金会的成立 1988年：图形界面 XFree86(X Window System + Free + x86) 计划 1991年：芬兰大学生 Linux Torvalds 的一则简讯  Linux 的核心版本 2.6.18-92.el5 主版本.次版本.释出版本-修改版本 核心被分为两个分支：\n 主、次版本为奇数：发展中版本(development)  如2.5.xx，这种核心版本主要用在测试与发展新功能，所以通常这种版本仅有核心开发工程师会使用。 如果有新增的核心程序代码，会加到这种版本当中，等到众多工程师测试没问题后，才加入下一版的稳定核心中；   主、次版本为偶数：稳定版本(stable)  如2.6.xx，等到核心功能发展成熟后会加到这类的版本中，主要用在一般家庭计算机以及企业版本中。 重点在于提供使用者一个相对稳定的Linux作业环境平台。    Linux 是一个操作系统最底层的核心以及其提供的核心工具。他是 GNU GPL 授权模式，所以，任何人均可取得源代码，并且可以修改。","title":"《鸟哥的Linux私房菜》笔记——02. 关于Linux"},{"content":" 计算机的五大部分：输入单元、输出单元、CPU（控制单元(Control Unit)、算数逻辑单元(ALU)）、内存。   CPU 的架构\n 精简指令集（Reduced Instruction Set Computing, RISC），例如：SPARC，ARM 复杂指令集（Complex Instruction Set Computing, RISC），例如：Intel/AMD x86 架构    CPU\n 外频：CPU 与外部组件进行数据传输时的速度 内频：CPU 内部用来加速工作性能的一个倍数  注：\n 两者相乘为 CPU 的频率速度 超频：将CPU的倍频或外频更改为更高，但倍频通常被锁定，经常被修改的是外频。    主板芯片组\n 北桥：系统总线（速度相对较快），内存传输的主要信道 南桥：I/O 总线，连接硬盘、USB、网卡等设备  注：\n 北桥所支持的频率称为前端总线速度（Front Side Bus, FSB），而每次传送的位数则是总线宽度。    CPU 每次能够处理的数据量称为字组大小（word size）\n 计算机被称为“32位”或“64位”的主要依据 早期“32位”的CPU中，因为CPU每次能够解析的数据量有限，因此由内存传来的数据量就有所限制，即导致了“32位”CPU最多只能支持到4GB内存    内存主要组件 动态随机访问内存（Dynamic Random Access Memory, DRAM）\n CPU 内部第二层缓存（L2 Cache）使用静态随机访问内存（Static Random Access Memory, SRAM）    计算机的分类\n 超级计算机（Super Computer） 大型计算机（Mainframe Computer） 迷你计算机（Mini Computer） 工作站（Workstation） 微型计算机（Micro Computer）    计算机常用的计量单位\n 容量一般采用二进制，速度一般采用十进制    进位制 kilo mega giga tera peta exa zetta     binary 1024 1024K 1024M 1024G 1024T 1024P 1024E   decimal 1000 1000K 1000M 1000G 1000T 1000P 1000E        磁盘 ——图自 簇 - 维基百科，自由的百科全书 磁盘分割格式：\n MBR：主引导记录（Master Boot Record） GPT：GUID磁盘分割表（GUID Partition Table），全局唯一标识磁盘分区表     操作系统  操作系统的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。  内核（Kernel）的功能：  系统调用接口（System call interface） 程序管理（Process control） 内存管理（Memory management） 文件系统管理（Filesystem management） 设备驱动（Device driver）      ","permalink":"https://hiwangzi.com/posts/2017/10/02/vbird-linux-01/","summary":"计算机的五大部分：输入单元、输出单元、CPU（控制单元(Control Unit)、算数逻辑单元(ALU)）、内存。   CPU 的架构\n 精简指令集（Reduced Instruction Set Computing, RISC），例如：SPARC，ARM 复杂指令集（Complex Instruction Set Computing, RISC），例如：Intel/AMD x86 架构    CPU\n 外频：CPU 与外部组件进行数据传输时的速度 内频：CPU 内部用来加速工作性能的一个倍数  注：\n 两者相乘为 CPU 的频率速度 超频：将CPU的倍频或外频更改为更高，但倍频通常被锁定，经常被修改的是外频。    主板芯片组\n 北桥：系统总线（速度相对较快），内存传输的主要信道 南桥：I/O 总线，连接硬盘、USB、网卡等设备  注：\n 北桥所支持的频率称为前端总线速度（Front Side Bus, FSB），而每次传送的位数则是总线宽度。    CPU 每次能够处理的数据量称为字组大小（word size）\n 计算机被称为“32位”或“64位”的主要依据 早期“32位”的CPU中，因为CPU每次能够解析的数据量有限，因此由内存传来的数据量就有所限制，即导致了“32位”CPU最多只能支持到4GB内存    内存主要组件 动态随机访问内存（Dynamic Random Access Memory, DRAM）\n CPU 内部第二层缓存（L2 Cache）使用静态随机访问内存（Static Random Access Memory, SRAM）    计算机的分类","title":"《鸟哥的Linux私房菜》笔记——01. 计算机概论"},{"content":"面向对象的三大特征  封装（Encapsulation）：对外部不可见 继承（Inheritance）：扩展类的功能 多态（Polymorphism）：一个对象变量可以指示多种实际类型的现象被称为多态  关于重载（Overload）、重写（Override）、多态   重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，但是考虑到程序设计的一致性，重载时尽量保证方法的返回值类型相同。\n  重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。即外壳不变，核心重写。\n   区别点 重载方法 重写方法     参数列表 必须修改 一定不能修改   返回类型 可以修改，但最好相同 可以有可协变的返回类型   异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常   访问 可以修改 一定不能做更严格的限制（可以降低限制）     参考 http://www.runoob.com/java/java-override-overload.html\n   关于重写（Override）的返回类型：\n 返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。 例如，假设Employee类有public Employee getBuddy() {}，在子类Manager中，可以按照 public Manager getBuddy() {} 方式覆盖这个方法。这样就可以说，这两个 getBuddy() 方法就有可协变的返回类型。    多态是同一个行为具有多个不同表现形式或形态的能力。\n 多态的三个必要条件：  继承 重写 父类引用指向子类对象      内存划分：对象创建之初   类属于引用传递类型，同样存在着“栈内存-堆内存”的引用关系\nPerson per = new Person();  声明对象：Person per，栈内存中保存对象名，只开辟了栈内存的对象是无法使用的，必须有堆内存的引用才可以使用。 实例化对象：new Person()，在堆中开辟空间，所有的内容都是默认值。    进一步拆分上面一行代码，可以用如下形式：\nPerson per = null; // 声明对象 per = new Person(); // 实例化对象   引用传递  引用保存在栈内存 属性保存在堆内存 方法保存在全局代码区（此区域中的内容是所有对象共享的）  注意：对象间的引用传递，实际上传递的就是堆内存空间的使用权。\n垃圾产生与回收（GC） ","permalink":"https://hiwangzi.com/posts/2017/09/27/core-java-04/","summary":"面向对象的三大特征  封装（Encapsulation）：对外部不可见 继承（Inheritance）：扩展类的功能 多态（Polymorphism）：一个对象变量可以指示多种实际类型的现象被称为多态  关于重载（Overload）、重写（Override）、多态   重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同，但是考虑到程序设计的一致性，重载时尽量保证方法的返回值类型相同。\n  重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。即外壳不变，核心重写。\n   区别点 重载方法 重写方法     参数列表 必须修改 一定不能修改   返回类型 可以修改，但最好相同 可以有可协变的返回类型   异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常   访问 可以修改 一定不能做更严格的限制（可以降低限制）     参考 http://www.runoob.com/java/java-override-overload.html\n   关于重写（Override）的返回类型：\n 返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。 例如，假设Employee类有public Employee getBuddy() {}，在子类Manager中，可以按照 public Manager getBuddy() {} 方式覆盖这个方法。这样就可以说，这两个 getBuddy() 方法就有可协变的返回类型。    多态是同一个行为具有多个不同表现形式或形态的能力。\n 多态的三个必要条件：  继承 重写 父类引用指向子类对象      内存划分：对象创建之初   类属于引用传递类型，同样存在着“栈内存-堆内存”的引用关系","title":"【Java 核心笔记】04. 面向对象"},{"content":"泛型数组列表   ArrayList 是一个采用类型参数（type parameter）的泛型类（generic class）。\nArrayList\u0026lt;Employee\u0026gt; staff = new ArrayList\u0026lt;Employee\u0026gt;(); ArrayList\u0026lt;Employee\u0026gt; staff = new ArrayList\u0026lt;\u0026gt;(); // JavaSE 7 之后可以简写   JavaSE 5.0 以前的版本没有提供泛型类，而是有一个 ArrayList 类，其中保存类型为 Object 的元素。\n  如果已经清楚或者能够估计数组可能的存储元素数量，就可以在填充数组之前调用 ensureCapacity 方法\nstaff.ensureCapacity(100); ArrayList\u0026lt;Employee\u0026gt; staff = new ArrayList\u0026lt;\u0026gt;(100); // 或者在构造时就传入初始容量（超过100个之后自动扩展） 这样做可以预先分配100个内存空间，而不用在每次 add 的时候再去分配。\n  一旦可以确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法，其可以将存储区域的大小调整为当前元素数量所需要的存储空间数目，垃圾回收器将回收多余的存储空间。但要注意，在整理了存储空间大小之后，添加新元素就需要再次花费时间移动存储块。\n  常用方法\n boolean add(E obj) // 在数组列表尾端添加一个元素，永远返回 true void add(int index, E obj) void set(int index, E obj) // 替换已经存在的元素内容 E get(int index) E remove(int index) // 删除一个元素，并返回这个被删除的元素 int size() // 返回数组列表中当前元素数量    对象包装器与自动装箱  所有的基本类型都有一个与之对应的类。这些类称为包装器（wrapper）。  Integer, Long, Float, Double, Short, Byte, Character, Void, Boolean（前6个类派生于公共的超类Number） 对象包装器类是不可变的（一旦构造了包装器，就不允许更改包装在其中的值）（个人认为类似 String） 对象包装器类是 final。    自动装箱 // 下面这个调用 list.add(3); // 将自动地变换为 list.add(Integer.valueOf(3)); 自动拆箱 // 编译器会将下面这个调用 int n = list.get(i); // 翻译成 int n = list.get(i).intValue();  注意，对于包装类，不要使用 == ，要使用 equals 进行比较。 如果一个条件表达式中混合使用 Integer 和 Double 类型，Integer 值就会拆箱，提升为 double，然后再装箱为 Double。 Integer i = 1; Double d = 2.0; System.out.println(true ? i : x); // 结果是 1.0  装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。而虚拟机只是执行这些字节码。  ","permalink":"https://hiwangzi.com/posts/2017/09/27/core-java-03-01/","summary":"泛型数组列表   ArrayList 是一个采用类型参数（type parameter）的泛型类（generic class）。\nArrayList\u0026lt;Employee\u0026gt; staff = new ArrayList\u0026lt;Employee\u0026gt;(); ArrayList\u0026lt;Employee\u0026gt; staff = new ArrayList\u0026lt;\u0026gt;(); // JavaSE 7 之后可以简写   JavaSE 5.0 以前的版本没有提供泛型类，而是有一个 ArrayList 类，其中保存类型为 Object 的元素。\n  如果已经清楚或者能够估计数组可能的存储元素数量，就可以在填充数组之前调用 ensureCapacity 方法\nstaff.ensureCapacity(100); ArrayList\u0026lt;Employee\u0026gt; staff = new ArrayList\u0026lt;\u0026gt;(100); // 或者在构造时就传入初始容量（超过100个之后自动扩展） 这样做可以预先分配100个内存空间，而不用在每次 add 的时候再去分配。\n  一旦可以确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法，其可以将存储区域的大小调整为当前元素数量所需要的存储空间数目，垃圾回收器将回收多余的存储空间。但要注意，在整理了存储空间大小之后，添加新元素就需要再次花费时间移动存储块。\n  常用方法\n boolean add(E obj) // 在数组列表尾端添加一个元素，永远返回 true void add(int index, E obj) void set(int index, E obj) // 替换已经存在的元素内容 E get(int index) E remove(int index) // 删除一个元素，并返回这个被删除的元素 int size() // 返回数组列表中当前元素数量    对象包装器与自动装箱  所有的基本类型都有一个与之对应的类。这些类称为包装器（wrapper）。  Integer, Long, Float, Double, Short, Byte, Character, Void, Boolean（前6个类派生于公共的超类Number） 对象包装器类是不可变的（一旦构造了包装器，就不允许更改包装在其中的值）（个人认为类似 String） 对象包装器类是 final。    自动装箱 // 下面这个调用 list.","title":"【Java 核心笔记】03.01 泛型数组、包装类"},{"content":"数组的定义及使用 声明及开辟数组空间   声明数组\nint score [] = null; // null表示引用数据类型的默认值 int [] score = null; // 与上一句等价   为数组开辟空间\n   补充：堆栈内存解释  数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是无法使用的，必须有指向的堆内存才可以使用； 要想开辟新的堆内存，则必须使用 new 关键字，之后只是将此内存的使用权交给了对应的栈内存空间，而且一个堆内存可以被多个栈内存空间指向。    数组的静态初始化 一维数组 int score[] = {1,2,3,4,5}; 二维数组   声明之后再赋值\nint arr[][] = new int[4][3]; // 声明并实例化二维数组 arr[0][0] = 201604; arr[0][1] = 1; arr[1][1] = 11; arr[2][2] = 22; arr[3][1] = 31;   声明同时赋值\n// 每行的数组元素个数不一样，分配空间不同 public class ArrayDemo { public static void main(String args[]){ int score[][] = { {67,61},{78,89,83},{99,100,98,66,95} }; for(int i=0; i\u0026lt;score.length; i++){ for(int j=0; j\u0026lt;score[i].length; j++){ System.out.print(score[i][j] + \u0026#34;\\t\u0026#34;); } System.out.println(\u0026#34;\u0026#34;); } } };   数组的传递引用  Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。  要点  数组引用传递的是 堆内存 的使用权，可以将数组传递到方法之中，传递时不需要写 []，直接写数组名。 方法中对数组的修改都会保留下来。 Java 提供了一些对数组进行操作的方法，例如数组排序，数组拷贝。  接收和返回数组 一个方法可以接收一个数组，也可以返回一个数组。\n 接收数组：如果方法接收一个数组的话，则在此方法中对数组做的操作都将被保留下来。 返回数组：方法除了可以接受数组之外，也可以通过方法返回一个数组，只需要在返回值类型上，明确的声明出返回的类型是数组即可。  应用举例 1. 数组排序  冒泡排序算法的运作如下：\na. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\nb. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\nc. 针对所有的元素重复以上的步骤，除了最后一个。\nd. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n参考：冒泡排序\n // 标准冒泡排序法 public static void sort(int temp[]) { for (int i = 0; i \u0026lt; temp.length - 1; i++) { for (int j = 0; j \u0026lt; temp.length - 1 - i; j++) { if (temp[j] \u0026gt; temp[j + 1]) { int t = temp[j]; temp[j] = temp[j + 1]; temp[j + 1] = t; } } } } // 助记码 // 参考 https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F#JAVA i∈[0,N-1) //循环N-1遍  j∈[0,N-1-i) //每遍循环要处理的无序部分  swap(j,j+1) //两两排序（升序/降序）  // Java 本身也提供了数组排序的方法（不局限于 int 数组） int score[]={67,89,87,69,90,100,75,90}; // 定义整型数组 java.util.Arrays.sort(score); // 数组排序 2. 数组拷贝 public class Test { public static void main(String args[]) { int i1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; // 源数组  int i2[] = {11, 22, 33, 44, 55, 66, 77, 88, 99}; // 目标数组  copy(i1, 3, i2, 1, 3); // 调用拷贝方法(正常拷贝)  //copy(i1,0,i2,8,2); // 数组越界调用  //System.arraycopy(i1,0,i2,8,2); // 系统提供的方法，同上数组越界调用  print(i2); } // 源数组名称，源数组开始点，目标数组名称，目标数组开始点，拷贝长度  public static void copy(int s[], int s1, int o[], int s2, int len) { for (int i = 0; i \u0026lt; len; i++) { o[s2 + i] = s[s1 + i]; // 进行拷贝操作  } } public static void print(int temp[]) { // 输出数组内容  for (int i = 0; i \u0026lt; temp.length; i++) { System.out.print(temp[i] + \u0026#34;\\t\u0026#34;); } } } 3. 使用方法交换变量值  Java 总是采用「按值调用(call by value)」，即方法得到的是参数值的一个拷贝。  public class Swap { public static void main(String[] args) { int a[] = {1}; int b[] = {2}; System.out.println(\u0026#34;Swap 1:\u0026#34;); System.out.println(\u0026#34;--Before: \u0026#34; + a[0] + \u0026#34;, \u0026#34; + b[0]); Swap1(a, b); System.out.println(\u0026#34;--After: \u0026#34; + a[0] + \u0026#34;, \u0026#34; + b[0] + \u0026#34;\\n\u0026#34;); a[0] = 1; b[0] = 2; System.out.println(\u0026#34;Swap 2:\u0026#34;); System.out.println(\u0026#34;--Before: \u0026#34; + a[0] + \u0026#34;, \u0026#34; + b[0]); Swap2(a, b); System.out.println(\u0026#34;--After: \u0026#34; + a[0] + \u0026#34;, \u0026#34; + b[0]); } /*使用数组实现交换数值*/ /*改变的是对应的堆空间里面的值*/ public static void Swap1(int num1[], int num2[]) { int temp = num1[0]; num1[0] = num2[0]; num2[0] = temp; } /*改变（交换）的只是num1与num2对堆空间值的引用*/ /*a与b对堆内存的引用并没有改变*/ public static void Swap2(int num1[], int num2[]) { int temp[]; temp = num1; num1 = num2; num2 = temp; } } 可变参数 即方法中，可以接收的参数不再是固定的，而是随着需要传递。\n格式如下：\n返回值类型 方法名称(类型 … 参数名称) { //函数体 } 例子：\npublic class Demo { public static void main(String args[]) { System.out.print(\u0026#34;不传递参数（fun()）：\u0026#34;); fun(); // 不传递参数  System.out.print(\u0026#34;\\n传递一个参数（fun(1)）：\u0026#34;); fun(1); // 传递一个参数  System.out.print(\u0026#34;\\n传递五个参数（fun(1,2,3,4,5)）：\u0026#34;); fun(1, 2, 3, 4, 5); } public static void fun(int... arg) { // 可变参数  for (int i = 0; i \u0026lt; arg.length; i++) { // 循环输出  System.out.print(arg[i] + \u0026#34; \u0026#34;); } } // 输出：  // 不传递参数（fun()）：  // 传递一个参数（fun(1)）：1  // 传递五个参数（fun(1,2,3,4,5)）：1 2 3 4 5 } foreach 数组的输出，一般都会使用 for 循环输出。在 JDK 1.5 之后，提出一种 foreach 语法。 格式如下：\nfor(数据类型 变量名称:数组名称){ //函数体 } 例子：\npublic class Demo { public static void main(String args[]) { System.out.print(\u0026#34;不传递参数（fun()）：\u0026#34;); fun(); // 不传递参数  System.out.print(\u0026#34;\\n传递一个参数（fun(1)）：\u0026#34;); fun(1); // 传递一个参数  System.out.print(\u0026#34;\\n传递五个参数（fun(1,2,3,4,5)）：\u0026#34;); fun(1, 2, 3, 4, 5); } public static void fun(int... args) { // 可变参数  for (int arg : args) { // 使用foreach输出输出  System.out.print(arg + \u0026#34; \u0026#34;); } } } ","permalink":"https://hiwangzi.com/posts/2017/09/27/core-java-03/","summary":"数组的定义及使用 声明及开辟数组空间   声明数组\nint score [] = null; // null表示引用数据类型的默认值 int [] score = null; // 与上一句等价   为数组开辟空间\n   补充：堆栈内存解释  数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是无法使用的，必须有指向的堆内存才可以使用； 要想开辟新的堆内存，则必须使用 new 关键字，之后只是将此内存的使用权交给了对应的栈内存空间，而且一个堆内存可以被多个栈内存空间指向。    数组的静态初始化 一维数组 int score[] = {1,2,3,4,5}; 二维数组   声明之后再赋值\nint arr[][] = new int[4][3]; // 声明并实例化二维数组 arr[0][0] = 201604; arr[0][1] = 1; arr[1][1] = 11; arr[2][2] = 22; arr[3][1] = 31;   声明同时赋值\n// 每行的数组元素个数不一样，分配空间不同 public class ArrayDemo { public static void main(String args[]){ int score[][] = { {67,61},{78,89,83},{99,100,98,66,95} }; for(int i=0; i\u0026lt;score.","title":"【Java 核心笔记】03. 关于数组"},{"content":"数据类型 概述 注意：\n 在 Java 中，小数默认类型为 double，整数默认类型是 int 基本数据类型的默认值（开发中尽可能为每一个变量赋初值）    类型 默认值     byte (byte) 0   short (short) 0   int 0   long 0L   float 0.0f   double 0.0d   char \\u0000   boolean false      基本数据类型 整型 注意：Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。 不同进制的表示形式：\n 十六进制数值有一个前缀 0x 或 0X（如0xCAFE）。 八进制有一个前缀 0，例如，010 对应十进制中的 8 。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。 从Java 7开始，加上前缀 0b 或 0B 就可以写二进制数。例如， 0b1001 就是 9 。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用（1_000_000 或 0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。  浮点类型 可以使用十六进制表示浮点数值。例如，0.125=2^(-3)可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e。 注意，底数采用十六进制，指数采用十进制。指数的基数是2，而不是10。 所有浮点数的计算都遵循 IEEE754 规范。表示溢出和出错情况的三个特殊的浮点数值：\n 正无穷大（Double.POSITIVE_INFINITY） 负无穷大（Double.NEGATIVE_INFINITY） NaN（不是一个数字，Double.NaN）  判断是否是“非数值” if((Double.isNaN(x)) //check whether x is \u0026quot;not a number\u0026quot;\nIEEE 754 浮点数值不适用于无法接受舍入误差的金融计算中。例如，命令System.out.println(2.0-1.1) 将打印出 0.8999999999999999，而不是人们想象的 0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数 1/10。这就好像十进制无法精确地表示分数 1/3 一样。如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal 类。\nchar 类型 char 类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些 Unicode 字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值。\n📒 关于字符编码更多内容请参考《Unicode 笔记》。\nchar 类型的值可以表示为十六进制值，其范围从 \\u0000 到 \\uFFFF。 除了转义序列 \\u 之外，还有一些用于表示特殊字符的转义序列，请参看表3-3。\n 所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，'\\u2122' 或 \u0026quot;Hello\\n\u0026quot;。 转义序列 \\u 还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以）。例如：public static void main(String\\u0058\\u005D args) 是符合语法规则的，因为 \\u0058 \\u005D 分别表示 [ ]。  Unicode转义序列会在 解析代码之前 得到处理。例如， \u0026quot;\\u0022+\\u0022\u0026quot; 并不是一个由引号(U+0022)包围加号构成的字符串。实际上，\\u0022 会在解析之前转换为 \u0026quot;，这会得到 \u0026quot;\u0026quot;+\u0026quot;\u0026quot;，也就是一个空串。 更隐秘地，一定要当心注释中的 \\u。注释 // \\u00A0 is a newline 会产生一个语法错误，因为读程序时 \\u00A0 会替换为一个换行符。类似地，下面这个注释 // look inside c:\\users 也会产生一个语法错误，因为 \\u 后面并未跟着4个十六进制数。    boolean类型 整型值 和 布尔值 之间不能相互转换。\n基本数据类型的转换 自动转换 条件（需要2个同时满足）：\n 转换前的数据类型与转换后的数据类型兼容 转换后的数据类型的表示范围比转换前的大  补充：任何类型的数据都可向 String 类型转换。例：\nSystem.out.println( \u0026#34;1 + 2 = \u0026#34; + 1 + 2 ); System.out.println( \u0026#34;1 + 2 = \u0026#34; + ( 1 + 2 ) ); // 输出 // 1 + 2 = 12 // 1 + 2 = 3 注：虚线箭头可能有精度的损失\n强制转换 // (欲转换的类型) 变量名称 double x = 9.997; int nx = (int) x; // 变量nx的值为9。强制类型转换通过截断小数部分将浮点值转换为整型。   如果想对浮点数进行舍入运算，以便得到最接近的整数（在很多情况下，这种操作更有用），那就需要使用Math.round方法：\ndouble x = 9.997; int nx = (int) Math.round(x); // 现在，变量 nx 的值为10。当调用 round 的时候，仍然需要使用强制类型转换（int）。其原因是round 方法返回的结果为 long 类型，由于存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将 long 类型转换成 int 类型。   复合数据类型 枚举类型 例： 枚举类型 Size 的声明：\nenum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE }; 声明 Size 类型变量：Size s = Size.MEDIUM;\n注意：Size 类型的变量只能存储这个类型声明中给定的某个枚举值，或者 null 值。\n补充：\n 跟类定义一样，枚举类型可以单独放在一个文件里，当一个枚举类型用 public 修饰时，它对其他包可见，否则只对同一个包中的类可见，这和类定义是一样的。\n标识符 SMALL, MEDIUM 等就称为枚举常量（enumeration constants）\n每一个枚举常量被隐式的声明成 Day 的一个 public 、 static 成员，而且其类型为 Size ，亦就是说这些常量是 self-typed 的\n参考：Java 里有枚举类型吗？如何定义？\n 字符串  字符串是不可变的 使用equals()方法比较字符串内容  如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等。但实际上只有字符串常量是共享的，而 + 或 .substring(parm) 等操作产生的结果并不是共享的。因此，千万不要使用 == 运算符测试字符串的相等性，以免在程序中出现糟糕的 bug。从表面上看，这种 bug 很像随机产生的间歇性错误。   空串：str.length() == 0 或 str.equals(\u0026quot;\u0026quot;) Null串：str == null  length 方法  Java 语言里 String 在内存中以是 UTF-16 方式编码 \u0026quot;\u0026quot;.length()：The length is equal to the number of Unicode code units in the string. 因此，实际length方法在Java中返回的是UTF-16的代码单元数目。 BMP内的字符转义\\uXXXX即可（Unicode转义序列会在解析代码之前得到处理） 增补平面内的字符转义写成 UTF-16 的代理对形式，例：U+1D11E写作\\uD834\\uDD1E，虽然是一个字符，但其.length()结果为2 若想得到非BMP的字符数，可以使用codePointCount方法。  getBytes 方法  .getBytes() 不过是把「一种编码」的字节数组转换成「另一种编码」的字节数组。  这里的「一种编码」在 Java 中就是 UTF-16。 这里的「另一种编码」则由调用者来指定，不指定就用缺省（JVM的默认编码，JVM启动时如果没有明确指定，则默认使用操作系统的缺省编码）。    运算符 逻辑运算符    名称 符号     逻辑非 !   逻辑与 \u0026amp;   逻辑或 |   短路与 \u0026amp;\u0026amp;   短路或 ||   异或 ^    例：「短路与」示例 （若使用“与”，则会报错(10/0)，使用「短路与」则可以正常运行）\npublic class Demo{ public static void main(String[] args){ int n = 10, m = 2; boolean k = false; if(n != 10 \u0026amp;\u0026amp; 10/0 == 9){ System.out.println(!k); } else{ System.out.println(k); } } } 位运算符 \u0026amp; (\u0026quot;and\u0026quot;) | (\u0026quot;or\u0026quot;) ^ (\u0026quot;xor\u0026quot;) ~ (\u0026quot;not\u0026quot;) \u0026lt;\u0026lt; 左移 \u0026gt;\u0026gt; 右移（用符号位填充高位） \u0026gt;\u0026gt;\u0026gt; (用0填充高位) 运算符优先级 ","permalink":"https://hiwangzi.com/posts/2017/09/27/core-java-02/","summary":"数据类型 概述 注意：\n 在 Java 中，小数默认类型为 double，整数默认类型是 int 基本数据类型的默认值（开发中尽可能为每一个变量赋初值）    类型 默认值     byte (byte) 0   short (short) 0   int 0   long 0L   float 0.0f   double 0.0d   char \\u0000   boolean false      基本数据类型 整型 注意：Java 没有任何无符号（unsigned）形式的 int、long、short 或 byte 类型。 不同进制的表示形式：\n 十六进制数值有一个前缀 0x 或 0X（如0xCAFE）。 八进制有一个前缀 0，例如，010 对应十进制中的 8 。很显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。 从Java 7开始，加上前缀 0b 或 0B 就可以写二进制数。例如， 0b1001 就是 9 。另外，同样是从 Java 7 开始，还可以为数字字面量加下划线，如用（1_000_000 或 0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。  浮点类型 可以使用十六进制表示浮点数值。例如，0.","title":"【Java 核心笔记】02. 数据类型与运算符"},{"content":"「白皮书」关键术语  简单性 C++\u0026ndash; 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性  Java 发展历程  SUN公司——Stanford University Network 主设计者：James Gosling 1996年初 - 发布 Java 1.0 Java 2, JDK 1.2 有了很大的改变 - 更加接近“一次编写，随处运行”的承诺 J2SE 5.0 得到了进一步改进 - 泛型、(以下几项受 C# 启发) foreach、自动装箱、注解 2014年 - 发布 Java 8 - 重大改变：提供了一种「函数式」编程方式，可以容易地表述并发执行的计算  Java 主要技术分支  Java SE Java 2 Platform, Standard Edition 前身：J2SE，2005年更名为Java SE Java EE（主要应用） Java 2 Platform, Enterprise Edition 前身：J2EE，2005年更名为Java EE Java ME（嵌入式） Java 2 Platform, Micro Edition 前身：J2ME，2005年更名为Java ME  JVM, JRE, JDK  JVM(Java Virtual Machine) \u0026lt; JRE(Java Runtime Environment) \u0026lt; JDK(Java Development Kit)  “跨平台” 与 “解释执行”  早期的 Java是解释型的。现在 Java 虚拟机使用了即时编译器，因此采用 Java 编写的“热点”代码其运行速度与 C++ 相差无几，有些情况下甚至更快。  Java 开发环境  Path 的主要功能是设置 JDK 的可执行命令 classpath 主要是在执行的时候起作用，告诉JVM类的保存路径，一般（默认）设置为.（cmd设置命令：set classpath=.）   注意：classpath 只在 java 命令时起作用，对 javac 无作用  一些术语  当Oracle为解决一些紧急问题做出某些微小的版本改变时，将其称为更新。例如：Java SE 8u31是Java SE 8的第31次更新，它的内部版本号是1.8.0_31。更新不需要安装在前一个版本上，它会包含整个JDK的最新版本。  ","permalink":"https://hiwangzi.com/posts/2017/09/27/core-java-01/","summary":"「白皮书」关键术语  简单性 C++\u0026ndash; 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性  Java 发展历程  SUN公司——Stanford University Network 主设计者：James Gosling 1996年初 - 发布 Java 1.0 Java 2, JDK 1.2 有了很大的改变 - 更加接近“一次编写，随处运行”的承诺 J2SE 5.0 得到了进一步改进 - 泛型、(以下几项受 C# 启发) foreach、自动装箱、注解 2014年 - 发布 Java 8 - 重大改变：提供了一种「函数式」编程方式，可以容易地表述并发执行的计算  Java 主要技术分支  Java SE Java 2 Platform, Standard Edition 前身：J2SE，2005年更名为Java SE Java EE（主要应用） Java 2 Platform, Enterprise Edition 前身：J2EE，2005年更名为Java EE Java ME（嵌入式） Java 2 Platform, Micro Edition 前身：J2ME，2005年更名为Java ME  JVM, JRE, JDK  JVM(Java Virtual Machine) \u0026lt; JRE(Java Runtime Environment) \u0026lt; JDK(Java Development Kit)  “跨平台” 与 “解释执行”  早期的 Java是解释型的。现在 Java 虚拟机使用了即时编译器，因此采用 Java 编写的“热点”代码其运行速度与 C++ 相差无几，有些情况下甚至更快。  Java 开发环境  Path 的主要功能是设置 JDK 的可执行命令 classpath 主要是在执行的时候起作用，告诉JVM类的保存路径，一般（默认）设置为.","title":"【Java 核心笔记】01. Java介绍"},{"content":"1. 通过命令提示符（cmd）命令连接 Wi-Fi 1.1 连接曾经连接过的 Wi-Fi :: 查看配置的列表（::表示注释） netsh wlan show profile :: 连接 netsh wlan connect ssid=你的SSID名字(简单可以理解为Wi-Fi名) name=你的配置名字 1.2 连接从未连接过的 Wi-Fi :: 先增加一项 Wi-Fi 配置，注意要在配置文件所在目录执行 netsh wlan add profile filename=\u0026#34;你的配置.xml\u0026#34; :: 查看配置的列表，检查是否添加成功 netsh wlan show profile :: 连接 netsh wlan connect ssid=你的SSID名字 name=你的配置名字 示例配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;WLANProfile xmlns=\u0026#34;http://www.microsoft.com/networking/WLAN/profile/v1\u0026#34;\u0026gt; \u0026lt;name\u0026gt;你的配置名字（与SSID名字相同即可）\u0026lt;/name\u0026gt; \u0026lt;SSIDConfig\u0026gt; \u0026lt;SSID\u0026gt; \u0026lt;name\u0026gt;你的SSID名字\u0026lt;/name\u0026gt; \u0026lt;/SSID\u0026gt; \u0026lt;/SSIDConfig\u0026gt; \u0026lt;connectionType\u0026gt;ESS\u0026lt;/connectionType\u0026gt; \u0026lt;connectionMode\u0026gt;auto\u0026lt;/connectionMode\u0026gt; \u0026lt;MSM\u0026gt; \u0026lt;security\u0026gt; \u0026lt;authEncryption\u0026gt; \u0026lt;authentication\u0026gt;WPA2PSK\u0026lt;/authentication\u0026gt; \u0026lt;encryption\u0026gt;AES\u0026lt;/encryption\u0026gt; \u0026lt;useOneX\u0026gt;false\u0026lt;/useOneX\u0026gt; \u0026lt;/authEncryption\u0026gt; \u0026lt;sharedKey\u0026gt; \u0026lt;keyType\u0026gt;passPhrase\u0026lt;/keyType\u0026gt; \u0026lt;protected\u0026gt;false\u0026lt;/protected\u0026gt; \u0026lt;keyMaterial\u0026gt;你的WiFi密码\u0026lt;/keyMaterial\u0026gt; \u0026lt;/sharedKey\u0026gt; \u0026lt;/security\u0026gt; \u0026lt;/MSM\u0026gt; \u0026lt;MacRandomization xmlns=\u0026#34;http://www.microsoft.com/networking/WLAN/profile/v3\u0026#34;\u0026gt; \u0026lt;enableRandomization\u0026gt;false\u0026lt;/enableRandomization\u0026gt; \u0026lt;/MacRandomization\u0026gt; \u0026lt;/WLANProfile\u0026gt; 2. 查看连接过的 Wi-Fi 密码 :: 查看特定 netsh wlan show profile 配置名称 key=clear :: 查看所有 for /f \u0026#34;skip=9 tokens=1,2 delims=:\u0026#34; %i in (\u0026#39;netsh wlan show profiles\u0026#39;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 3. 查看、禁用、启用网络接口（网卡） :: 查看网络接口的列表 netsh interface show interface :: 禁用网络接口 netsh interface set interface 接口名称 disabled :: 启用网络接口 netsh interface set interface 接口名称 enabled ","permalink":"https://hiwangzi.com/posts/2017/09/04/netsh-newbie-note/","summary":"1. 通过命令提示符（cmd）命令连接 Wi-Fi 1.1 连接曾经连接过的 Wi-Fi :: 查看配置的列表（::表示注释） netsh wlan show profile :: 连接 netsh wlan connect ssid=你的SSID名字(简单可以理解为Wi-Fi名) name=你的配置名字 1.2 连接从未连接过的 Wi-Fi :: 先增加一项 Wi-Fi 配置，注意要在配置文件所在目录执行 netsh wlan add profile filename=\u0026#34;你的配置.xml\u0026#34; :: 查看配置的列表，检查是否添加成功 netsh wlan show profile :: 连接 netsh wlan connect ssid=你的SSID名字 name=你的配置名字 示例配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;WLANProfile xmlns=\u0026#34;http://www.microsoft.com/networking/WLAN/profile/v1\u0026#34;\u0026gt; \u0026lt;name\u0026gt;你的配置名字（与SSID名字相同即可）\u0026lt;/name\u0026gt; \u0026lt;SSIDConfig\u0026gt; \u0026lt;SSID\u0026gt; \u0026lt;name\u0026gt;你的SSID名字\u0026lt;/name\u0026gt; \u0026lt;/SSID\u0026gt; \u0026lt;/SSIDConfig\u0026gt; \u0026lt;connectionType\u0026gt;ESS\u0026lt;/connectionType\u0026gt; \u0026lt;connectionMode\u0026gt;auto\u0026lt;/connectionMode\u0026gt; \u0026lt;MSM\u0026gt; \u0026lt;security\u0026gt; \u0026lt;authEncryption\u0026gt; \u0026lt;authentication\u0026gt;WPA2PSK\u0026lt;/authentication\u0026gt; \u0026lt;encryption\u0026gt;AES\u0026lt;/encryption\u0026gt; \u0026lt;useOneX\u0026gt;false\u0026lt;/useOneX\u0026gt; \u0026lt;/authEncryption\u0026gt; \u0026lt;sharedKey\u0026gt; \u0026lt;keyType\u0026gt;passPhrase\u0026lt;/keyType\u0026gt; \u0026lt;protected\u0026gt;false\u0026lt;/protected\u0026gt; \u0026lt;keyMaterial\u0026gt;你的WiFi密码\u0026lt;/keyMaterial\u0026gt; \u0026lt;/sharedKey\u0026gt; \u0026lt;/security\u0026gt; \u0026lt;/MSM\u0026gt; \u0026lt;MacRandomization xmlns=\u0026#34;http://www.","title":"「cmd」与「网卡」—— netsh 命令"},{"content":"半年之前，第一次接触到这种将函数作为参数传递的做法，当时实在觉得难以理解。\nPHP 的变量真的是啥都能装，不管函数还是类，这个真的是灵活到飘逸🙈。另外，“魔术方法”哈哈哈哈哈哈哈🌞好酷哦... pic.twitter.com/nxGwbBKAEl\n\u0026mdash; Zi WANG (@zill057) March 28, 2017  直到最近再次接触到 Python，查询了一些资料，才开始对其有了一些初步的认识。\n 我们暂停一下，看看计算机中比较诡异的地方，也就是代码(code)和数据(data)的统一。这是一个槛，如果不跨过这槛，很多概念就不清楚。我们常常说计算机程序分成 code 和 data 两部分。很多人会理解成，code 是会运行的，是动态的，data 是给 code 使用，是静态的，这是两种完全不同的东西。\n回调函数（callback）是什么？ - 回答作者: 黄兢成 https://zhihu.com/question/19801131/answer/17156023\n 最开始我的认知也就如上面这个问题的答主描述的一般，但如果转变一下思维，将 code 与 data 统一视为视为信息，对于 PHP 中可以将函数作为参数传递的做法，也就可以理解了。\n 其实 code 只是对行为的一种描述，比如有个机器人可以开灯，关灯，扫地。如果跟机器人约定好，0 表示开灯，1 表示关灯，2 表示扫地。\n我发出指令串，0 1 2，就可以控制机器人开灯，关灯，扫地。再约定用二进制表示，两位一个指令，就有一个数字串，000111，这个时候 000111 这串数字就描述了机器人的一系列动作，这个就是从一方面理解是 code，它可以控制机器人的行为。\n但另一方面，它可以传递，可以记录，可以修改，也就是数据。只要大家都协商好，code 就可以编码成 data, 将 data 解释运行的时候，也变成了 code。\n 关于 code 与 data，上面的答主如是说：\n  有些语言不区分，它的 function(表示code)跟 int, double 的地位是一样的。这种语言称函数是第一类值。 有些语言是不能存储函数，不能动态创建函数，不能动态销毁函数。只能存储一个指向函数的指针，这种语言称函数是第二类值。   在 Python 中，将一切都视为对象，传递的即是函数的指针。这种做法即属于上述描述中的第二类。\n最后，发自内心的说，这个回答的内容真得值得一读。\n我要走的路还有很长，路漫漫其修远兮……\n","permalink":"https://hiwangzi.com/posts/2017/09/03/code-and-data/","summary":"半年之前，第一次接触到这种将函数作为参数传递的做法，当时实在觉得难以理解。\nPHP 的变量真的是啥都能装，不管函数还是类，这个真的是灵活到飘逸🙈。另外，“魔术方法”哈哈哈哈哈哈哈🌞好酷哦... pic.twitter.com/nxGwbBKAEl\n\u0026mdash; Zi WANG (@zill057) March 28, 2017  直到最近再次接触到 Python，查询了一些资料，才开始对其有了一些初步的认识。\n 我们暂停一下，看看计算机中比较诡异的地方，也就是代码(code)和数据(data)的统一。这是一个槛，如果不跨过这槛，很多概念就不清楚。我们常常说计算机程序分成 code 和 data 两部分。很多人会理解成，code 是会运行的，是动态的，data 是给 code 使用，是静态的，这是两种完全不同的东西。\n回调函数（callback）是什么？ - 回答作者: 黄兢成 https://zhihu.com/question/19801131/answer/17156023\n 最开始我的认知也就如上面这个问题的答主描述的一般，但如果转变一下思维，将 code 与 data 统一视为视为信息，对于 PHP 中可以将函数作为参数传递的做法，也就可以理解了。\n 其实 code 只是对行为的一种描述，比如有个机器人可以开灯，关灯，扫地。如果跟机器人约定好，0 表示开灯，1 表示关灯，2 表示扫地。\n我发出指令串，0 1 2，就可以控制机器人开灯，关灯，扫地。再约定用二进制表示，两位一个指令，就有一个数字串，000111，这个时候 000111 这串数字就描述了机器人的一系列动作，这个就是从一方面理解是 code，它可以控制机器人的行为。\n但另一方面，它可以传递，可以记录，可以修改，也就是数据。只要大家都协商好，code 就可以编码成 data, 将 data 解释运行的时候，也变成了 code。\n 关于 code 与 data，上面的答主如是说：\n  有些语言不区分，它的 function(表示code)跟 int, double 的地位是一样的。这种语言称函数是第一类值。 有些语言是不能存储函数，不能动态创建函数，不能动态销毁函数。只能存储一个指向函数的指针，这种语言称函数是第二类值。   在 Python 中，将一切都视为对象，传递的即是函数的指针。这种做法即属于上述描述中的第二类。","title":"代码与数据"},{"content":"基础  Python 的语法比较简单，采用缩进方式 以 # 开头的语句是注释 当语句以冒号 : 结尾时，缩进的语句视为代码块 没有规定缩进是几个空格还是 Tab，但按照约定俗成的惯例，应该始终坚持使用4个空格的缩进 确保不混用 Tab 和空格 Python 程序是大小写敏感的  输入输出  print() input()  数据类型  整数 浮点数  对于很大或很小的浮点数，用科学计数法表示，把10用e替代，例: 1.23x10⁹就是1.23e9, 0.000012可以写成1.2e-5   字符串  可以用r''表示''内部的字符串默认不转义   布尔值 空值  一个特殊的值，用 None 表示。   常量  变量名全大写表示常量, 事实上仍然是变量    字符串与编码 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：\n#!/usr/bin/env python3 # -*- coding: utf-8 -*-  第一行注释是为了告诉 Linux/OS X系统，这是一个 Python 可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。  格式化 \u0026gt;\u0026gt;\u0026gt; 'Hello, %s' % 'world' 'Hello, world' \u0026gt;\u0026gt;\u0026gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000) 'Hi, Michael, you have $1000000.' \u0026gt;\u0026gt;\u0026gt; '%2d-%02d' % (3, 1) ' 3-01' \u0026gt;\u0026gt;\u0026gt; '%.2f' % 3.1415926 '3.14' list, tuple 与 dict, set  list: 一种有序的集合, 可以随时添加和删除其中的元素, 函数: append(var), insert(index, var), pop(), pop(index) classmates = [\u0026#39;Michael\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Tracy\u0026#39;]  tuple: 类似于 list, 但初始化后不能修改 classmates = (\u0026#39;Michael\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Tracy\u0026#39;)  dict: 字典, 使用键-值(key-value)存储, 具有极快的查找速度, 函数: get(key), pop(key) d = {\u0026#39;Michael\u0026#39;: 95, \u0026#39;Bob\u0026#39;: 75, \u0026#39;Tracy\u0026#39;: 85}  set: 类似于 dict, 但不存储 value, 只存储 key(不可重复), 函数: add(key), remove(key) # 要创建一个set，需要提供一个list作为输入集合 s = set([1, 2, 3])   ","permalink":"https://hiwangzi.com/posts/2017/08/31/python3-newbie-note/","summary":"基础  Python 的语法比较简单，采用缩进方式 以 # 开头的语句是注释 当语句以冒号 : 结尾时，缩进的语句视为代码块 没有规定缩进是几个空格还是 Tab，但按照约定俗成的惯例，应该始终坚持使用4个空格的缩进 确保不混用 Tab 和空格 Python 程序是大小写敏感的  输入输出  print() input()  数据类型  整数 浮点数  对于很大或很小的浮点数，用科学计数法表示，把10用e替代，例: 1.23x10⁹就是1.23e9, 0.000012可以写成1.2e-5   字符串  可以用r''表示''内部的字符串默认不转义   布尔值 空值  一个特殊的值，用 None 表示。   常量  变量名全大写表示常量, 事实上仍然是变量    字符串与编码 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：\n#!/usr/bin/env python3 # -*- coding: utf-8 -*-  第一行注释是为了告诉 Linux/OS X系统，这是一个 Python 可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。  格式化 \u0026gt;\u0026gt;\u0026gt; 'Hello, %s' % 'world' 'Hello, world' \u0026gt;\u0026gt;\u0026gt; 'Hi, %s, you have $%d.","title":"Python 3 基础总结"},{"content":"我的 PC 型号是 Acer V3-572G，安装了 Debian 后，发现只能通过有线网络上网，无法识别无线网卡，以下是解决的过程(不局限于此型号 PC):\n  在命令行键入 lspci ，得到网卡型号「BCM43228」\nxox@debian-x64:~$ lspci 00:00.0 Host bridge: Intel Corporation Haswell-ULT DRAM Controller (rev 0b) 00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 0b) 00:03.0 Audio device: Intel Corporation Haswell-ULT HD Audio Controller (rev 0b) 00:14.0 USB controller: Intel Corporation 8 Series USB xHCI HC (rev 04) 00:16.0 Communication controller: Intel Corporation 8 Series HECI #0 (rev 04) 00:1b.0 Audio device: Intel Corporation 8 Series HD Audio Controller (rev 04) 00:1c.0 PCI bridge: Intel Corporation 8 Series PCI Express Root Port 3 (rev e4) 00:1c.3 PCI bridge: Intel Corporation 8 Series PCI Express Root Port 4 (rev e4) 00:1c.4 PCI bridge: Intel Corporation 8 Series PCI Express Root Port 5 (rev e4) 00:1d.0 USB controller: Intel Corporation 8 Series USB EHCI #1 (rev 04) 00:1f.0 ISA bridge: Intel Corporation 8 Series LPC Controller (rev 04) 00:1f.2 SATA controller: Intel Corporation 8 Series SATA Controller 1 [AHCI mode] (rev 04) 00:1f.3 SMBus: Intel Corporation 8 Series SMBus Controller (rev 04) 01:00.0 Unassigned class [ff00]: Realtek Semiconductor Co., Ltd. RTL8411B PCI Express Card Reader (rev 01) 01:00.1 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 12) 02:00.0 Network controller: Broadcom Limited BCM43228 802.11a/b/g/n 03:00.0 3D controller: NVIDIA Corporation GM108M [GeForce 840M] (rev a2)   使用搜索引擎得到特定型号的固件包\n  如下图，第一个搜索结果中即有相关信息 wl - Debian Wiki\n  apt-get install 安装驱动\n# apt-get update # apt-get install linux-image-$(uname -r|sed \u0026#39;s,[^-]*-[^-]*-,,\u0026#39;) linux-headers-$(uname -r|sed \u0026#39;s,[^-]*-[^-]*-,,\u0026#39;) broadcom-sta-dkms   重启即可使用无线网络\n  ","permalink":"https://hiwangzi.com/posts/2017/08/29/install-wifi-driver-for-bcm43228-in-linux/","summary":"在 Debian 下为 BCM43228 无线网卡安装驱动","title":"Debian/Linux 下无线网卡驱动的安装"},{"content":"源代码编译安装 源代码包的安装一般为下载软件源代码，然后编译安装。常见的 C 程序软件的安装步骤是 configure, make, make install 三部曲（./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install）。\n一句话来解释整个过程：\n 根据源码包中 Makefile.in 文件的指示，configure 脚本检查当前的系统环境和配置选项，在当前目录中生成 Makefile 文件(还有其它本文无需关心的文件)，然后 make 程序就按照当前目录中的 Makefile 文件的指示将源代码编译为二进制文件，最后将这些二进制文件移动(即安装)到指定的地方(仍然按照 Makefile 文件的指示)。\n 借助软件包管理器安装 例如借助 yum、apt-get 等管理软件进行安装。\n在 Ubuntu 系统上，软件包的格式是 deb，相比于「源代码编译安装」，deb 包这类的二进制包是依赖硬件和软件平台的。\n顺便提一点，apt-get只是dpkg的一个前端而已，dpkg 是Debian软件包管理器的基础。而上层的工具，像是 APT，用于从远程获取软件包以及处理复杂的软件包关系。\n二进制格式安装 编译好的文件，类似于 Windows 下的 exe，后缀一般为 bin，如 jdk 就有 bin 后缀（虽然 Linux 下没有后缀的概念，但为了好区分，一般文件名都加后缀）。安装就是先给它可执行权限，然后执行，例如：\nchmod 777 xxx.bin ./xxx.bin 总结  源代码编译安装最为灵活自由 借助包管理器最为方便 二进制格式安装方式一般被一些闭源的驱动和预编译的安装包所采用  参考  源代码包 - deepin Wiki 深入理解软件包的配置、编译与安装 在 Linux 下安装软件的方法有哪些？各有什么优劣？  ","permalink":"https://hiwangzi.com/posts/2017/08/22/how-to-install-software-for-linux/","summary":"源代码编译安装 源代码包的安装一般为下载软件源代码，然后编译安装。常见的 C 程序软件的安装步骤是 configure, make, make install 三部曲（./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install）。\n一句话来解释整个过程：\n 根据源码包中 Makefile.in 文件的指示，configure 脚本检查当前的系统环境和配置选项，在当前目录中生成 Makefile 文件(还有其它本文无需关心的文件)，然后 make 程序就按照当前目录中的 Makefile 文件的指示将源代码编译为二进制文件，最后将这些二进制文件移动(即安装)到指定的地方(仍然按照 Makefile 文件的指示)。\n 借助软件包管理器安装 例如借助 yum、apt-get 等管理软件进行安装。\n在 Ubuntu 系统上，软件包的格式是 deb，相比于「源代码编译安装」，deb 包这类的二进制包是依赖硬件和软件平台的。\n顺便提一点，apt-get只是dpkg的一个前端而已，dpkg 是Debian软件包管理器的基础。而上层的工具，像是 APT，用于从远程获取软件包以及处理复杂的软件包关系。\n二进制格式安装 编译好的文件，类似于 Windows 下的 exe，后缀一般为 bin，如 jdk 就有 bin 后缀（虽然 Linux 下没有后缀的概念，但为了好区分，一般文件名都加后缀）。安装就是先给它可执行权限，然后执行，例如：\nchmod 777 xxx.bin ./xxx.bin 总结  源代码编译安装最为灵活自由 借助包管理器最为方便 二进制格式安装方式一般被一些闭源的驱动和预编译的安装包所采用  参考  源代码包 - deepin Wiki 深入理解软件包的配置、编译与安装 在 Linux 下安装软件的方法有哪些？各有什么优劣？  ","title":"Linux 安装软件的几种方式"},{"content":"介绍 在之前的 Entity Framework 快速上手介绍 之中，两个实体之间只是简单的一对一关系，而在实际的应用场景中，还会出现多对多关系，同时还有可能会出现多对多关系还附带有其他字段的情况。\n下面以几个例子，对表间多对多关系的类表示加以更加详细地描述。虽然两个场景举例是使用的 C# 及 Entity Framework(Model First) 框架自动生成数据库、实体类。但这种设计方法，并不只是在使用 ORM 框架时需要，事实上，它是 POCO 及简单 Java 类（POJO）的设计原则之一。\n场景实例 场景一 在考虑多对多关系还附带有字段的情况之前，让我们先看一下，多对多关系但不附带额外字段的情况下，实体类代码的表示。\n此处使用 Entity Framework(Model First)，快速将 model diagram 转为数据库中的表及实体类。\n假设的场景是学生选课，一名学生可以选多门课，一门课也可以被多个学生选择。E-R 图如下所示： 对应自动生成的数据库如下：\n StudentSet  CourseSet  CourseRegistrationSet  其中 Course_Id 与 Students_Id（注：此处词尾(s)负数的原因参见上面 E-R 图中右边的 Properties 中 End1 Navigation Property 的设置）分别以另外两张数据表的 Id 主键作为外键。 同时 Course_Id 与 Students_Id 两者联合做 CourseRegistrationSet 表的主键。    对应自动生成实体类的代码如下：\n Student.cs namespace Model { using System; using System.Collections.Generic; public partial class Student { [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2214:DoNotCallOverridableMethodsInConstructors\u0026#34;)] public Student() { this.Course = new HashSet\u0026lt;Course\u0026gt;(); } public int Id { get; set; } public string 学号 { get; set; } public string 姓名 { get; set; } [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2227:CollectionPropertiesShouldBeReadOnly\u0026#34;)] public virtual ICollection\u0026lt;Course\u0026gt; Course { get; set; } } }  Course.cs namespace Model { using System; using System.Collections.Generic; public partial class Course { [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2214:DoNotCallOverridableMethodsInConstructors\u0026#34;)] public Course() { this.Students = new HashSet\u0026lt;Student\u0026gt;(); } public int Id { get; set; } public string 课程名称 { get; set; } public string 学分 { get; set; } [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2227:CollectionPropertiesShouldBeReadOnly\u0026#34;)] public virtual ICollection\u0026lt;Student\u0026gt; Students { get; set; } } }   分析  数据库表之间一对一、一对多的关系在代码中是通过 对象引用 或 对象数组/List等形式的引用 实现的。 从实例中可以看出，CourseRegistrationSet 表中的多对多关系在代码中的表现形式同样是实体类中的 对象List等形式的引用，只不过多对多关系是多个实体类中都存在其他实体类对象List的引用。  场景二 现在让我们增加一个需求，实际应用之中，数据库不可能仅仅存储某学生选了某门课程这些信息，同时还需要保存选课时间、操作人、成绩等等信息。\n现在让我们为 CourseRegistrationSet 表增加一个字段——成绩。\n CourseRegistrationSet   同时我们需要更新一下程序中的代码，这时候问题出现了🙄：两个实体类中互相存储着对方对象List的引用，成绩字段该放到哪里呢？\n此时我们换一种思路，如果将 CourseRegistrationSet 同样想象为一种特殊的实体，那么就可以实现将 Student 与 Course 关联的同时，还可以保存成绩信息。即如下图所示：\n如果你刚刚仔细阅读了 Entity Framework(Model First) 自动生成的 数据库表结构 以及 类的代码，再结合上面新的 E-R图，大概也就可以明白，应该如何在代码中表示多对多关系（附带额外字段/属性）。\n上面的场景生成的数据表结构如下：\n StudentSet  CourseSet  CourseRegistrationSet   自动生成的实体类的代码：\n Student.cs namespace Model { using System; using System.Collections.Generic; public partial class Student { [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2214:DoNotCallOverridableMethodsInConstructors\u0026#34;)] public Student() { this.CourseRegistration = new HashSet\u0026lt;CourseRegistration\u0026gt;(); } public int Id { get; set; } public string 学号 { get; set; } public string 姓名 { get; set; } [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2227:CollectionPropertiesShouldBeReadOnly\u0026#34;)] public virtual ICollection\u0026lt;CourseRegistration\u0026gt; CourseRegistration { get; set; } } }  Course.cs namespace Model { using System; using System.Collections.Generic; public partial class Course { [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2214:DoNotCallOverridableMethodsInConstructors\u0026#34;)] public Course() { this.CourseRegistration = new HashSet\u0026lt;CourseRegistration\u0026gt;(); } public int Id { get; set; } public string 课程名称 { get; set; } public string 学分 { get; set; } [System.Diagnostics.CodeAnalysis.SuppressMessage(\u0026#34;Microsoft.Usage\u0026#34;, \u0026#34;CA2227:CollectionPropertiesShouldBeReadOnly\u0026#34;)] public virtual ICollection\u0026lt;CourseRegistration\u0026gt; CourseRegistration { get; set; } } }  CourseRegistration.cs namespace Model { using System; using System.Collections.Generic; public partial class CourseRegistration { public int Id { get; set; } public string 成绩 { get; set; } public virtual Student Student { get; set; } public virtual Course Course { get; set; } } }   分析  数据库表之间多对多的关系在代码中表示需要将“多对多关系”同样抽象为“实体”来实现。但仍然是通过 对象引用 或 对象数组/List等形式的引用 实现的。 从实例中可以看出，Student 与 Course 之间原本直接的多对多关系被转换成了：  Student 与 CourseRegistration 的一对多关系 Course 与 CourseRegistration 的一对多关系 CourseRegistration 与 Student, Course 的一对一关系    One more thing\u0026hellip;（事实上是主题相关的更多内容） 在前段时间的实习期间设计数据库时，两次遇到这个问题；同时前段时间在一次上机考试中，又遇到了这个问题。\n  第一次时，没有找到合适的相关资料，同时秉持着一个现在看来并不恰当的信念：“实体类对应实体表”。因此，解决方法比较粗暴，当时直接将额外字段加到了某一张表之中。下面是当时的情景：（括号中为对应于上面的案例）\n 工人（学生）拥有（选课）技能（课程），额外需要一个字段表示工人对技能的熟练程度（成绩）。 看起来和上面的场景二就是一模一样呀🙃然而当时我并没有想到场景二中的解决方法，而是把“工人对技能的熟练程度”这个字段加到了技能表中。还算幸运的是，技能熟练程度只分为三个级别。    那段时间，又恰巧碰到了一门考试，遇到了同样的问题，然后正在上机考试的我，突发奇想地想到了这个办法来解决这个问题。但当时设计的类同样存在缺陷。\n 题目描述：  设计一个机票销售网站提供机票在线销售功能。客户登录系统后，可以查看航班列表，以及剩余机票数量，可以进行机票的购买，可以查看已购机票情况，对已购机票在规定的日期期限内可以退票。   数据库要求：  客户表(Id, 身份证号, 姓名, 电话, 密码) 机票表(Id, 航班号, 起飞时间, 价格, 剩余数量) 机票购买表(Id, 客户Id, 机票Id, 购票日期, 退票标志, 退票日期)   我的实体类设计（Java, 此处省略 getter, setter）：  Client.java  public class Client { private int id; private String govNumber; private String fullName; private String phoneNumber; private String password; private List\u0026lt;Ticketing\u0026gt; ticketingList; }  Ticket.java  public class Ticket { private int id; private String flightNumber; private Date takeOffTime; private double price; private int avaliable; private List\u0026lt;Client\u0026gt; clientList; }  Ticketing.java  public class Ticketing { private int id; private Client client; private Ticket ticket; private Date ticketingDate; private int cancelRemark; private Date cancelDate; }   发现我当时的问题出在哪里了么？如果找到了，欢迎在评论区留言哦~😀（我就先不明说咯，逃\n  第三次遇到此问题\n 自认为此次解决方法算是符合业界规范 😂 如果文章中有什么错误之处，烦请指出，感谢。 如下图所示，通过 Arrangement 实体连接其他三个实体。     ","permalink":"https://hiwangzi.com/posts/2017/05/26/po-in-many-to-many-relationship/","summary":"介绍 在之前的 Entity Framework 快速上手介绍 之中，两个实体之间只是简单的一对一关系，而在实际的应用场景中，还会出现多对多关系，同时还有可能会出现多对多关系还附带有其他字段的情况。\n下面以几个例子，对表间多对多关系的类表示加以更加详细地描述。虽然两个场景举例是使用的 C# 及 Entity Framework(Model First) 框架自动生成数据库、实体类。但这种设计方法，并不只是在使用 ORM 框架时需要，事实上，它是 POCO 及简单 Java 类（POJO）的设计原则之一。\n场景实例 场景一 在考虑多对多关系还附带有字段的情况之前，让我们先看一下，多对多关系但不附带额外字段的情况下，实体类代码的表示。\n此处使用 Entity Framework(Model First)，快速将 model diagram 转为数据库中的表及实体类。\n假设的场景是学生选课，一名学生可以选多门课，一门课也可以被多个学生选择。E-R 图如下所示： 对应自动生成的数据库如下：\n StudentSet  CourseSet  CourseRegistrationSet  其中 Course_Id 与 Students_Id（注：此处词尾(s)负数的原因参见上面 E-R 图中右边的 Properties 中 End1 Navigation Property 的设置）分别以另外两张数据表的 Id 主键作为外键。 同时 Course_Id 与 Students_Id 两者联合做 CourseRegistrationSet 表的主键。    对应自动生成实体类的代码如下：\n Student.cs namespace Model { using System; using System.","title":"数据库表间多对多关系（附带额外字段）的实体类（POJO 或 POCO）表示"},{"content":"开始学习这门课程，是源自一次无意间的发现。上一周时看到金老师的博客，觉得内容非常不错，这才开始了这门课程的学习。\n面向对象软件开发实践之基本技能训练 - 网易云课堂\n 这门课能告诉他们：一个有用的软件到底是如何诞生的，我们在学校里学的操作系统、数据结构等专业课程到底在开发中是怎样应用的……\n 以下是本课程第一单元的笔记：\n工具 .NET Reference Source 在此之前，有一次也想查看微软类库的源代码，可在 Visual Studio 中使用 F12 可以查看到的，仅仅只是定义，并没有对应的实现。那时还在想，难道是微软仅仅只是开放定义给开发人员。后来在网络上也没有搜索到相关内容（那时不知道如何描述，也没有找到合适的人请教），直到在这门课程中看到金老师的演示，才了解到微软的 .NET Framework 框架源码是完全开放的。\n查看方式有两种：\n  直接在 .NET Reference Source 网站中在线浏览。\n  通过配置，在 Visual Studio 中调试 .NET Framework 源码。 具体配置方法参考：\n 微软开放了.NET 4.5.1的源代码 .NET Framework 4.5.1 已正式开源 配置Visual Studio 以调试.net framework的源代码    ildasm IL 反汇编程序是 IL 汇编程序 (Ilasm.exe) 的配套工具。Ildasm.exe 可利用包含中间语言 (IL) 代码的可移植可执行 (PE) 文件，并创建适合输入到 Ilasm.exe 的文本文件。此工具自动随 Visual Studio 一起安装。\n命令行方式使用文档说明：Ildasm.exe（IL 反汇编程序）\n如果已经安装了 Visual Studio 的话，可以在这个目录（C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.6.1 Tools）下找到这个程序。实际情况取决于 Visual Studio 的版本，所以路径中的版本数字也可能会有所不同。\nilspy ILSpy is the open-source .NET assembly browser and decompiler.\n这个工具可以帮助我们将 .NET 可执行程序反汇编出 C# 源代码。官网地址：http://ilspy.net/\n关于 .NET 未完待续\u0026hellip;\n","permalink":"https://hiwangzi.com/posts/2017/03/25/oop-practice-csharp-note-1/","summary":"开始学习这门课程，是源自一次无意间的发现。上一周时看到金老师的博客，觉得内容非常不错，这才开始了这门课程的学习。\n面向对象软件开发实践之基本技能训练 - 网易云课堂\n 这门课能告诉他们：一个有用的软件到底是如何诞生的，我们在学校里学的操作系统、数据结构等专业课程到底在开发中是怎样应用的……\n 以下是本课程第一单元的笔记：\n工具 .NET Reference Source 在此之前，有一次也想查看微软类库的源代码，可在 Visual Studio 中使用 F12 可以查看到的，仅仅只是定义，并没有对应的实现。那时还在想，难道是微软仅仅只是开放定义给开发人员。后来在网络上也没有搜索到相关内容（那时不知道如何描述，也没有找到合适的人请教），直到在这门课程中看到金老师的演示，才了解到微软的 .NET Framework 框架源码是完全开放的。\n查看方式有两种：\n  直接在 .NET Reference Source 网站中在线浏览。\n  通过配置，在 Visual Studio 中调试 .NET Framework 源码。 具体配置方法参考：\n 微软开放了.NET 4.5.1的源代码 .NET Framework 4.5.1 已正式开源 配置Visual Studio 以调试.net framework的源代码    ildasm IL 反汇编程序是 IL 汇编程序 (Ilasm.exe) 的配套工具。Ildasm.exe 可利用包含中间语言 (IL) 代码的可移植可执行 (PE) 文件，并创建适合输入到 Ilasm.exe 的文本文件。此工具自动随 Visual Studio 一起安装。","title":"《面向对象软件开发实践》笔记一"},{"content":"起因 因为实习的原因，程序之中用到了较多的数据库操作逻辑。如果每一处数据库操作都手写的话，工作量较大且后期不易于维护，所以希望能通过 ORM 框架来解决这两个问题。\n在昨天之前，对于 ORM 这个词汇，我也仅仅只是在上个学期的 Java EE 课上看企业老师“神速”地使用 Hibernate 做了建立数据库、插入数据的演示。\n这两天花了很多时间了解 Entity Framework，终于在今晚成功地实现了“查插删改”，中间经过了很多的波折。例如：查找的很多资料提供的代码都是不完整的，同时他们的讲解也不够“新人（菜鸟）友好型”。所以我决定把一个简单的实例的具体步骤写出来，帮助像我这样的菜鸟快速将 EF(Entity Framework) 应用起来。\n如果博文有不当之处，欢迎指出，谢谢~\n简介 首先是两个概念\n  对象关系映射（英语：Object Relational Mapping，简称 ORM，或 O/RM，或 O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。简单来说，就是可以把一条数据库记录转换为程序中的一个对象，或者反向转换，当然实际上 ORM 可以做更多的事情。）\n  Entity Framework (又称ADO.NET Entity Framework) 是微软以 ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。\n  使用 Entity Framework 在实际数据库相关代码开发中可以采取三种方式：\n DB First：先开发数据库，然后借助 Visual Studio 将数据库中的表结构（或视图）转换为程序中实体模型类。 Code First：直接在程序中定义实体模型类，然后借助 Visual Studio 将其转换为数据库中的表。 Model First：借助 Visual Studio 中的可视化设计工具，设计好数据模型（可以理解为E-R图），然后转换为数据库中的表。  本实例采用第三种方式，即 Model First。\n实例演示 本实例使用的是 Visual Studio 2017(Community)，通过一个 WinForm 程序访问 SQL Server 2016(Express) 数据库来演示。\n本程序可以实现学生信息的自我维护，包括对用户名、密码、性别、班级、电话等资料的处理。学生可以填写信息注册账号，然后使用账号登录查看自己的信息，并对自己的信息进行修改。\n演示：\n数据实体 两个实体：\n  用户（用户名，密码）\n  个人资料（学号，姓名，性别，电话，地址，爱好）\n  具体步骤 1. 新建一个名为 Sstudent 的 WinForm 程序项目 2. 新建一个名为 Model 的类库项目（可选） 3. 新增一个名为 Sstudent 的 ADO.NET Entity Data Model 3.1 在向导中选择空的实体设计器模型 3.2 然后就可以开始创建自己的实体模型 这里首先从工具栏拖出两个 Entity 。\n此时我们观察一下属性区，这里有两项比较重要的属性，如下图\n其中 Name 可以理解为对应将来的数据库表中的一条记录的名字，Entity Set Name 对应的则是一张表的名字。这里修改一下，即用户表（或用户集，UserSet）中会有多条用户记录（User）。\n再来观察一下实体中的属性，在我们创建 Entity 的时候，会自动产生一个名为 Id 的非空自增实体键，如下图所示。\n现在我们完善一下两个实体的属性，这里为了简便，所有的属性都设置为了 String 类型，对应到数据库即为 nvarchar(MAX)。这里其中一个属性用中文命名是想说明，C# 对中文是完全支持的。\n在完成了实体的创建之后，下一步进行实体之间关系的创建，同样从工具栏中拖出一个关系到两个实体之间，因为用户与个人资料之间的关系是 1对1，所以选中关系后，在属性区修改其对应关系。\n然后，在操作区点击右键，选择从模型生成数据库，根据指引，即可完成数据库的建立。\n如果之前没有数据库连接的话，点击“新建连接”选项，按照你的需求选择，这里选择 SQL Server，输入相关信息后，即可完成连接的建立。\n补充：如果此处输入的数据库名不存在，会自动创建对应数据库。\n然后按照提示，可以得到自动生成的 SQL 文件，点击绿色按钮执行即可（此处同样要求输入数据库的账号密码）。\n在完成创建后，到SQL Server Management Studio 中查看数据库即可发现，表已经被创建。\n因为实体之间是 1对1 的关系，所以不会创建新的关系表，而是将其中一张表的主键附加到另一张表中，如下图所示。\n4. 下面来说一说如何通过创建的模型来访问数据库。 4.1 先来看一下 EF 框架帮我们创建的文件，如下图所示。 4.2 我们新建一个名为 UI 的项目，用于展现界面与接受用户操作。因为本项目同样直接使用 EF 框架，所以在此项目中也需要引用 Entity Framework，同时引用 Model 项目。 (1) 使用 Nuget 引用 Entity Framework。\n(2) 引用同解决方案的另一个项目 Model。\n然后就可以方便地如下图所示一般使用“数据库”了，下图所示为两个实体对象集（可理解为数据表）。\n4.3 通过 EF 框架实现查询功能。 // 登录 private void button_Login_Click(object sender, EventArgs e) { // 使用 EF 框架实现查询 User u=sstudentContainer.UserSet.Where(user =\u0026gt; user.Userame == textBox_Username.Text \u0026amp;\u0026amp; user.Password == textBox_Password.Text).FirstOrDefault(); // 如果查询不到，会返回 null if (u != null) { new MyProfile(u).Show(); this.Hide(); } else { MessageBox.Show(\u0026quot;用户名或密码错误，请重试！\u0026quot;); } } 4.4 通过 EF 框架实现插入功能。 // 注册 private void button_Signup_Click(object sender, EventArgs e) { try { // 使用 EF 框架实现添加新数据功能 User u = new User(); Profile p = new Profile(); u.Password = this.textBox_Password.Text; u.Userame = this.textBox_Username.Text; p.Address = this.textBox_Address.Text; p.Hobby = this.textBox_Hobby.Text; p.PhoneNumber = this.textBox_PhoneNumber.Text; p.Sex = this.textBox_Sex.Text; p.StudentNumber = this.textBox_StudentNumber.Text; p.姓名 = this.textBox_FullName.Text; u.Profile = p; // 添加两个新对象分别进入两张表 sstudentContainer.UserSet.Add(u); // 因为 EF 会自动将关联的对象同时加入数据库，所以无需手动增加 //sstudentContainer.ProfileSet.Add(p); // 保存新增记录进入数据库 sstudentContainer.SaveChanges(); MessageBox.Show(\u0026quot;注册成功！\u0026quot;); this.Close(); } catch (Exception) { MessageBox.Show(\u0026quot;抱歉，注册失败！\u0026quot;); throw; } } 4.5 通过 EF 框架实现删除功能。 // 删除用户所有资料 private void button_Delete_Click(object sender, EventArgs e) { // 使用 EF 框架实现删除数据 try { // 需要首先使用 sstudentContainer 查找到该项记录（对象），然后将其删除 User u = sstudentContainer.UserSet.Where(user =\u0026gt; user.Id == this.user.Id).FirstOrDefault(); Profile p = u.Profile; // 删除用户 sstudentContainer.ProfileSet.Remove(p); sstudentContainer.UserSet.Remove(u); // 保存删除操作进入数据库 sstudentContainer.SaveChanges(); MessageBox.Show(\u0026quot;再见，删除成功！\u0026quot;); this.Close(); } catch (Exception) { // 发生异常，删除失败 MessageBox.Show(\u0026quot;抱歉，删除失败！\u0026quot;); throw; } } 4.6 通过 EF 框架实现更新功能。 // 更新用户资料 private void button_Update_Click(object sender, EventArgs e) { // 使用 EF 框架实现更新数据 try { // 需要首先使用 sstudentContainer 查找到该项记录（对象），然后对其进行修改 User u = sstudentContainer.UserSet.Where(user =\u0026gt; user.Id == this.user.Id).FirstOrDefault(); Profile p = u.Profile; u.Password = this.textBox_Password.Text; u.Userame = this.textBox_Username.Text; p.Address = this.textBox_Address.Text; p.Hobby = this.textBox_Hobby.Text; p.PhoneNumber = this.textBox_PhoneNumber.Text; p.Sex = this.textBox_Sex.Text; p.StudentNumber = this.textBox_StudentNumber.Text; p.姓名 = this.textBox_FullName.Text; // 保存更改进入数据库 sstudentContainer.SaveChanges(); MessageBox.Show(\u0026quot;更新资料成功！\u0026quot;); } catch (Exception) { // 发生异常，更新失败 MessageBox.Show(\u0026quot;更新资料失败！\u0026quot;); throw; } } 4.7 当我们尝试运行程序的时候，会发现出现异常，这是因为在 UI 项目中缺少了数据库连接字符串，即下图中的选中部分。只要将其复制，即可。 补充 EF 能帮我们做的事情还有很多，例如可以方便快捷地通过 ToList() 方法直接将数据库中所有数据转换为对象List。而本文只是一个简单的入门实例，只是仅仅帮助初次接触 EF 摸不到头脑的新手快速实战应用，需要学习的还有很多。如果本文有任何错误或不当之处，敬请指出，共同进步，谢谢~\n附上源代码：下载地址\n补充一个不错的视频（但是其中的实例演示并没有成功）：\nEntity Framework 實戰技巧 - YouTube\nCode First 实例可以参考：\nEntity Framework(EF) Code First 多对多关系的实体增，删，改，查操作全程详细示例\n其他可能对你有帮助的链接：\n  ORM框架之EntityFramework介绍\n  Entity(Ado.net) - zezhi821的专栏\n  ","permalink":"https://hiwangzi.com/posts/2017/03/24/entity-framework-newbie-sample/","summary":"起因 因为实习的原因，程序之中用到了较多的数据库操作逻辑。如果每一处数据库操作都手写的话，工作量较大且后期不易于维护，所以希望能通过 ORM 框架来解决这两个问题。\n在昨天之前，对于 ORM 这个词汇，我也仅仅只是在上个学期的 Java EE 课上看企业老师“神速”地使用 Hibernate 做了建立数据库、插入数据的演示。\n这两天花了很多时间了解 Entity Framework，终于在今晚成功地实现了“查插删改”，中间经过了很多的波折。例如：查找的很多资料提供的代码都是不完整的，同时他们的讲解也不够“新人（菜鸟）友好型”。所以我决定把一个简单的实例的具体步骤写出来，帮助像我这样的菜鸟快速将 EF(Entity Framework) 应用起来。\n如果博文有不当之处，欢迎指出，谢谢~\n简介 首先是两个概念\n  对象关系映射（英语：Object Relational Mapping，简称 ORM，或 O/RM，或 O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。简单来说，就是可以把一条数据库记录转换为程序中的一个对象，或者反向转换，当然实际上 ORM 可以做更多的事情。）\n  Entity Framework (又称ADO.NET Entity Framework) 是微软以 ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。\n  使用 Entity Framework 在实际数据库相关代码开发中可以采取三种方式：\n DB First：先开发数据库，然后借助 Visual Studio 将数据库中的表结构（或视图）转换为程序中实体模型类。 Code First：直接在程序中定义实体模型类，然后借助 Visual Studio 将其转换为数据库中的表。 Model First：借助 Visual Studio 中的可视化设计工具，设计好数据模型（可以理解为E-R图），然后转换为数据库中的表。  本实例采用第三种方式，即 Model First。","title":"Entity Framework 新手入门友好实例"},{"content":"计算机科学及编程导论在 MIT 的课程编号是 6.00.1，是计算机科学及工程学院的经典课程。之前，课程一直使用 Scheme 作为教学语言，不过由于 Python 简单、易学等原因，近年来已经改用 Python 作为教学语言了。（更多介绍）\n最初知道这个课程的时候大概是在 2014 年，对于做事拖沓的我，这门课程已经从低清随堂录制变成了 edX 平台的一门 高清的 MOOC，转眼间已经大三，希望自己能够完成自己曾经定下的计划。以下是在我在学习本课程时的一些笔记，在此与大家共享、共勉。\nWhat does a computer do?   Fundamentally a computer:\n Performs some calculations Remembers results    What calculations?\n Built in primitives Creating our own methods of calculating    Simple calculations are not enough, so good algorithm design also needed to accomplish a task.\nDespite its speed and storage, a computer does have limitations\n Some problems still too complex Some problems are fundamentally impossible to computer (e.g. Turing\u0026rsquo;s Halting Problem)   Knowledge  Declarative Imperative (likes a recipe, \u0026ldquo;how-to\u0026rdquo;)  Computers  Fixed-program computers (earliest computers) To solve specific problems  Atanasoff (1941) - linear equations Turing bombe   Stored-program computers  Program is a recipe. Each programming language provides a set of primitive operations. Given a fixed set of primitives, a good programmer can program anything. Anything you can do with a language, you can do with another.  About python  High(✅) vs. Low General(✅) vs. Targetted Interpreted(✅) vs. Compiled  Aspects of languages \u0026amp; Common Errors    Aspects Description     Primitive constructs numbers, strings, simple operators   Syntax which strings of charactres and symbols are well-formed   Static semantics which syntactically valid strings have a meaning   Full semantics what is the meaning associated with a syntactically correct string of symbols with no static semantic errors     语法用来描述语言中，什么表述是合法的。 静态语义表示什么程序是有意义的，哪种表达是有意义的。 完整语义即程序想达到什么目的，运行程序会产生什么效果。  Goal  Learn the syntax and semantics of a programming language. Learn how to use those elements to translate “recipes” for solving a problem into a form that the computer can use to do the work for us. Computational modes of thought enable us to use a suite of methods to solve problems.  References  MIT麻省理工学院公开课：计算机科学及编程导论 Python 笔记1-3 麻省理工公开课《计算机科学及编程导论》中文笔记（第1讲） 【MIT计算机科学与编程导论】打卡及笔记  ","permalink":"https://hiwangzi.com/posts/2017/02/10/mit-introduction-to-computer-science-and-programming-in-python-note-1/","summary":"计算机科学及编程导论在 MIT 的课程编号是 6.00.1，是计算机科学及工程学院的经典课程。之前，课程一直使用 Scheme 作为教学语言，不过由于 Python 简单、易学等原因，近年来已经改用 Python 作为教学语言了。（更多介绍）\n最初知道这个课程的时候大概是在 2014 年，对于做事拖沓的我，这门课程已经从低清随堂录制变成了 edX 平台的一门 高清的 MOOC，转眼间已经大三，希望自己能够完成自己曾经定下的计划。以下是在我在学习本课程时的一些笔记，在此与大家共享、共勉。\nWhat does a computer do?   Fundamentally a computer:\n Performs some calculations Remembers results    What calculations?\n Built in primitives Creating our own methods of calculating    Simple calculations are not enough, so good algorithm design also needed to accomplish a task.\nDespite its speed and storage, a computer does have limitations","title":"MIT 计算机科学及编程导论Python 笔记 1"},{"content":"IntelliJ 作为一款强大的 Java 开发 IDE，售价自然也不会低。但是对于学生或教师来说，JetBrains 开发工具免费提供给学生和教师使用。而且取得一次授权后只需要使用相同的 JetBrains 帐号就可以激活其他产品，不需要重复申请。\n个人申请步骤如下：   打开 申请页面 ，点击 “APPLY NOW” 开始申请。\n  填写姓名，以及学校提供给你的邮箱（邮箱地址要 edu.cn 结尾）   下一步后，进入邮箱查看（如果收件箱没有找到，请查看是否为误判丢进了“垃圾邮件”）   点击 “Confirm Request” 进行确认，打开的网站会提示你注册 JetBrains 账号，输入账号与密码后，再次确认。\n  回到邮箱，刷新，此时点击 “Active Educational License”   成功的获得授权码。   官网下载开发工具，以 IntelliJ 为例（注意下载Ultimate版本），2016.3.4版本直接下载地址在此。\n  可以直接通过之前注册的 JetBrains 帐号激活产品。   激活完成，Help-\u0026gt;Register验证。   注意：  申请的 Lisence 有效期为一年，在到期后，可以去官网重新认证。 一个 Lisence 可以在多台设备验证，但同时使用的只能为1台，参考网站。 更多的学生优惠资源在此。 最后，引用第3条中作者的一句话，“希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠资格，不要作践自己作为学生的价值”，谢谢！  ","permalink":"https://hiwangzi.com/posts/2017/02/10/how-to-apply-jetbrains-education-license/","summary":"希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠资格，不要作践自己作为学生的价值","title":"JetBrains 套装免费学生授权申请（IntelliJ, WebStorm...）"},{"content":"10月是个忙碌的月份，总感觉每天都是匆匆忙忙，人生何其短……\n从上个学期末就在计划的教务系统爬虫在10月终于开始真正的实施。这个月以来，大概每个周末都在尝试推进，可大多数时候都是只做一小会儿就不知道干什么去了……一直到上上个周末，抱着一种写不出来就不睡觉的精神，花了大概一天的时间。但是，然而并没有主角光环，在最后一个关键的页面上，出现了目前我无法解决的问题（某一过程陷入死循环）。请教了几个人，还是没有解决，只能等这个学期闲下来或者寒假里，再继续研究了。\n这个月，参加的活动比较多。参加了深度的开发者与用户大会（DDUC），又去现场看了老罗的相声；最近又接连熬夜两天，从吃瓜到吃惊的看完了微软与苹果的发布会。\n先说深度吧。可以说，深度是我在国内最为佩服的企业（至少目前），在国内一票儿骗拨款的各种国产 Linux 的“辣眼睛”中，作为一家私企，真的是一股清流。我觉得评价“Deepin 做到了小白开箱即用、好用”一点都不过分，我最喜欢的就是它的应用商店了，真的是极大的缓解了我这种“半吊子水平”的用户的 Software Panic。在现场，听了王勇（不过说起来，在去之前我并不知道深度的老板是谁，补充他也是产品经理）的演讲，也才意识到，其实深度也只是小公司，人微言轻，认真做事并活下去也是挺难的。另外，最喜欢王勇讲的一点是“独立思想 创造贡献 最后才是分享”，他觉得这才是开源社区的本质。非常认同这一点，所以，好好做事，然后才是分享。\n再说说锤子发布会吧。之前对于锤子其实并不了解，知道锤子还是因为当时王自如与罗永浩的现场论战，所以这次去的时候，还和朋友戏谑说“说不定是锤子的最后一场发布会”，似乎现在看来锤子成功的活下去了。虽然锤子M1并没有激发我的购买欲，但Smartisan OS 也还是有一些亮点的。通过不同的手指指纹解锁屏幕，可以快速的打开支付宝或者微信支付的二维码界面、大爆炸分词都挺不错的。\n虽然罗永浩总是不停地撕逼，甚至在本次发布会也要黑一下苹果……但他能够介绍很长时间的讯飞等企业，同时承诺以后会把 One Step 开源，这让我对其的好感度提高不少。或许，全靠国内其他友商照应吧。\n10月尾声，微软与苹果接连分别召开了自己的新品发布会。总体来讲，感觉都不够让人眼前一亮，或许是因为之前看过太多爆料新闻了吧。不过，Surface Dial让我感觉还不错，以一种简单的方式补足了单纯依靠触摸屏时某些操作不便的不足。就如同之前提到的锤子通过验证不同指纹来打开支付宝或微信二维码。\n而说到苹果，在库克对场内观众说可以去后场体验一下新产品的时候，熬夜到3点看完接近两个小时的发布会，让接下来还有两场考试的我，不由得想讲“裤脱看”。发布会一半的时间在演示“神奇的”Touch Bar，真是尴尬症都犯了，而到了 DJ 上台用新款 Macbook Pro 来打碟的时候，我只想说“WTF”。如果 DJ 需要触摸操作的话，那么他需要的应该是 iPad 吧。\n在我看来，4个 type-c 可以说代表了未来的趋势，可问题在于，既然 Macbook Pro 都采用了 type-c，为什么不能统一一下，让 iPhone 也换上新接口呢？因为混乱的接口导致需要各种转接器，这还是我心中代表着优质产品的苹果么？\n如果说已经阉割了 Touch Bar 的新款13吋 mbp，同时又阉割一系列配置是为了区分价位，可是为什么还有再阉割掉两个接口？这次发布会最让我印象深刻的不是什么产品，而是精明商人库克。15吋低配价格直涨￥5000；new macbook参数不变，价格直涨￥600……\n在气愤两天之后，我想明白了，还是我太穷了（滑稽 （哭泣\n这个周末，“准备”了1个月的腾讯云校园工作坊终于在昨晚办完了……从最开始准备要筛选报名者，再到线上宣传期间，中间态度的转变很有趣。宣传期间，寥寥无几的报名者，让我一度以为，能来十几个人就已经非常不错了。幸运的是，最终还是接近30个到场的参与者。虽然过程与最终结果都与我想象中的不同，但和小伙伴们一起做成一件事还是非常开心的。\n现在想来，活动策划期间，最值得注意的就是团队沟通。大致有以下几点吧：\n 人数众多的 IM 沟通群会让人抓狂，尤其不限制交流话题的时候； 与他人沟通要注意反馈，不要想象对方拥有和你一样的思维； 注意说话的语气，“说者无意，听者有心”并非只是一句谚语。 无论如何，这大概就是我10月里值得讲述的事了……  好好做事才是真！\n以上。\n","permalink":"https://hiwangzi.com/posts/2016/10/31/october-2016/","summary":"10月是个忙碌的月份，总感觉每天都是匆匆忙忙，人生何其短……","title":"我的十月"},{"content":"2016年9月30日，网信办正式发布《未成年人网络保护条例（草案征求意见稿）》。最早看到这条信息是在知乎（ 网瘾即将合法化，绿坝将强奸全部智能设备 ）。因为对其中的某些条例存在意见，故写了电邮反馈。\n同时希望大家也可以将自己的意见通过电邮的形式表达，条例内容及反馈方式在此：\n国家互联网信息办公室关于《未成年人网络保护条例（草案征求意见稿）》公开征求意见的通知-中共中央网络安全和信息化领导小组办公室\n截止日期是2016年10月31日。\n我的邮件内容如下：\n 您好，\n关于这份草案，作为一名已经上网近10年的网民，我有如下意见：\n  网瘾并不是疾病，不需要治疗。草案中第二十条如此表述：\n 第二十条 教育、卫生计生等部门依据各自职责，组织开展预防未成年人沉迷网络的教育，对未成年人网络成瘾实施干预和矫治。\n县级以上人民政府及其教育行政部门应当为中小学校配备专门教师或提高教师专业水平，增强对未成年人沉迷网络的早期识别和干预能力，并可以通过购买服务等方式提供预防和干预未成年人沉迷网络的教育或服务。\n国务院卫生计生部门会同有关部门推动出台网络成瘾的本土化预测和诊断测评系统，制定诊断、治疗规范。\n 可是截至目前为止，国际社会上并无任何临床标准证明网瘾属于疾病。难道只有我国的青少年独有此病？所以治疗矫正，自然无稽之谈。此种举动，将会使社会上出现越来越多的杨永信之流，带给青少年的反而是更多的伤害。\n  我认为对于智能终端设备，不应当强制要求出厂时、销售前安装未成年人上网保护软件。草案中第十二条表述如下：\n 第十二条 智能终端产品制造商在产品出厂时、智能终端产品进口商在产品销售前应当在产品上安装未成年人上网保护软件，或者为安装未成年人上网保护软件提供便利并采用显著方式告知用户安装渠道和方法。\n 我认为仅保留最后一句表述即可，即\n 智能终端产品制造商应当为安装未成年人上网保护软件提供便利并采用显著方式告知用户安装渠道和方法。\n 因为使用智能终端的用户群体中，不止未成年人，还有成年人。对于成年人而言，是拥有能力辨别有害信息的，不需要国家统一划定范围。\n  我认为保护青少年不受到网络伤害、不沉迷网络的最重要解决途径应当是为青少年增加更多的公益场所、公益娱乐项目。\n现在青少年更多地喜欢上网的原因一方面是因为网络世界很精彩，可很重要的另一方面也是他们闲暇时要么无处可去，要么就要花费大量金钱才可以参加绘画、音乐等娱乐活动。\n相较于发达国家，我们国家城市中公益性质的活动场所太少。例如，国外的青少年暑假可以在公共游泳馆愉快玩耍，而我们的青少年却要花费百元乃至千元才可以得到同样的娱乐机会。\n自然，免费或说低成本的互联网更吸引青少年的注意力。同时，这也是寒门子弟得到知识、提升综合素质成本最低的方式。如果政府再进一步限制青少年上网，那么我国的阶层固化将进一步严重。\n  以上是我的一点看法，感谢您的阅读，同时希望您能认真考虑一下以上三点意见。\n谢谢！\n2016年10月4日\n","permalink":"https://hiwangzi.com/posts/2016/10/04/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%88%90%E5%B9%B4%E4%BA%BA%E7%BD%91%E7%BB%9C%E4%BF%9D%E6%8A%A4%E6%9D%A1%E4%BE%8B%E8%8D%89%E6%A1%88%E5%BE%81%E6%B1%82%E6%84%8F%E8%A7%81%E7%A8%BF%E7%9A%84%E6%84%8F%E8%A7%81/","summary":"2016年9月30日，网信办正式发布《未成年人网络保护条例（草案征求意见稿）》。最早看到这条信息是在知乎（ 网瘾即将合法化，绿坝将强奸全部智能设备 ）。因为对其中的某些条例存在意见，故写了电邮反馈。\n同时希望大家也可以将自己的意见通过电邮的形式表达，条例内容及反馈方式在此：\n国家互联网信息办公室关于《未成年人网络保护条例（草案征求意见稿）》公开征求意见的通知-中共中央网络安全和信息化领导小组办公室\n截止日期是2016年10月31日。\n我的邮件内容如下：\n 您好，\n关于这份草案，作为一名已经上网近10年的网民，我有如下意见：\n  网瘾并不是疾病，不需要治疗。草案中第二十条如此表述：\n 第二十条 教育、卫生计生等部门依据各自职责，组织开展预防未成年人沉迷网络的教育，对未成年人网络成瘾实施干预和矫治。\n县级以上人民政府及其教育行政部门应当为中小学校配备专门教师或提高教师专业水平，增强对未成年人沉迷网络的早期识别和干预能力，并可以通过购买服务等方式提供预防和干预未成年人沉迷网络的教育或服务。\n国务院卫生计生部门会同有关部门推动出台网络成瘾的本土化预测和诊断测评系统，制定诊断、治疗规范。\n 可是截至目前为止，国际社会上并无任何临床标准证明网瘾属于疾病。难道只有我国的青少年独有此病？所以治疗矫正，自然无稽之谈。此种举动，将会使社会上出现越来越多的杨永信之流，带给青少年的反而是更多的伤害。\n  我认为对于智能终端设备，不应当强制要求出厂时、销售前安装未成年人上网保护软件。草案中第十二条表述如下：\n 第十二条 智能终端产品制造商在产品出厂时、智能终端产品进口商在产品销售前应当在产品上安装未成年人上网保护软件，或者为安装未成年人上网保护软件提供便利并采用显著方式告知用户安装渠道和方法。\n 我认为仅保留最后一句表述即可，即\n 智能终端产品制造商应当为安装未成年人上网保护软件提供便利并采用显著方式告知用户安装渠道和方法。\n 因为使用智能终端的用户群体中，不止未成年人，还有成年人。对于成年人而言，是拥有能力辨别有害信息的，不需要国家统一划定范围。\n  我认为保护青少年不受到网络伤害、不沉迷网络的最重要解决途径应当是为青少年增加更多的公益场所、公益娱乐项目。\n现在青少年更多地喜欢上网的原因一方面是因为网络世界很精彩，可很重要的另一方面也是他们闲暇时要么无处可去，要么就要花费大量金钱才可以参加绘画、音乐等娱乐活动。\n相较于发达国家，我们国家城市中公益性质的活动场所太少。例如，国外的青少年暑假可以在公共游泳馆愉快玩耍，而我们的青少年却要花费百元乃至千元才可以得到同样的娱乐机会。\n自然，免费或说低成本的互联网更吸引青少年的注意力。同时，这也是寒门子弟得到知识、提升综合素质成本最低的方式。如果政府再进一步限制青少年上网，那么我国的阶层固化将进一步严重。\n  以上是我的一点看法，感谢您的阅读，同时希望您能认真考虑一下以上三点意见。\n谢谢！\n2016年10月4日","title":"关于《未成年人网络保护条例（草案征求意见稿）》的意见"},{"content":"要求如下： source string: mmmmmmynameismickeym separator: m result string []: {\u0026quot;m\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;yna\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;eis\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;ickey\u0026quot;, \u0026quot;m\u0026quot;} 思路分析： 1 判断 source string 是否包含 separator 1.1 若不包含，则将其包装为 string 数组返回 1.2 若包含，则进行下列操作 2 将 source string 转换为 char 数组 3 对数组每个字符依次进行检测（循环） 3.1 若不为分隔符，则先将内容存入临时 string 变量 temp 3.2 若为分隔符，则检测 temp 是否为空 - 若 temp 不为空，则先将 temp 变量的值写入 result 数组 - 将分隔符写入 result 数组 4 循环体外，检查 temp 变量是否为 null - 若不为空，则将其写入 result 数组 - 返回 string 数组 result 代码： // 需要引入命名空间 // using System; // using System.Linq;  static string[] splitString(string source_str, char separator) { //1. 判断 source string 是否包含 separator  //1.1 string 中不包括分隔符  if (source_str.IndexOf(separator) == -1) { //为了返回原字符串，将其包成一个只有一项的string数组返回  string[] source_str_pack = new string[1]; //试一试string[source_str]  source_str_pack[0] = source_str; return source_str_pack; } //1.2 string 中包括分隔符  else { //2. 将 source_str 转换为 char 数组  char[] source = source_str.ToCharArray(); string temp = null; int resultID = 0; string[] result = new string[source.Length];//这样的结果会有大量的 null 元素，后面在返回结果前，进行处理去除无用的 null 元素  //3. 对数组每个字符依次进行检测  for (int i = 0; i \u0026lt; source.Length; i++) { //3.1 若不为分隔符，则先将内容存入临时 string 变量 temp  if (source[i].Equals(separator) == false) { if (temp == null) { temp = \u0026#34;\u0026#34;; } temp = temp.Insert(temp.Length, source[i].ToString()); } //3.2 若为分隔符，则检测 temp 是否为空  else { //temp不为空，先将 temp 变量的值写入 result 数组  if (temp != null) { result[resultID] = temp; resultID++; temp = null; } //将分隔符写入 result 数组  result[resultID] = source[i].ToString(); resultID++; } } //4. 检查 temp 变量是否为 null  //若不为空，先将其写入 result 数组  if (temp != null) { result[resultID] = temp; resultID++; temp = null; } //返回 string 数组 result  //后面在返回结果前，进行处理去除无用的 null 元素  result = result.Where(s =\u0026gt; !String.IsNullOrEmpty(s)).ToArray(); return result; } } ","permalink":"https://hiwangzi.com/posts/2016/09/04/split-string-into-array-by-specific-separator-in-csharp/","summary":"mmmmmmynameismickeym -\u0026gt; [\u0026ldquo;m\u0026rdquo;, \u0026ldquo;m\u0026rdquo;, \u0026ldquo;m\u0026rdquo;, \u0026ldquo;m\u0026rdquo;, \u0026ldquo;m\u0026rdquo;, \u0026ldquo;m\u0026rdquo;, \u0026ldquo;yna\u0026rdquo;, \u0026ldquo;m\u0026rdquo;, \u0026ldquo;eis\u0026rdquo;, \u0026ldquo;m\u0026rdquo;, \u0026ldquo;ickey\u0026rdquo;, \u0026ldquo;m\u0026rdquo;]","title":"C#指定并保留分隔符，字符串转数组"},{"content":" 难以想象的晴朗  ","permalink":"https://hiwangzi.com/about/","summary":"about","title":"值得探访的星球"}]